
    package Web::HTML::Parser;
    use strict;
    use warnings;
    no warnings 'utf8';
    use warnings FATAL => 'recursion';
    use warnings FATAL => 'redefine';
    use warnings FATAL => 'uninitialized';
    use utf8;
    our $VERSION = '8.0';
    use Carp qw(croak);
    
    use Encode qw(decode); # XXX
    use Web::Encoding;
    use Web::HTML::ParserData;
    use Web::HTML::_SyntaxDefs;

    
    sub HTMLNS () { 1 }
    sub SVGNS () { 2 }
    sub MATHMLNS () { 3 }
    my $NSToURL = [
      undef,
      'http://www.w3.org/1999/xhtml',
      'http://www.w3.org/2000/svg',
      'http://www.w3.org/1998/Math/MathML',
    ];
    my $ForeignAttrMap = [
      undef, undef,
      $Web::HTML::ParserData::ForeignAttrNameToArgs->{'http://www.w3.org/2000/svg'},
      $Web::HTML::ParserData::ForeignAttrNameToArgs->{'http://www.w3.org/1998/Math/MathML'},
    ];
      
    my $TagName2Group = {};

    ## ------ Common handlers ------

    sub new ($) {
      return bless {
        ## Input parameters
        # Scripting IframeSrcdoc DI known_definite_encoding locale_tag
        # di_data_set is_sub_parser

        ## Callbacks
        # onerror onerrors onappcacheselection onscript
        # onelementspopped onrestartwithencoding
        # onextentref onparsed

        ## Parser internal states
        # input_stream input_encoding saved_states saved_lists saved_maps
        # nodes document can_restart restart
        # parse_bytes_started transport_encoding_label
        # byte_bufer byte_buffer_orig
      }, $_[0];
    } # new

my $GetDefaultErrorHandler = sub {
  my $dids = $_[0]->di_data_set;
  return sub {
    my $error = {@_};
    require Web::HTML::SourceMap;
    my ($di, $index) = Web::HTML::SourceMap::resolve_index_pair ($dids, $error->{di}, $error->{index});
    my $text = defined $error->{text} ? qq{ - $error->{text}} : '';
    my $value = defined $error->{value} ? qq{ "$error->{value}"} : '';
    my $level = {
      m => 'Parse error',
      s => 'SHOULD-level error',
      w => 'Warning',
      i => 'Information',
    }->{$error->{level} || ''} || $error->{level};
    my $doc = 'document #' . $error->{di};
    if (not $di == -1) {
      my $did = $dids->[$di];
      if (defined $did->{name}) {
        $doc = $did->{name};
      } elsif (defined $did->{url}) {
        $doc = 'document <' . $did->{url} . '>';
      }
    }
    warn "$level ($error->{type}$text) at $doc index $index$value\n";
  };
}; # $GetDefaultErrorHandler

sub onerror ($;$) {
  if (@_ > 1) {
    $_[0]->{onerror} = $_[1];
  }
  return $_[0]->{onerror} ||= $GetDefaultErrorHandler->($_[0]);
} # onerror

sub onerrors ($;$) {
  if (@_ > 1) {
    $_[0]->{onerrors} = $_[1];
  }
  return $_[0]->{onerrors} || sub {
    my $onerror = $_[0]->onerror;
    $onerror->(%$_) for @{$_[1]};
  };
} # onerrors

sub onappcacheselection ($;$) {
  if (@_ > 1) {
    $_[0]->{onappcacheselection} = $_[1];
  }
  return $_[0]->{onappcacheselection} || sub { };
} # onappcacheselection

sub onscript ($;$) {
  if (@_ > 1) {
    $_[0]->{onscript} = $_[1];
  }
  return $_[0]->{onscript} || sub { };
} # onscript

sub onextentref ($;$) {
  if (@_ > 1) {
    $_[0]->{onextentref} = $_[1];
  }
  return $_[0]->{onextentref} || sub {
    my ($self, $data, $sub) = @_;
    $self->cant_expand_extentref ($data, $sub);
  };
} # onextentref

sub max_entity_depth ($;$) {
  if (@_ > 1) {
    $_[0]->{max_entity_depth} = $_[1];
  }
  return $_[0]->{max_entity_depth} || 10;
} # max_entity_depth

sub max_entity_expansions ($;$) {
  if (@_ > 1) {
    return $_[0]->{max_entity_expansions} = $_[1];
  }
  return $_[0]->{max_entity_expansions} || 1000;
} # max_entity_expansions

sub onelementspopped ($;$) {
  if (@_ > 1) {
    $_[0]->{onelementspopped} = $_[1];
  }
  return $_[0]->{onelementspopped} || sub { };
} # onelementspopped

sub onrestartwithencoding ($;$) {
  if (@_ > 1) {
    $_[0]->{onrestartwithencoding} = $_[1];
  }
  return $_[0]->{onrestartwithencoding} || sub {
    my ($self, $encoding) = @_;
    $self->known_definite_encoding ($encoding);
    $self->restart;
  };
} # onrestartwithencoding

    sub throw ($$) { $_[1]->() }

    sub restart ($) {
      unless ($_[0]->{can_restart}) {
        croak "The current parsing method can't restart the parser";
      }
      $_[0]->{restart} = 1;
    } # restart

    sub scripting ($;$) {
      if (@_ > 1) {
        $_[0]->{Scripting} = $_[1];
      }
      return $_[0]->{Scripting};
    } # scripting

    sub onparsed ($;$) {
      if (@_ > 1) {
        $_[0]->{onparsed} = $_[1];
      }
      return $_[0]->{onparsed} || sub { };
    } # onparsed

    sub _cleanup_states ($) {
      my $self = $_[0];
      delete $self->{input_stream};
      delete $self->{input_encoding};
      delete $self->{saved_states};
      delete $self->{saved_lists};
      delete $self->{saved_maps};
      delete $self->{nodes};
      delete $self->{document};
      delete $self->{can_restart};
      delete $self->{restart};
      delete $self->{pause};
      delete $self->{main_parser};
    } # _cleanup_states

    ## ------ Common defs ------
    our $AFE;our $AnchoredIndex;our $Attr;our $CONTEXT;our $Callbacks;our $Confident;our $DI;our $EOF;our $Errors;our $FORM_ELEMENT;our $FRAMESET_OK;our $HEAD_ELEMENT;our $IM;our $IframeSrcdoc;our $InForeign;our $Input;our $LastStartTagName;our $NEXT_ID;our $OE;our $OP;our $ORIGINAL_IM;our $Offset;our $QUIRKS;our $Scripting;our $State;our $TABLE_CHARS;our $TEMPLATE_IMS;our $Temp;our $TempIndex;our $Token;our $Tokens;
    ## ------ Tokenizer defs ------
    my $InvalidCharRefs = $Web::HTML::_SyntaxDefs->{charref_invalid};
sub DOCTYPE_TOKEN () { 1 }
sub COMMENT_TOKEN () { 2 }
sub END_TAG_TOKEN () { 3 }
sub END_OF_FILE_TOKEN () { 4 }
sub START_TAG_TOKEN () { 5 }
sub TEXT_TOKEN () { 6 }
sub CDATA_SECTION_BRACKET_STATE () { 1 }
sub CDATA_SECTION_END_STATE () { 2 }
sub CDATA_SECTION_STATE () { 3 }
sub CDATA_SECTION_STATE_CR () { 4 }
sub DOCTYPE_NAME_STATE () { 5 }
sub DOCTYPE_PUBLIC_ID__DQ__STATE () { 6 }
sub DOCTYPE_PUBLIC_ID__DQ__STATE_CR () { 7 }
sub DOCTYPE_PUBLIC_ID__SQ__STATE () { 8 }
sub DOCTYPE_PUBLIC_ID__SQ__STATE_CR () { 9 }
sub DOCTYPE_STATE () { 10 }
sub DOCTYPE_SYSTEM_ID__DQ__STATE () { 11 }
sub DOCTYPE_SYSTEM_ID__DQ__STATE_CR () { 12 }
sub DOCTYPE_SYSTEM_ID__SQ__STATE () { 13 }
sub DOCTYPE_SYSTEM_ID__SQ__STATE_CR () { 14 }
sub PLAINTEXT_STATE () { 15 }
sub PLAINTEXT_STATE_CR () { 16 }
sub RAWTEXT_END_TAG_NAME_STATE () { 17 }
sub RAWTEXT_END_TAG_OPEN_STATE () { 18 }
sub RAWTEXT_LESS_THAN_SIGN_STATE () { 19 }
sub RAWTEXT_STATE () { 20 }
sub RAWTEXT_STATE_CR () { 21 }
sub RCDATA_END_TAG_NAME_STATE () { 22 }
sub RCDATA_END_TAG_OPEN_STATE () { 23 }
sub RCDATA_LESS_THAN_SIGN_STATE () { 24 }
sub RCDATA_STATE () { 25 }
sub RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 26 }
sub RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE () { 27 }
sub RCDATA_STATE___CHARREF_HEX_NUM_STATE () { 28 }
sub RCDATA_STATE___CHARREF_NAME_STATE () { 29 }
sub RCDATA_STATE___CHARREF_NUM_STATE () { 30 }
sub RCDATA_STATE___CHARREF_STATE () { 31 }
sub RCDATA_STATE___CHARREF_STATE_CR () { 32 }
sub RCDATA_STATE_CR () { 33 }
sub A_DOCTYPE_NAME_STATE () { 34 }
sub A_DOCTYPE_NAME_STATE_P () { 35 }
sub A_DOCTYPE_NAME_STATE_PU () { 36 }
sub A_DOCTYPE_NAME_STATE_PUB () { 37 }
sub A_DOCTYPE_NAME_STATE_PUBL () { 38 }
sub A_DOCTYPE_NAME_STATE_PUBLI () { 39 }
sub A_DOCTYPE_NAME_STATE_S () { 40 }
sub A_DOCTYPE_NAME_STATE_SY () { 41 }
sub A_DOCTYPE_NAME_STATE_SYS () { 42 }
sub A_DOCTYPE_NAME_STATE_SYST () { 43 }
sub A_DOCTYPE_NAME_STATE_SYSTE () { 44 }
sub A_DOCTYPE_PUBLIC_ID_STATE () { 45 }
sub A_DOCTYPE_PUBLIC_KWD_STATE () { 46 }
sub A_DOCTYPE_SYSTEM_ID_STATE () { 47 }
sub A_DOCTYPE_SYSTEM_KWD_STATE () { 48 }
sub A_ATTR_NAME_STATE () { 49 }
sub A_ATTR_VALUE__QUOTED__STATE () { 50 }
sub ATTR_NAME_STATE () { 51 }
sub ATTR_VALUE__DQ__STATE () { 52 }
sub ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 53 }
sub ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 54 }
sub ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE () { 55 }
sub ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE () { 56 }
sub ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE () { 57 }
sub ATTR_VALUE__DQ__STATE___CHARREF_STATE () { 58 }
sub ATTR_VALUE__DQ__STATE_CR () { 59 }
sub ATTR_VALUE__SQ__STATE () { 60 }
sub ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 61 }
sub ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 62 }
sub ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE () { 63 }
sub ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE () { 64 }
sub ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE () { 65 }
sub ATTR_VALUE__SQ__STATE___CHARREF_STATE () { 66 }
sub ATTR_VALUE__SQ__STATE_CR () { 67 }
sub ATTR_VALUE__UNQUOTED__STATE () { 68 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 69 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE () { 70 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE () { 71 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE () { 72 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE () { 73 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE () { 74 }
sub ATTR_VALUE__UNQUOTED__STATE_CR () { 75 }
sub B_DOCTYPE_NAME_STATE () { 76 }
sub B_DOCTYPE_PUBLIC_ID_STATE () { 77 }
sub B_DOCTYPE_SYSTEM_ID_STATE () { 78 }
sub B_ATTR_NAME_STATE () { 79 }
sub B_ATTR_VALUE_STATE () { 80 }
sub BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE () { 81 }
sub BOGUS_DOCTYPE_STATE () { 82 }
sub BOGUS_COMMENT_STATE () { 83 }
sub BOGUS_COMMENT_STATE_CR () { 84 }
sub CHARREF_IN_RCDATA_STATE () { 85 }
sub CHARREF_IN_DATA_STATE () { 86 }
sub COMMENT_END_BANG_STATE () { 87 }
sub COMMENT_END_DASH_STATE () { 88 }
sub COMMENT_END_STATE () { 89 }
sub COMMENT_START_DASH_STATE () { 90 }
sub COMMENT_START_STATE () { 91 }
sub COMMENT_STATE () { 92 }
sub COMMENT_STATE_CR () { 93 }
sub DATA_STATE () { 94 }
sub DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 95 }
sub DATA_STATE___CHARREF_DECIMAL_NUM_STATE () { 96 }
sub DATA_STATE___CHARREF_HEX_NUM_STATE () { 97 }
sub DATA_STATE___CHARREF_NAME_STATE () { 98 }
sub DATA_STATE___CHARREF_NUM_STATE () { 99 }
sub DATA_STATE___CHARREF_STATE () { 100 }
sub DATA_STATE___CHARREF_STATE_CR () { 101 }
sub DATA_STATE_CR () { 102 }
sub END_TAG_OPEN_STATE () { 103 }
sub MDO_STATE () { 104 }
sub MDO_STATE__ () { 105 }
sub MDO_STATE_D () { 106 }
sub MDO_STATE_DO () { 107 }
sub MDO_STATE_DOC () { 108 }
sub MDO_STATE_DOCT () { 109 }
sub MDO_STATE_DOCTY () { 110 }
sub MDO_STATE_DOCTYP () { 111 }
sub MDO_STATE__5B () { 112 }
sub MDO_STATE__5BC () { 113 }
sub MDO_STATE__5BCD () { 114 }
sub MDO_STATE__5BCDA () { 115 }
sub MDO_STATE__5BCDAT () { 116 }
sub MDO_STATE__5BCDATA () { 117 }
sub SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE () { 118 }
sub SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR () { 119 }
sub SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE () { 120 }
sub SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR () { 121 }
sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE () { 122 }
sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE () { 123 }
sub SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE () { 124 }
sub SCRIPT_DATA_DOUBLE_ESCAPED_STATE () { 125 }
sub SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR () { 126 }
sub SCRIPT_DATA_END_TAG_NAME_STATE () { 127 }
sub SCRIPT_DATA_END_TAG_OPEN_STATE () { 128 }
sub SCRIPT_DATA_ESCAPE_START_DASH_STATE () { 129 }
sub SCRIPT_DATA_ESCAPE_START_STATE () { 130 }
sub SCRIPT_DATA_ESCAPED_DASH_DASH_STATE () { 131 }
sub SCRIPT_DATA_ESCAPED_DASH_STATE () { 132 }
sub SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE () { 133 }
sub SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE () { 134 }
sub SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE () { 135 }
sub SCRIPT_DATA_ESCAPED_STATE () { 136 }
sub SCRIPT_DATA_ESCAPED_STATE_CR () { 137 }
sub SCRIPT_DATA_LESS_THAN_SIGN_STATE () { 138 }
sub SCRIPT_DATA_STATE () { 139 }
sub SCRIPT_DATA_STATE_CR () { 140 }
sub SELF_CLOSING_START_TAG_STATE () { 141 }
sub TAG_NAME_STATE () { 142 }
sub TAG_OPEN_STATE () { 143 }
 sub cant_expand_extentref ($$$) { } 

my $TokenizerAbortingTagNames = {
  title => 1,
  textarea => 1,
  plaintext => 1,
  style => 1,
  script => 1,
  xmp => 1,
  iframe => 1,
  noembed => 1,
  noframes => 1,
  noscript => 1,

  #html => 1, # for <html manifest> -> see the line with "first start tag"
  #meta => 1, # for <meta charset>
};
  


sub strict_checker ($;$) {
  if (@_ > 1) {
    $_[0]->{strict_checker} = $_[1];
  }
  return $_[0]->{strict_checker} || 'Web::XML::Parser::MinimumChecker';
} # strict_checker

  
    ## ------ Tree constructor defs ------
    my $Element2Type = [];
my $ProcessIM = [];
sub TAG_NAME_A () { 1 }
$TagName2Group->{q@a@} = 1;
sub TAG_NAME_ADDRESS_ARTICLE_ASIDE_DETAILS_DIALOG_DIR_FIGCAPTION_FIGURE_FOOTER_HEADER_HGROUP_MAIN_NAV_SECTION_SUMMARY () { 2 }
$TagName2Group->{q@address@} = 2;
$TagName2Group->{q@article@} = 2;
$TagName2Group->{q@aside@} = 2;
$TagName2Group->{q@details@} = 2;
$TagName2Group->{q@dialog@} = 2;
$TagName2Group->{q@dir@} = 2;
$TagName2Group->{q@figcaption@} = 2;
$TagName2Group->{q@figure@} = 2;
$TagName2Group->{q@footer@} = 2;
$TagName2Group->{q@header@} = 2;
$TagName2Group->{q@hgroup@} = 2;
$TagName2Group->{q@main@} = 2;
$TagName2Group->{q@nav@} = 2;
$TagName2Group->{q@section@} = 2;
$TagName2Group->{q@summary@} = 2;
sub TAG_NAME_APPLET_MARQUEE () { 3 }
$TagName2Group->{q@applet@} = 3;
$TagName2Group->{q@marquee@} = 3;
sub TAG_NAME_AREA_WBR () { 4 }
$TagName2Group->{q@area@} = 4;
$TagName2Group->{q@wbr@} = 4;
sub TAG_NAME_B_BIG_CODE_EM_I_S_SMALL_STRIKE_STRONG_TT_U () { 5 }
$TagName2Group->{q@b@} = 5;
$TagName2Group->{q@big@} = 5;
$TagName2Group->{q@code@} = 5;
$TagName2Group->{q@em@} = 5;
$TagName2Group->{q@i@} = 5;
$TagName2Group->{q@s@} = 5;
$TagName2Group->{q@small@} = 5;
$TagName2Group->{q@strike@} = 5;
$TagName2Group->{q@strong@} = 5;
$TagName2Group->{q@tt@} = 5;
$TagName2Group->{q@u@} = 5;
sub TAG_NAME_BASE () { 6 }
$TagName2Group->{q@base@} = 6;
sub TAG_NAME_BASEFONT_BGSOUND_LINK () { 7 }
$TagName2Group->{q@basefont@} = 7;
$TagName2Group->{q@bgsound@} = 7;
$TagName2Group->{q@link@} = 7;
sub TAG_NAME_BLOCKQUOTE_CENTER_DIV_DL_OL_UL () { 8 }
$TagName2Group->{q@blockquote@} = 8;
$TagName2Group->{q@center@} = 8;
$TagName2Group->{q@div@} = 8;
$TagName2Group->{q@dl@} = 8;
$TagName2Group->{q@ol@} = 8;
$TagName2Group->{q@ul@} = 8;
sub TAG_NAME_BODY () { 9 }
$TagName2Group->{q@body@} = 9;
sub TAG_NAME_BR () { 10 }
$TagName2Group->{q@br@} = 10;
sub TAG_NAME_BUTTON () { 11 }
$TagName2Group->{q@button@} = 11;
sub TAG_NAME_CAPTION () { 12 }
$TagName2Group->{q@caption@} = 12;
sub TAG_NAME_COL () { 13 }
$TagName2Group->{q@col@} = 13;
sub TAG_NAME_COLGROUP () { 14 }
$TagName2Group->{q@colgroup@} = 14;
sub TAG_NAME_DD_DT () { 15 }
$TagName2Group->{q@dd@} = 15;
$TagName2Group->{q@dt@} = 15;
sub TAG_NAME_EMBED () { 16 }
$TagName2Group->{q@embed@} = 16;
sub TAG_NAME_FIELDSET () { 17 }
$TagName2Group->{q@fieldset@} = 17;
sub TAG_NAME_FONT () { 18 }
$TagName2Group->{q@font@} = 18;
sub TAG_NAME_FORM () { 19 }
$TagName2Group->{q@form@} = 19;
sub TAG_NAME_FRAME () { 20 }
$TagName2Group->{q@frame@} = 20;
sub TAG_NAME_FRAMESET () { 21 }
$TagName2Group->{q@frameset@} = 21;
sub TAG_NAME_H1_H2_H3_H4_H5_H6 () { 22 }
$TagName2Group->{q@h1@} = 22;
$TagName2Group->{q@h2@} = 22;
$TagName2Group->{q@h3@} = 22;
$TagName2Group->{q@h4@} = 22;
$TagName2Group->{q@h5@} = 22;
$TagName2Group->{q@h6@} = 22;
sub TAG_NAME_HEAD () { 23 }
$TagName2Group->{q@head@} = 23;
sub TAG_NAME_HR () { 24 }
$TagName2Group->{q@hr@} = 24;
sub TAG_NAME_HTML () { 25 }
$TagName2Group->{q@html@} = 25;
sub TAG_NAME_IFRAME () { 26 }
$TagName2Group->{q@iframe@} = 26;
sub TAG_NAME_IMAGE () { 27 }
$TagName2Group->{q@image@} = 27;
sub TAG_NAME_IMG () { 28 }
$TagName2Group->{q@img@} = 28;
sub TAG_NAME_INPUT () { 29 }
$TagName2Group->{q@input@} = 29;
sub TAG_NAME_KEYGEN () { 30 }
$TagName2Group->{q@keygen@} = 30;
sub TAG_NAME_LI () { 31 }
$TagName2Group->{q@li@} = 31;
sub TAG_NAME_LISTING_PRE () { 32 }
$TagName2Group->{q@listing@} = 32;
$TagName2Group->{q@pre@} = 32;
sub TAG_NAME_MALIGNMARK_MGLYPH () { 33 }
$TagName2Group->{q@malignmark@} = 33;
$TagName2Group->{q@mglyph@} = 33;
sub TAG_NAME_MATH () { 34 }
$TagName2Group->{q@math@} = 34;
sub TAG_NAME_MENU () { 35 }
$TagName2Group->{q@menu@} = 35;
sub TAG_NAME_MENUITEM () { 36 }
$TagName2Group->{q@menuitem@} = 36;
sub TAG_NAME_META () { 37 }
$TagName2Group->{q@meta@} = 37;
sub TAG_NAME_NOBR () { 38 }
$TagName2Group->{q@nobr@} = 38;
sub TAG_NAME_NOEMBED () { 39 }
$TagName2Group->{q@noembed@} = 39;
sub TAG_NAME_NOFRAMES () { 40 }
$TagName2Group->{q@noframes@} = 40;
sub TAG_NAME_NOSCRIPT () { 41 }
$TagName2Group->{q@noscript@} = 41;
sub TAG_NAME_OBJECT () { 42 }
$TagName2Group->{q@object@} = 42;
sub TAG_NAME_OPTGROUP () { 43 }
$TagName2Group->{q@optgroup@} = 43;
sub TAG_NAME_OPTION () { 44 }
$TagName2Group->{q@option@} = 44;
sub TAG_NAME_OUTPUT () { 45 }
$TagName2Group->{q@output@} = 45;
sub TAG_NAME_P () { 46 }
$TagName2Group->{q@p@} = 46;
sub TAG_NAME_PARAM_SOURCE_TRACK () { 47 }
$TagName2Group->{q@param@} = 47;
$TagName2Group->{q@source@} = 47;
$TagName2Group->{q@track@} = 47;
sub TAG_NAME_PLAINTEXT () { 48 }
$TagName2Group->{q@plaintext@} = 48;
sub TAG_NAME_RB_RTC () { 49 }
$TagName2Group->{q@rb@} = 49;
$TagName2Group->{q@rtc@} = 49;
sub TAG_NAME_RP_RT () { 50 }
$TagName2Group->{q@rp@} = 50;
$TagName2Group->{q@rt@} = 50;
sub TAG_NAME_RUBY_SPAN_SUB_SUP_VAR () { 51 }
$TagName2Group->{q@ruby@} = 51;
$TagName2Group->{q@span@} = 51;
$TagName2Group->{q@sub@} = 51;
$TagName2Group->{q@sup@} = 51;
$TagName2Group->{q@var@} = 51;
sub TAG_NAME_SARCASM () { 52 }
$TagName2Group->{q@sarcasm@} = 52;
sub TAG_NAME_SCRIPT () { 53 }
$TagName2Group->{q@script@} = 53;
sub TAG_NAME_SELECT () { 54 }
$TagName2Group->{q@select@} = 54;
sub TAG_NAME_STYLE () { 55 }
$TagName2Group->{q@style@} = 55;
sub TAG_NAME_SVG () { 56 }
$TagName2Group->{q@svg@} = 56;
sub TAG_NAME_TABLE () { 57 }
$TagName2Group->{q@table@} = 57;
sub TAG_NAME_TBODY_TFOOT_THEAD () { 58 }
$TagName2Group->{q@tbody@} = 58;
$TagName2Group->{q@tfoot@} = 58;
$TagName2Group->{q@thead@} = 58;
sub TAG_NAME_TD_TH () { 59 }
$TagName2Group->{q@td@} = 59;
$TagName2Group->{q@th@} = 59;
sub TAG_NAME_TEMPLATE () { 60 }
$TagName2Group->{q@template@} = 60;
sub TAG_NAME_TEXTAREA () { 61 }
$TagName2Group->{q@textarea@} = 61;
sub TAG_NAME_TITLE () { 62 }
$TagName2Group->{q@title@} = 62;
sub TAG_NAME_TR () { 63 }
$TagName2Group->{q@tr@} = 63;
sub TAG_NAME_XMP () { 64 }
$TagName2Group->{q@xmp@} = 64;

        ## HTML:*
        sub HTML_NS_ELS () { 1 }
      

        ## HTML:a,HTML:b,HTML:big,HTML:code,HTML:em,HTML:font,HTML:i,HTML:nobr,HTML:s,HTML:small,HTML:strike,HTML:strong,HTML:tt,HTML:u
        sub ABBCEFINSSSSTU_ELS () { 2 }
      

        ## HTML:address,HTML:div
        sub ADD_DIV_ELS () { 4 }
      

        ## HTML:applet
        sub APP_ELS () { 8 }
      

        ## HTML:area,HTML:article,HTML:aside,HTML:base,HTML:basefont,HTML:bgsound,HTML:blockquote,HTML:br,HTML:center,HTML:col,HTML:details,HTML:dir,HTML:dl,HTML:embed,HTML:figcaption,HTML:figure,HTML:footer,HTML:form,HTML:frame,HTML:frameset,HTML:head,HTML:header,HTML:hgroup,HTML:hr,HTML:iframe,HTML:link,HTML:listing,HTML:main,HTML:menu,HTML:meta,HTML:nav,HTML:noembed,HTML:noframes,HTML:noscript,HTML:param,HTML:plaintext,HTML:pre,HTML:script,HTML:section,HTML:source,HTML:summary,HTML:title,HTML:track,HTML:wbr
        sub AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS () { 16 }
      

        ## HTML:audio,HTML:video
        sub AUD_VID_ELS () { 32 }
      

        ## HTML:body
        sub BOD_ELS () { 64 }
      

        ## HTML:button
        sub BUT_ELS () { 128 }
      

        ## HTML:caption
        sub CAP_ELS () { 256 }
      

        ## HTML:colgroup
        sub COL_ELS () { 512 }
      

        ## HTML:dd
        sub DD_ELS () { 1024 }
      

        ## HTML:dt
        sub DT_ELS () { 2048 }
      

        ## HTML:fieldset,HTML:input,HTML:select
        sub FIE_INP_SEL_ELS () { 4096 }
      

        ## HTML:h1,HTML:h2,HTML:h3,HTML:h4,HTML:h5,HTML:h6
        sub HHHHHH_ELS () { 8192 }
      

        ## HTML:html
        sub HTM_ELS () { 16384 }
      

        ## HTML:img
        sub IMG_ELS () { 32768 }
      

        ## HTML:keygen,HTML:output
        sub KEY_OUT_ELS () { 65536 }
      

        ## HTML:li
        sub LI_ELS () { 131072 }
      

        ## HTML:marquee,MathML:annotation-xml
        sub MAR_M_ANN_ELS () { 262144 }
      

        ## HTML:menuitem
        sub MEN_ELS () { 524288 }
      

        ## HTML:object
        sub OBJ_ELS () { 1048576 }
      

        ## HTML:ol,HTML:ul
        sub OL_UL_ELS () { 2097152 }
      

        ## HTML:optgroup,HTML:option
        sub OPT_OPT_ELS () { 4194304 }
      

        ## HTML:p
        sub P_ELS () { 8388608 }
      

        ## HTML:rb,HTML:rp,HTML:rt
        sub RB_RP_RT_ELS () { 16777216 }
      

        ## HTML:rtc
        sub RTC_ELS () { 33554432 }
      

        ## HTML:ruby
        sub RUB_ELS () { 67108864 }
      

        ## HTML:style
        sub STY_ELS () { 134217728 }
      

        ## HTML:table
        sub TAB_ELS () { 268435456 }
      

        ## HTML:tbody,HTML:tfoot,HTML:thead
        sub TBO_TFO_THE_ELS () { 536870912 }
      

        ## HTML:td,HTML:th
        sub TD_TH_ELS () { 1073741824 }
      

        ## HTML:template
        sub TEM_ELS () { 2147483648 }
      

        ## HTML:textarea
        sub TEX_ELS () { 4294967296 }
      

        ## HTML:tr
        sub TR_ELS () { 8589934592 }
      

        ## MathML:*
        sub MATHML_NS_ELS () { 17179869184 }
      

        ## MathML:annotation-xml
        sub M_ANN_ELS () { 34359738368 }
      

        ## MathML:annotation-xml@encoding=application/xhtml+xml,MathML:annotation-xml@encoding=text/html
        sub M_ANN_M_ANN_ELS () { 68719476736 }
      

        ## MathML:mi,MathML:mn,MathML:mo,MathML:ms,MathML:mtext
        sub M_MI_M_MN_M_MO_M_MS_M_MTE_ELS () { 137438953472 }
      

        ## SVG:*
        sub SVG_NS_ELS () { 274877906944 }
      

        ## SVG:desc,SVG:foreignObject,SVG:title
        sub S_DES_S_FOR_S_TIT_ELS () { 549755813888 }
      
$Element2Type->[HTMLNS]->{q@*@} = HTML_NS_ELS;
sub A_EL () { HTML_NS_ELS | ABBCEFINSSSSTU_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@a@} = A_EL;
sub ADDRESS_EL () { HTML_NS_ELS | ADD_DIV_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@address@} = ADDRESS_EL;
sub APPLET_EL () { HTML_NS_ELS | APP_ELS } $Element2Type->[HTMLNS]->{q@applet@} = APPLET_EL;
$Element2Type->[HTMLNS]->{q@area@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub ARTICLE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@article@} = ARTICLE_EL;
sub ASIDE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@aside@} = ASIDE_EL;
$Element2Type->[HTMLNS]->{q@audio@} = HTML_NS_ELS | AUD_VID_ELS;
$Element2Type->[HTMLNS]->{q@b@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@base@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@basefont@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@bgsound@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@big@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
sub BLOCKQUOTE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 3298534883328 } $Element2Type->[HTMLNS]->{q@blockquote@} = BLOCKQUOTE_EL;
sub BODY_EL () { HTML_NS_ELS | BOD_ELS } $Element2Type->[HTMLNS]->{q@body@} = BODY_EL;
$Element2Type->[HTMLNS]->{q@br@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub BUTTON_EL () { HTML_NS_ELS | BUT_ELS } $Element2Type->[HTMLNS]->{q@button@} = BUTTON_EL;
sub CAPTION_EL () { HTML_NS_ELS | CAP_ELS } $Element2Type->[HTMLNS]->{q@caption@} = CAPTION_EL;
sub CENTER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 4398046511104 } $Element2Type->[HTMLNS]->{q@center@} = CENTER_EL;
$Element2Type->[HTMLNS]->{q@code@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@col@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub COLGROUP_EL () { HTML_NS_ELS | COL_ELS } $Element2Type->[HTMLNS]->{q@colgroup@} = COLGROUP_EL;
sub DD_EL () { HTML_NS_ELS | DD_ELS } $Element2Type->[HTMLNS]->{q@dd@} = DD_EL;
sub DETAILS_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 5497558138880 } $Element2Type->[HTMLNS]->{q@details@} = DETAILS_EL;
sub DIALOG_EL () { HTML_NS_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@dialog@} = DIALOG_EL;
sub DIR_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 6597069766656 } $Element2Type->[HTMLNS]->{q@dir@} = DIR_EL;
sub DIV_EL () { HTML_NS_ELS | ADD_DIV_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@div@} = DIV_EL;
sub DL_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 7696581394432 } $Element2Type->[HTMLNS]->{q@dl@} = DL_EL;
sub DT_EL () { HTML_NS_ELS | DT_ELS } $Element2Type->[HTMLNS]->{q@dt@} = DT_EL;
$Element2Type->[HTMLNS]->{q@em@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@embed@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub FIELDSET_EL () { HTML_NS_ELS | FIE_INP_SEL_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@fieldset@} = FIELDSET_EL;
sub FIGCAPTION_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 8796093022208 } $Element2Type->[HTMLNS]->{q@figcaption@} = FIGCAPTION_EL;
sub FIGURE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 9895604649984 } $Element2Type->[HTMLNS]->{q@figure@} = FIGURE_EL;
$Element2Type->[HTMLNS]->{q@font@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
sub FOOTER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 10995116277760 } $Element2Type->[HTMLNS]->{q@footer@} = FOOTER_EL;
sub FORM_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 12094627905536 } $Element2Type->[HTMLNS]->{q@form@} = FORM_EL;
$Element2Type->[HTMLNS]->{q@frame@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub FRAMESET_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 13194139533312 } $Element2Type->[HTMLNS]->{q@frameset@} = FRAMESET_EL;
sub H1_EL () { HTML_NS_ELS | HHHHHH_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@h1@} = H1_EL;
sub H2_EL () { HTML_NS_ELS | HHHHHH_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@h2@} = H2_EL;
sub H3_EL () { HTML_NS_ELS | HHHHHH_ELS | 3298534883328 } $Element2Type->[HTMLNS]->{q@h3@} = H3_EL;
sub H4_EL () { HTML_NS_ELS | HHHHHH_ELS | 4398046511104 } $Element2Type->[HTMLNS]->{q@h4@} = H4_EL;
sub H5_EL () { HTML_NS_ELS | HHHHHH_ELS | 5497558138880 } $Element2Type->[HTMLNS]->{q@h5@} = H5_EL;
sub H6_EL () { HTML_NS_ELS | HHHHHH_ELS | 6597069766656 } $Element2Type->[HTMLNS]->{q@h6@} = H6_EL;
sub HEAD_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 14293651161088 } $Element2Type->[HTMLNS]->{q@head@} = HEAD_EL;
sub HEADER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 15393162788864 } $Element2Type->[HTMLNS]->{q@header@} = HEADER_EL;
sub HGROUP_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 16492674416640 } $Element2Type->[HTMLNS]->{q@hgroup@} = HGROUP_EL;
$Element2Type->[HTMLNS]->{q@hr@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub HTML_EL () { HTML_NS_ELS | HTM_ELS } $Element2Type->[HTMLNS]->{q@html@} = HTML_EL;
$Element2Type->[HTMLNS]->{q@i@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@iframe@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@img@} = HTML_NS_ELS | IMG_ELS;
$Element2Type->[HTMLNS]->{q@input@} = HTML_NS_ELS | FIE_INP_SEL_ELS;
$Element2Type->[HTMLNS]->{q@keygen@} = HTML_NS_ELS | KEY_OUT_ELS;
sub LI_EL () { HTML_NS_ELS | LI_ELS } $Element2Type->[HTMLNS]->{q@li@} = LI_EL;
$Element2Type->[HTMLNS]->{q@link@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub LISTING_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 17592186044416 } $Element2Type->[HTMLNS]->{q@listing@} = LISTING_EL;
sub MAIN_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 18691697672192 } $Element2Type->[HTMLNS]->{q@main@} = MAIN_EL;
sub MARQUEE_EL () { HTML_NS_ELS | MAR_M_ANN_ELS } $Element2Type->[HTMLNS]->{q@marquee@} = MARQUEE_EL;
sub MENU_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 19791209299968 } $Element2Type->[HTMLNS]->{q@menu@} = MENU_EL;
sub MENUITEM_EL () { HTML_NS_ELS | MEN_ELS } $Element2Type->[HTMLNS]->{q@menuitem@} = MENUITEM_EL;
$Element2Type->[HTMLNS]->{q@meta@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub NAV_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 20890720927744 } $Element2Type->[HTMLNS]->{q@nav@} = NAV_EL;
sub NOBR_EL () { HTML_NS_ELS | ABBCEFINSSSSTU_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@nobr@} = NOBR_EL;
$Element2Type->[HTMLNS]->{q@noembed@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@noframes@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@noscript@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub OBJECT_EL () { HTML_NS_ELS | OBJ_ELS } $Element2Type->[HTMLNS]->{q@object@} = OBJECT_EL;
sub OL_EL () { HTML_NS_ELS | OL_UL_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@ol@} = OL_EL;
sub OPTGROUP_EL () { HTML_NS_ELS | OPT_OPT_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@optgroup@} = OPTGROUP_EL;
sub OPTION_EL () { HTML_NS_ELS | OPT_OPT_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@option@} = OPTION_EL;
$Element2Type->[HTMLNS]->{q@output@} = HTML_NS_ELS | KEY_OUT_ELS;
sub P_EL () { HTML_NS_ELS | P_ELS } $Element2Type->[HTMLNS]->{q@p@} = P_EL;
$Element2Type->[HTMLNS]->{q@param@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@plaintext@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub PRE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 21990232555520 } $Element2Type->[HTMLNS]->{q@pre@} = PRE_EL;
$Element2Type->[HTMLNS]->{q@rb@} = HTML_NS_ELS | RB_RP_RT_ELS;
$Element2Type->[HTMLNS]->{q@rp@} = HTML_NS_ELS | RB_RP_RT_ELS;
$Element2Type->[HTMLNS]->{q@rt@} = HTML_NS_ELS | RB_RP_RT_ELS;
$Element2Type->[HTMLNS]->{q@rtc@} = HTML_NS_ELS | RTC_ELS;
sub RUBY_EL () { HTML_NS_ELS | RUB_ELS } $Element2Type->[HTMLNS]->{q@ruby@} = RUBY_EL;
$Element2Type->[HTMLNS]->{q@s@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
sub SARCASM_EL () { HTML_NS_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@sarcasm@} = SARCASM_EL;
sub SCRIPT_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 23089744183296 } $Element2Type->[HTMLNS]->{q@script@} = SCRIPT_EL;
sub SECTION_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 24189255811072 } $Element2Type->[HTMLNS]->{q@section@} = SECTION_EL;
sub SELECT_EL () { HTML_NS_ELS | FIE_INP_SEL_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@select@} = SELECT_EL;
$Element2Type->[HTMLNS]->{q@small@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@source@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@strike@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@strong@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@style@} = HTML_NS_ELS | STY_ELS;
sub SUMMARY_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | 25288767438848 } $Element2Type->[HTMLNS]->{q@summary@} = SUMMARY_EL;
sub TABLE_EL () { HTML_NS_ELS | TAB_ELS } $Element2Type->[HTMLNS]->{q@table@} = TABLE_EL;
sub TBODY_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@tbody@} = TBODY_EL;
sub TD_EL () { HTML_NS_ELS | TD_TH_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@td@} = TD_EL;
sub TEMPLATE_EL () { HTML_NS_ELS | TEM_ELS } $Element2Type->[HTMLNS]->{q@template@} = TEMPLATE_EL;
$Element2Type->[HTMLNS]->{q@textarea@} = HTML_NS_ELS | TEX_ELS;
sub TFOOT_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@tfoot@} = TFOOT_EL;
sub TH_EL () { HTML_NS_ELS | TD_TH_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@th@} = TH_EL;
sub THEAD_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 3298534883328 } $Element2Type->[HTMLNS]->{q@thead@} = THEAD_EL;
$Element2Type->[HTMLNS]->{q@title@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
sub TR_EL () { HTML_NS_ELS | TR_ELS } $Element2Type->[HTMLNS]->{q@tr@} = TR_EL;
$Element2Type->[HTMLNS]->{q@track@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[HTMLNS]->{q@tt@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
$Element2Type->[HTMLNS]->{q@u@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
sub UL_EL () { HTML_NS_ELS | OL_UL_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@ul@} = UL_EL;
$Element2Type->[HTMLNS]->{q@video@} = HTML_NS_ELS | AUD_VID_ELS;
$Element2Type->[HTMLNS]->{q@wbr@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS;
$Element2Type->[MATHMLNS]->{q@*@} = MATHML_NS_ELS;
$Element2Type->[MATHMLNS]->{q@annotation-xml@} = MATHML_NS_ELS | MAR_M_ANN_ELS | M_ANN_ELS;
$Element2Type->[MATHMLNS]->{q@mi@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
$Element2Type->[MATHMLNS]->{q@mn@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
$Element2Type->[MATHMLNS]->{q@mo@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
$Element2Type->[MATHMLNS]->{q@ms@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
$Element2Type->[MATHMLNS]->{q@mtext@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
$Element2Type->[SVGNS]->{q@*@} = SVG_NS_ELS;
$Element2Type->[SVGNS]->{q@desc@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
$Element2Type->[SVGNS]->{q@foreignObject@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
sub SVG_SCRIPT_EL () { SVG_NS_ELS | 1099511627776 } $Element2Type->[SVGNS]->{q@script@} = SVG_SCRIPT_EL;
$Element2Type->[SVGNS]->{q@title@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
sub AFTER_AFTER_BODY_IM () { 1 }
sub AFTER_AFTER_FRAMESET_IM () { 2 }
sub AFTER_BODY_IM () { 3 }
sub AFTER_FRAMESET_IM () { 4 }
sub AFTER_HEAD_IM () { 5 }
sub BEFORE_HEAD_IM () { 6 }
sub BEFORE_HTML_IM () { 7 }
sub BEFORE_IGNORED_NEWLINE_IM () { 8 }
sub BEFORE_IGNORED_NEWLINE_AND_TEXT_IM () { 9 }
sub IN_BODY_IM () { 10 }
sub IN_CAPTION_IM () { 11 }
sub IN_CELL_IM () { 12 }
sub IN_COLUMN_GROUP_IM () { 13 }
sub IN_FOREIGN_CONTENT_IM () { 14 }
sub IN_FRAMESET_IM () { 15 }
sub IN_HEAD_IM () { 16 }
sub IN_HEAD_NOSCRIPT_IM () { 17 }
sub IN_ROW_IM () { 18 }
sub IN_SELECT_IM () { 19 }
sub IN_SELECT_IN_TABLE_IM () { 20 }
sub IN_TABLE_IM () { 21 }
sub IN_TABLE_BODY_IM () { 22 }
sub IN_TABLE_TEXT_IM () { 23 }
sub IN_TEMPLATE_IM () { 24 }
sub INITIAL_IM () { 25 }
sub TEXT_IM () { 26 }
my $QPublicIDPrefixPattern = qr{(?:(?:-(?://(?:S(?:OFTQUAD(?: SOFTWARE//DTD HOTMETAL PRO 6\.0::19990601|//DTD HOTMETAL PRO 4\.0::19971010)::EXTENSIONS TO HTML 4\.0|UN MICROSYSTEMS CORP\.//DTD HOTJAVA(?: STRICT)? HTML|Q//DTD HTML 2\.0 HOTMETAL \+ EXTENSIONS|PYGLASS//DTD HTML 2\.0 EXTENDED)|W(?:3(?:C//DTD HTML (?:3\.2(?: (?:DRAFT|FINAL)|S DRAFT)?|4\.0 (?:TRANSITIONAL|FRAMESET))|O//DTD W3 HTML 3\.0)|EBTECHS//DTD MOZILLA HTML 2\.0)|IETF//DTD HTML (?:2\.(?:0(?: (?:STRICT(?: LEVEL [12])?|LEVEL [12]))?|1E)|3\.(?:2(?: FINAL)?|0))|MICROSOFT//DTD INTERNET EXPLORER [23]\.0 (?:HTML(?: STRICT)?|TABLES)|O'REILLY AND ASSOCIATES//DTD HTML (?:EXTEND(?:ED RELAX)?ED 1|2)\.0|A(?:DVASOFT LTD|S)//DTD HTML 3\.0 ASWEDIT \+ EXTENSIONS|NETSCAPE COMM\. CORP\.//DTD(?: STRICT)? HTML)//|//(?:W(?:3C//DTD (?:HTML (?:EXPERIMENTAL (?:19960712|970421)|3 1995-03-24)|W3 HTML)|EBTECHS//DTD MOZILLA HTML)|IETF//DTD HTML(?: (?:STRICT(?: LEVEL [0123])?|LEVEL [0123]|3))?|METRIUS//DTD METRIUS PRESENTATIONAL)//)|\+//SILMARIL//DTD HTML PRO V0R11 19970101//))};
my $LQPublicIDPrefixPattern = qr{(?:-//W3C//DTD XHTML 1\.0 (?:TRANSITIONAL|FRAMESET)//)};
my $QorLQPublicIDPrefixPattern = qr{(?:-//W3C//DTD HTML 4\.01 (?:TRANSITIONAL|FRAMESET)//)};
my $QPublicIDs = {q<-//W3O//DTD W3 HTML STRICT 3.0//EN//> => 1, q<-/W3C/DTD HTML 4.0 TRANSITIONAL/EN> => 1, q<HTML> => 1};
my $QSystemIDs = {q<HTTP://WWW.IBM.COM/DATA/DTD/V11/IBMXHTML1-TRANSITIONAL.DTD> => 1};
my $OPPublicIDToSystemID = {q<-//W3C//DTD HTML 4.0//EN> => q<http://www.w3.org/TR/REC-html40/strict.dtd>, q<-//W3C//DTD HTML 4.01//EN> => q<http://www.w3.org/TR/html4/strict.dtd>, q<-//W3C//DTD XHTML 1.0 Strict//EN> => q<http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd>, q<-//W3C//DTD XHTML 1.1//EN> => q<http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd>};
my $OPPublicIDOnly = {q<-//W3C//DTD HTML 4.0//EN> => 1, q<-//W3C//DTD HTML 4.01//EN> => 1};

      my $TCA = [undef,
        ## [1] after after body;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [2] after after body;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [3] after after body;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [4] after after body;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [5] after after body;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [6] after after frameset;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [7] after after frameset;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [8] after after frameset;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [9] after after frameset;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [10] after after frameset;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'after-after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [11] after body;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => $OE->[0]->{id}];
          
        },
      ,
        ## [12] after body;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [13] after body;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [14] after body;END:html
        sub {
          my $token = $_;

          if (defined $CONTEXT) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            
          $IM = AFTER_AFTER_BODY_IM;
          #warn "Insertion mode changed to |after after body| ($IM)";
        
          }
        
        },
      ,
        ## [15] after body;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [16] after body;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [17] after body;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [18] after frameset;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [19] after frameset;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [20] after frameset;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [21] after frameset;END:html
        sub {
          
          $IM = AFTER_AFTER_FRAMESET_IM;
          #warn "Insertion mode changed to |after after frameset| ($IM)";
        
        },
      ,
        ## [22] after frameset;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [23] after frameset;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [24] after frameset;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'after-body-else',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
              
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [25] after head;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [26] after head;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [27] after head;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [28] after head;END:body,br,html
        sub {
          my $token = $_;

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [29] after head;EOF
        sub {
          my $token = $_;

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [30] after head;START-ELSE
        sub {
          my $token = $_;

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [31] after head;START:base,basefont bgsound link
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
        },
      ,
        ## [32] after head;START:body
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => $token->{attr_list},
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        
        },
      ,
        ## [33] after head;START:frameset
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'frameset',
                 attr_list => $token->{attr_list},
                 et => (FRAMESET_EL), aet => (FRAMESET_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_FRAMESET_IM;
          #warn "Insertion mode changed to |in frameset| ($IM)";
        
        },
      ,
        ## [34] after head;START:head
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [35] after head;START:meta
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'meta',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        if (defined $token->{attrs}->{charset}) {
          push @$OP, ['change-the-encoding',
                      (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                      $token->{attrs}->{charset}];
        } elsif (defined $token->{attrs}->{'http-equiv'} and
                 defined $token->{attrs}->{content}) {
          # IndexedString
          if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                  =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
              (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                  =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                        [\x09\x0A\x0C\x0D\x20]*=
                        [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                        ([^"'\x09\x0A\x0C\x0D\x20]
                         [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
            push @$OP, ['change-the-encoding',
                        defined $1 ? $1 : defined $2 ? $2 : $3,
                        $token->{attrs}->{content}];
          }
        }
      
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
        },
      ,
        ## [36] after head;START:noframes,style
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [37] after head;START:script
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'script',
                 attr_list => $token->{attr_list},
                 et => (SCRIPT_EL), aet => (SCRIPT_EL) , script_flags => 1};
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$State = SCRIPT_DATA_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [38] after head;START:template
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'template',
                 attr_list => $token->{attr_list},
                 et => (TEMPLATE_EL), aet => (TEMPLATE_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
push @$AFE, '#marker';

        $FRAMESET_OK = 0;
      

          $IM = IN_TEMPLATE_IM;
          #warn "Insertion mode changed to |in template| ($IM)";
        

        push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
      
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [39] after head;START:title
        sub {
          my $token = $_;
push @$Errors, {type => 'after head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OE, $HEAD_ELEMENT;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'title',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$State = RCDATA_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
@$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [40] after head;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          
        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [41] before head;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [42] before head;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [43] before head;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [44] before head;END:body,br,head,html
        sub {
          my $token = $_;

        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [45] before head;EOF
        sub {
          my $token = $_;

        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [46] before head;START-ELSE
        sub {
          my $token = $_;

        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [47] before head;START:head
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => $token->{attr_list},
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$HEAD_ELEMENT = $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
        },
      ,
        ## [48] before head;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          
        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [49] before html;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [50] before html;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [51] before html;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [52] before html;END:body,br,head,html
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => [],
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [53] before html;EOF
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => [],
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [54] before html;START-ELSE
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => [],
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [55] before html;START:html
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => $token->{attr_list},
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache', $token->{attrs}->{manifest}];

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        
        },
      ,
        ## [56] before html;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          
        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => [],
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        

        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [57] before ignored newline and text;ELSE
        sub {
          
      $IM = TEXT_IM;
      goto &{$ProcessIM->[$IM]->[$_->{type}]->[$_->{tn}]};
    
        },
      ,
        ## [58] before ignored newline and text;TEXT
        sub {
          
      $_->{index}++ if $_->{value} =~ s/^\x0A//;
      $IM = TEXT_IM;
      goto &{$ProcessIM->[$IM]->[$_->{type}]->[0]} if length $_->{value};
    
        },
      ,
        ## [59] before ignored newline;ELSE
        sub {
          
    $IM = $ORIGINAL_IM;
    goto &{$ProcessIM->[$IM]->[$_->{type}]->[$_->{tn}]};
  
        },
      ,
        ## [60] before ignored newline;TEXT
        sub {
          
    $_->{index}++ if $_->{value} =~ s/^\x0A//;
    $IM = $ORIGINAL_IM;
    goto &{$ProcessIM->[$IM]->[$_->{type}]->[0]} if length $_->{value};
  
        },
      ,
        ## [61] in body;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [62] in body;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [63] in body;END-ELSE
        sub {
          my $token = $_;

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{ns} == HTMLNS and $_node->{local_name} eq $token->{tag_name}) {
            {
            my @popped;
            push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @$OP, ['popped', \@popped];
          }

          if (not ($OE->[-1] eq $_node)) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $_node);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
return;
          } else {
            
          if ($_node->{et} & (ADD_DIV_ELS | APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        
          }
        
          }
        
        },
      ,
        ## [64] in body;END:a,b big code em i s small strike strong tt u,font,nobr
        sub {
          my $token = $_;
aaa ($token, $token->{tag_name});
        },
      ,
        ## [65] in body;END:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl ol ul,button,fieldset,listing pre,menu
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
        },
      ,
        ## [66] in body;END:applet marquee,object
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      
          }
        
        },
      ,
        ## [67] in body;END:body
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (BOD_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = AFTER_BODY_IM;
          #warn "Insertion mode changed to |after body| ($IM)";
        
          }
        
        },
      ,
        ## [68] in body;END:br
        sub {
          my $token = $_;
push @$Errors, {type => '</br>',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node_br = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'br',
                 attr_list => [],
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node_br => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [69] in body;END:dd dt
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
            my @popped;
            push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @$OP, ['popped', \@popped];
          }

          if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
        },
      ,
        ## [70] in body;END:form
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    ) {
            my $_node = $FORM_ELEMENT;
$FORM_ELEMENT = undef;

          if ((not defined $_node) or 
(
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_ eq $_node) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    )) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1] eq $_node)) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
@$OE = grep { $_ ne $_node } @$OE;
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == FORM_EL) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} == FORM_EL)) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == FORM_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
        },
      ,
        ## [71] in body;END:h1 h2 h3 h4 h5 h6
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (HHHHHH_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HHHHHH_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
        },
      ,
        ## [72] in body;END:html
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (BOD_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = AFTER_BODY_IM;
          #warn "Insertion mode changed to |after body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [73] in body;END:li
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (LI_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | OL_UL_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (LI_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
        },
      ,
        ## [74] in body;END:p
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => '</p>',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node_p = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'p',
                 attr_list => [],
                 et => (P_EL), aet => (P_EL) };
      

      push @$OP, ['insert', $node_p => $OE->[-1]->{id}];
    

push @$OE, $node_p;
          }
        
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
        },
      ,
        ## [75] in body;END:sarcasm
        sub {
          my $token = $_;

        ## Take a deep breath!
      

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{et} & HTML_NS_ELS and $_node->{local_name} eq $token->{tag_name}) {
            {
            my @popped;
            push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @$OP, ['popped', \@popped];
          }

          if (not ($OE->[-1] eq $_node)) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $_node);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
return;
          } else {
            
          if ($_node->{et} & (ADD_DIV_ELS | APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        
          }
        
          }
        
        },
      ,
        ## [76] in body;EOF
        sub {
          my $token = $_;

          if (@$TEMPLATE_IMS) {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    ) {
            push @$OP, ['stop-parsing'];
          } else {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      
pop @$TEMPLATE_IMS;
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
          } else {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
          }
        
push @$OP, ['stop-parsing'];
          }
        
        },
      ,
        ## [77] in body;START-ELSE
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [78] in body;START:a
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$AFE) {
          last if not ref $_;
          if ($_->{et} == A_EL) {
            $result = 1;
            last;
          }
        }
        $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
aaa ($token, 'a', remove_from_afe_and_oe => 1);
          }
        
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'a',
                 attr_list => $token->{attr_list},
                 et => (A_EL), aet => (A_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [79] in body;START:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl ol ul,fieldset,p
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [80] in body;START:applet marquee,object
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;
push @$AFE, '#marker';

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [81] in body;START:area wbr,br,embed,img,keygen
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          

          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [82] in body;START:b big code em i s small strike strong tt u,font
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [83] in body;START:body
        sub {
          my $token = $_;
push @$Errors, {type => 'duplicate body/html tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ((@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS))) or 
($OE->[-1]->{et} & (HTM_ELS)) or 
(
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    )) {
            return;
          } else {
            
        $FRAMESET_OK = 0;
      

        push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[1]->{id}]
            if @{$token->{attr_list} or []};
      
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [84] in body;START:button
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (BUT_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (BUT_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'button',
                 attr_list => $token->{attr_list},
                 et => (BUTTON_EL), aet => (BUTTON_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [85] in body;START:caption,col,colgroup,frame,head,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [86] in body;START:dd dt
        sub {
          my $token = $_;

        $FRAMESET_OK = 0;
      

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{et} & (DD_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (DD_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (DD_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (DT_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (DT_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (DT_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            last;
          } else {
            
          }
        
          }
        
          }
        
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [87] in body;START:form
        sub {
          my $token = $_;

          if ((defined $FORM_ELEMENT) and 
(
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    )) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          } else {
            
          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'form',
                 attr_list => $token->{attr_list},
                 et => (FORM_EL), aet => (FORM_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    ) {
            $FORM_ELEMENT = $node;
          }
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [88] in body;START:frameset
        sub {
          my $token = $_;
push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (($OE->[-1]->{et} & (HTM_ELS)) or 
(@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS)))) {
            return;
          }
        

          if (not $FRAMESET_OK) {
            return;
          } else {
            
        push @$OP, ['remove', $OE->[1]->{id}];
      
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $OE->[1]);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'frameset',
                 attr_list => $token->{attr_list},
                 et => (FRAMESET_EL), aet => (FRAMESET_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          $IM = IN_FRAMESET_IM;
          #warn "Insertion mode changed to |in frameset| ($IM)";
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [89] in body;START:h1 h2 h3 h4 h5 h6
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (HHHHHH_ELS)) {
            push @$Errors, {type => 'in hn:hn',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [90] in body;START:hr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'hr',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [91] in body;START:html
        sub {
          my $token = $_;
push @$Errors, {type => 'duplicate body/html tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            return;
          } else {
            
        push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[0]->{id}]
            if @{$token->{attr_list} or []};
      
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [92] in body;START:iframe
        sub {
          my $token = $_;

        $FRAMESET_OK = 0;
      

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'iframe',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [93] in body;START:image
        sub {
          my $token = $_;
push @$Errors, {type => 'image',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node_img = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'img',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | IMG_ELS), aet => (HTML_NS_ELS | IMG_ELS) };
      

      push @$OP, ['insert', $node_img => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [94] in body;START:input
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'input',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        

          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

          if (
      not (
        defined $token->{attrs}->{type} and
        do {
          my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
          $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
          $value eq q@hidden@;
        }
      )
    ) {
            
        $FRAMESET_OK = 0;
      
          }
        
        },
      ,
        ## [95] in body;START:li
        sub {
          my $token = $_;

        $FRAMESET_OK = 0;
      

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{et} & (LI_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (LI_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            last;
          } else {
            
          }
        
          }
        
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'li',
                 attr_list => $token->{attr_list},
                 et => (LI_EL), aet => (LI_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [96] in body;START:listing pre
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      

        $ORIGINAL_IM = $IM;
        $IM = BEFORE_IGNORED_NEWLINE_IM;
      
        },
      ,
        ## [97] in body;START:math
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];
my $ns = MATHMLNS;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
        },
      ,
        ## [98] in body;START:menu
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'menu',
                 attr_list => $token->{attr_list},
                 et => (MENU_EL), aet => (MENU_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [99] in body;START:menuitem
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'menuitem',
                 attr_list => $token->{attr_list},
                 et => (MENUITEM_EL), aet => (MENUITEM_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [100] in body;START:nobr
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == NOBR_EL) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
aaa ($token, 'nobr');
&reconstruct_afe if @$AFE and ref $AFE->[-1];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'nobr',
                 attr_list => $token->{attr_list},
                 et => (NOBR_EL), aet => (NOBR_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [101] in body;START:noembed
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noembed',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [102] in body;START:noscript
        sub {
          my $token = $_;

          if ($Scripting) {
            
        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
          } else {
            &reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [103] in body;START:optgroup,option
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} == OPTION_EL) {
            push @$OP, ['popped', [pop @$OE]];
          }
        
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [104] in body;START:param source track
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [105] in body;START:plaintext
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'plaintext',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = PLAINTEXT_STATE;
        },
      ,
        ## [106] in body;START:rb rtc
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (RUB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (RUB_ELS))) {
            push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
          }
        
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [107] in body;START:rp rt
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (RUB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS);

          if (not ($OE->[-1]->{et} & (RTC_ELS | RUB_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [108] in body;START:select
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'select',
                 attr_list => $token->{attr_list},
                 et => (SELECT_EL), aet => (SELECT_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

        $FRAMESET_OK = 0;
      

          if ($IM == IN_TABLE_IM or $IM == IN_CAPTION_IM or $IM == IN_TABLE_BODY_IM or $IM == IN_ROW_IM or $IM == IN_CELL_IM) {
            
          $IM = IN_SELECT_IN_TABLE_IM;
          #warn "Insertion mode changed to |in select in table| ($IM)";
        
          } else {
            
          $IM = IN_SELECT_IM;
          #warn "Insertion mode changed to |in select| ($IM)";
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [109] in body;START:svg
        sub {
          my $token = $_;
&reconstruct_afe if @$AFE and ref $AFE->[-1];
my $ns = SVGNS;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
        },
      ,
        ## [110] in body;START:table
        sub {
          my $token = $_;

          if ((not $QUIRKS) and 
(
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    )) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'table',
                 attr_list => $token->{attr_list},
                 et => (TABLE_EL), aet => (TABLE_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        
        },
      ,
        ## [111] in body;START:textarea
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'textarea',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | TEX_ELS), aet => (HTML_NS_ELS | TEX_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RCDATA_STATE;
$ORIGINAL_IM = $IM;

        $FRAMESET_OK = 0;
      

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        

        $IM = BEFORE_IGNORED_NEWLINE_AND_TEXT_IM;
      
        },
      ,
        ## [112] in body;START:xmp
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
&reconstruct_afe if @$AFE and ref $AFE->[-1];

        $FRAMESET_OK = 0;
      

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'xmp',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS), aet => (HTML_NS_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [113] in body;TEXT
        sub {
          my $token = $_;

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
        },
      ,
        ## [114] in caption;END:body,col,colgroup,html,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [115] in caption;END:caption
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (CAP_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (CAP_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        
          }
        
        },
      ,
        ## [116] in caption;END:table
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (CAP_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (CAP_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [117] in caption;START:caption,col,colgroup,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (CAP_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'in caption',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (CAP_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [118] in caption;TEXT
        sub {
          my $token = $_;

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
        },
      ,
        ## [119] in cell;END:body,caption,col,colgroup,html
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [120] in cell;END:table,tbody tfoot thead,tr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (TD_TH_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TD_TH_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [121] in cell;END:td th
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        
          }
        
        },
      ,
        ## [122] in cell;START:caption,col,colgroup,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TD_TH_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'in cell',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (TD_TH_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TD_TH_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [123] in cell;TEXT
        sub {
          my $token = $_;

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
        },
      ,
        ## [124] in column group;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [125] in column group;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [126] in column group;END-ELSE
        sub {
          my $token = $_;

          if (not ($OE->[-1]->{et} & (COL_ELS))) {
            push @$Errors, {type => 'in colgroup',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [127] in column group;END:col
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [128] in column group;END:colgroup
        sub {
          my $token = $_;

          if (not ($OE->[-1]->{et} & (COL_ELS))) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        
          }
        
        },
      ,
        ## [129] in column group;START-ELSE
        sub {
          my $token = $_;

          if (not ($OE->[-1]->{et} & (COL_ELS))) {
            push @$Errors, {type => 'in colgroup',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [130] in column group;START:col
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'col',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [131] in column group;TEXT
        sub {
          my $token = $_;

          if (not ($OE->[-1]->{et} & (COL_ELS))) {
            
          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'in colgroup',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
              
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
          }
        
          } else {
            
        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
          }
        
        },
      ,
        ## [132] in foreign content;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [133] in foreign content;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [134] in foreign content;END-ELSE
        sub {
          my $token = $_;

          if (not ((
        $OE->[-1]->{local_name} eq $token->{tag_name} or
        do {
          my $ln = $OE->[-1]->{local_name};
          $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          $ln eq $token->{tag_name};
        }
      ))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          my $_node_i = $#$OE;
          my $_node = $OE->[$_node_i];
          {
            
          if ($_node->{et} & (HTM_ELS)) {
            return;
          }
        

          if ((
        $_node->{local_name} eq $token->{tag_name} or
        do {
          my $ln = $_node->{local_name};
          $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          $ln eq $token->{tag_name};
        }
      )) {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $_node);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
return;
          }
        
            $_node_i--;
            $_node = $OE->[$_node_i];
            
          if (not ($_node->{et} & (HTML_NS_ELS))) {
            
          } else {
            
        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
last;
          }
        
            redo;
          }
        
        },
      ,
        ## [135] in foreign content;END:script
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} == SVG_SCRIPT_EL) {
            my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];
push @$OP, ['script', $script->{id}];
          } else {
            
          if (not ((
        $OE->[-1]->{local_name} eq $token->{tag_name} or
        do {
          my $ln = $OE->[-1]->{local_name};
          $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          $ln eq $token->{tag_name};
        }
      ))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          my $_node_i = $#$OE;
          my $_node = $OE->[$_node_i];
          {
            
          if ($_node->{et} & (HTM_ELS)) {
            return;
          }
        

          if ((
        $_node->{local_name} eq $token->{tag_name} or
        do {
          my $ln = $_node->{local_name};
          $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          $ln eq $token->{tag_name};
        }
      )) {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $_node);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
return;
          }
        
            $_node_i--;
            $_node = $OE->[$_node_i];
            
          if (not ($_node->{et} & (HTML_NS_ELS))) {
            
          } else {
            
        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
last;
          }
        
            redo;
          }
        
          }
        
        },
      ,
        ## [136] in foreign content;EOF
        sub {
          
        },
      ,
        ## [137] in foreign content;START-ELSE
        sub {
          my $token = $_;

          if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
            
        $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
      
          }
        

          ## Adjusted current node
          my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
        

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

          if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
              defined $token->{attrs}->{encoding}) {
            my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
            $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($encoding eq 'text/html' or
                $encoding eq 'application/xhtml+xml') {
              $node->{aet} |= M_ANN_M_ANN_ELS;
              $node->{et} |= M_ANN_M_ANN_ELS;
            }
          }
        

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            
          if (($token->{tag_name} eq q@script@) and 
($OE->[-1]->{et} & (SVG_NS_ELS))) {
            delete $token->{self_closing_flag};
my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];
push @$OP, ['script', $script->{id}];
          } else {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
          }
        
        },
      ,
        ## [138] in foreign content;START:b big code em i s small strike strong tt u,blockquote center div dl ol ul,body,br,dd dt,embed,h1 h2 h3 h4 h5 h6,head,hr,img,li,listing pre,menu,meta,nobr,p,ruby span sub sup var,table
        sub {
          my $token = $_;
push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (defined $CONTEXT) {
            
          if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
            
        $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
      
          }
        

          ## Adjusted current node
          my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
        

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

          if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
              defined $token->{attrs}->{encoding}) {
            my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
            $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($encoding eq 'text/html' or
                $encoding eq 'application/xhtml+xml') {
              $node->{aet} |= M_ANN_M_ANN_ELS;
              $node->{et} |= M_ANN_M_ANN_ELS;
            }
          }
        

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            
          if (($token->{tag_name} eq q@script@) and 
($OE->[-1]->{et} & (SVG_NS_ELS))) {
            delete $token->{self_closing_flag};
my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];
push @$OP, ['script', $script->{id}];
          } else {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
          }
        
          } else {
            push @$OP, ['popped', [pop @$OE]];
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTML_NS_ELS | M_ANN_M_ANN_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS));
          push @$OP, ['popped', \@popped];
        }

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [139] in foreign content;START:font
        sub {
          my $token = $_;

          if ($token->{attrs}->{q@color@} or 
$token->{attrs}->{q@face@} or 
$token->{attrs}->{q@size@}) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (defined $CONTEXT) {
            
          if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
            
        $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
      
          }
        

          ## Adjusted current node
          my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
        

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

          if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
              defined $token->{attrs}->{encoding}) {
            my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
            $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($encoding eq 'text/html' or
                $encoding eq 'application/xhtml+xml') {
              $node->{aet} |= M_ANN_M_ANN_ELS;
              $node->{et} |= M_ANN_M_ANN_ELS;
            }
          }
        

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            
          if (($token->{tag_name} eq q@script@) and 
($OE->[-1]->{et} & (SVG_NS_ELS))) {
            delete $token->{self_closing_flag};
my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];
push @$OP, ['script', $script->{id}];
          } else {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
          }
        
          } else {
            push @$OP, ['popped', [pop @$OE]];
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTML_NS_ELS | M_ANN_M_ANN_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS));
          push @$OP, ['popped', \@popped];
        }

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
          } else {
            
          if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
            
        $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
      
          }
        

          ## Adjusted current node
          my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
        

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

          if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
              defined $token->{attrs}->{encoding}) {
            my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
            $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($encoding eq 'text/html' or
                $encoding eq 'application/xhtml+xml') {
              $node->{aet} |= M_ANN_M_ANN_ELS;
              $node->{et} |= M_ANN_M_ANN_ELS;
            }
          }
        

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            
          if (($token->{tag_name} eq q@script@) and 
($OE->[-1]->{et} & (SVG_NS_ELS))) {
            delete $token->{self_closing_flag};
my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];
push @$OP, ['script', $script->{id}];
          } else {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
          }
        
          }
        
        },
      ,
        ## [140] in foreign content;TEXT
        sub {
          my $token = $_;

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};

      push @$OP, ['text', [[q@�@, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              
      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
        },
      ,
        ## [141] in frameset;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [142] in frameset;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [143] in frameset;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in frameset',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [144] in frameset;END:frameset
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} & (HTM_ELS)) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            push @$OP, ['popped', [pop @$OE]];

          if ((not defined $CONTEXT) and 
(not ($OE->[-1]->{et} == FRAMESET_EL))) {
            
          $IM = AFTER_FRAMESET_IM;
          #warn "Insertion mode changed to |after frameset| ($IM)";
        
          }
        
          }
        
        },
      ,
        ## [145] in frameset;EOF
        sub {
          my $token = $_;

          if (not ($OE->[-1]->{et} & (HTM_ELS))) {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
          }
        
push @$OP, ['stop-parsing'];
        },
      ,
        ## [146] in frameset;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in frameset',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [147] in frameset;START:frame
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'frame',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [148] in frameset;START:frameset
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'frameset',
                 attr_list => $token->{attr_list},
                 et => (FRAMESET_EL), aet => (FRAMESET_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [149] in frameset;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'in frameset',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
              
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [150] in head noscript;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [151] in head noscript;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [152] in head noscript;END:br
        sub {
          my $token = $_;
push @$Errors, {type => 'in noscript',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [153] in head noscript;END:noscript
        sub {
          push @$OP, ['popped', [pop @$OE]];

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
        },
      ,
        ## [154] in head noscript;EOF
        sub {
          my $token = $_;
push @$Errors, {type => 'in noscript',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [155] in head noscript;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in noscript',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [156] in head noscript;START:head,noscript
        sub {
          my $token = $_;
push @$Errors, {type => 'in noscript',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [157] in head noscript;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'in noscript',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [158] in head;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [159] in head;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [160] in head;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [161] in head;END:body,br,html
        sub {
          my $token = $_;
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [162] in head;END:head
        sub {
          push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        
        },
      ,
        ## [163] in head;END:template
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            pop @$OE while $OE->[-1]->{et} & (CAP_ELS | COL_ELS | DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS);

          if (not ($OE->[-1]->{et} & (TEM_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      
pop @$TEMPLATE_IMS;
&reset_im;
          }
        
        },
      ,
        ## [164] in head;EOF
        sub {
          my $token = $_;
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [165] in head;START-ELSE
        sub {
          my $token = $_;
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [166] in head;START:base,basefont bgsound link
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [167] in head;START:head
        sub {
          my $token = $_;
push @$Errors, {type => 'in head:head',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [168] in head;START:meta
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'meta',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        if (defined $token->{attrs}->{charset}) {
          push @$OP, ['change-the-encoding',
                      (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                      $token->{attrs}->{charset}];
        } elsif (defined $token->{attrs}->{'http-equiv'} and
                 defined $token->{attrs}->{content}) {
          # IndexedString
          if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                  =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
              (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                  =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                        [\x09\x0A\x0C\x0D\x20]*=
                        [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                        ([^"'\x09\x0A\x0C\x0D\x20]
                         [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
            push @$OP, ['change-the-encoding',
                        defined $1 ? $1 : defined $2 ? $2 : $3,
                        $token->{attrs}->{content}];
          }
        }
      
        },
      ,
        ## [169] in head;START:noframes,style
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [170] in head;START:noscript
        sub {
          my $token = $_;

          if ($Scripting) {
            
        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
          } else {
            
        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          $IM = IN_HEAD_NOSCRIPT_IM;
          #warn "Insertion mode changed to |in head noscript| ($IM)";
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [171] in head;START:script
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'script',
                 attr_list => $token->{attr_list},
                 et => (SCRIPT_EL), aet => (SCRIPT_EL) , script_flags => 1};
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = SCRIPT_DATA_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [172] in head;START:template
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'template',
                 attr_list => $token->{attr_list},
                 et => (TEMPLATE_EL), aet => (TEMPLATE_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
push @$AFE, '#marker';

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      

          $IM = IN_TEMPLATE_IM;
          #warn "Insertion mode changed to |in template| ($IM)";
        

        push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
      
        },
      ,
        ## [173] in head;START:title
        sub {
          my $token = $_;

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'title',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RCDATA_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [174] in head;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [175] in row;END:body,caption,col,colgroup,html,td th
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [176] in row;END:table
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TR_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [177] in row;END:tbody tfoot thead
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TR_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [178] in row;END:tr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TR_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        
          }
        
        },
      ,
        ## [179] in row;START:caption,col,colgroup,tbody tfoot thead,tr
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TR_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'in table row',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [180] in row;START:td th
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          $IM = IN_CELL_IM;
          #warn "Insertion mode changed to |in cell| ($IM)";
        
push @$AFE, '#marker';

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [181] in row;TEXT
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
            @$TABLE_CHARS = ();
$ORIGINAL_IM = $IM;

          $IM = IN_TABLE_TEXT_IM;
          #warn "Insertion mode changed to |in table text| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          } else {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
        },
      ,
        ## [182] in select in table;END:caption,table,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'in select in table:end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [183] in select in table;START:caption,table,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'in select in table:start tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [184] in select in table;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x00]+)//) {
              
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x00]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [185] in select;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [186] in select;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [187] in select;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in select',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [188] in select;END:optgroup
        sub {
          my $token = $_;

          if (($OE->[-1]->{et} == OPTION_EL) and 
(@$OE >= 2 and $OE->[-2]->{et} == OPTGROUP_EL)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

          if ($OE->[-1]->{et} == OPTGROUP_EL) {
            push @$OP, ['popped', [pop @$OE]];
          } else {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          }
        
        },
      ,
        ## [189] in select;END:option
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} == OPTION_EL) {
            push @$OP, ['popped', [pop @$OE]];
          } else {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          }
        
        },
      ,
        ## [190] in select;END:select
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == SELECT_EL) {
            $result = 1;
            last;
          } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;
          }
        
        },
      ,
        ## [191] in select;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in select',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [192] in select;START:input,keygen,textarea
        sub {
          my $token = $_;
push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == SELECT_EL) {
            $result = 1;
            last;
          } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
          }
        }
        not $result;
      }
    ) {
            
          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [193] in select;START:optgroup
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} == OPTION_EL) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

          if ($OE->[-1]->{et} == OPTGROUP_EL) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'optgroup',
                 attr_list => $token->{attr_list},
                 et => (OPTGROUP_EL), aet => (OPTGROUP_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [194] in select;START:option
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} == OPTION_EL) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'option',
                 attr_list => $token->{attr_list},
                 et => (OPTION_EL), aet => (OPTION_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [195] in select;START:select
        sub {
          my $token = $_;
push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == SELECT_EL) {
            $result = 1;
            last;
          } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
          }
        }
        not $result;
      }
    ) {
            return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [196] in select;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x00]+)//) {
              
      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x00]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [197] in table body;END:body,caption,col,colgroup,html,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [198] in table body;END:table
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TBO_TFO_THE_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [199] in table body;END:tbody tfoot thead
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        
          }
        
        },
      ,
        ## [200] in table body;START:caption,col,colgroup,tbody tfoot thead
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TBO_TFO_THE_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'in table body',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$OP, ['popped', [pop @$OE]];

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [201] in table body;START:td th
        sub {
          my $token = $_;
push @$Errors, {type => 'no <tr>',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node_tr = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'tr',
                 attr_list => [],
                 et => (TR_EL), aet => (TR_EL) };
      

      push @$OP, ['insert', $node_tr => $OE->[-1]->{id}];
    

push @$OE, $node_tr;

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [202] in table body;START:tr
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'tr',
                 attr_list => $token->{attr_list},
                 et => (TR_EL), aet => (TR_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        
        },
      ,
        ## [203] in table body;TEXT
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
            @$TABLE_CHARS = ();
$ORIGINAL_IM = $IM;

          $IM = IN_TABLE_TEXT_IM;
          #warn "Insertion mode changed to |in table text| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          } else {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
        },
      ,
        ## [204] in table text;COMMENT
        sub {
          my $token = $_;

          if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $TABLE_CHARS->[0]->{di},
                        index => $TABLE_CHARS->[0]->{index}};

          for my $token (@$TABLE_CHARS) {
            
            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
          } else {
            
      push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
    
          }
        

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [205] in table text;DOCTYPE
        sub {
          my $token = $_;

          if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $TABLE_CHARS->[0]->{di},
                        index => $TABLE_CHARS->[0]->{index}};

          for my $token (@$TABLE_CHARS) {
            
            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
          } else {
            
      push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
    
          }
        

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [206] in table text;END-ELSE
        sub {
          my $token = $_;

          if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $TABLE_CHARS->[0]->{di},
                        index => $TABLE_CHARS->[0]->{index}};

          for my $token (@$TABLE_CHARS) {
            
            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
          } else {
            
      push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
    
          }
        

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [207] in table text;EOF
        sub {
          my $token = $_;

          if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $TABLE_CHARS->[0]->{di},
                        index => $TABLE_CHARS->[0]->{index}};

          for my $token (@$TABLE_CHARS) {
            
            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
          } else {
            
      push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
    
          }
        

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [208] in table text;START-ELSE
        sub {
          my $token = $_;

          if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $TABLE_CHARS->[0]->{di},
                        index => $TABLE_CHARS->[0]->{index}};

          for my $token (@$TABLE_CHARS) {
            
            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
          } else {
            
      push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
    
          }
        

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [209] in table text;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x00]+)//) {
              push @$TABLE_CHARS, {%$token, value => $1};
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x00]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [210] in table;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [211] in table;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [212] in table;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        goto &{$ProcessIM->[IN_BODY_IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [213] in table;END:a,b big code em i s small strike strong tt u,font,nobr
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
aaa_foster ($token, $token->{tag_name});
        },
      ,
        ## [214] in table;END:body,caption,col,colgroup,html,tbody tfoot thead,td th,tr
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [215] in table;END:br
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => '</br>',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node_br = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'br',
                 attr_list => [],
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node_br => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node_br => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node_br => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node_br => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [216] in table;END:p
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => '</p>',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node_p = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'p',
                 attr_list => [],
                 et => (P_EL), aet => (P_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node_p => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node_p => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node_p => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node_p => $OE->[-1]->{id}];
      }
    

push @$OE, $node_p;
          }
        
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
        },
      ,
        ## [217] in table;END:table
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TAB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TAB_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;
          }
        
        },
      ,
        ## [218] in table;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [219] in table;START:a
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$AFE) {
          last if not ref $_;
          if ($_->{et} == A_EL) {
            $result = 1;
            last;
          }
        }
        $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
aaa_foster ($token, 'a', remove_from_afe_and_oe => 1);
          }
        
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'a',
                 attr_list => $token->{attr_list},
                 et => (A_EL), aet => (A_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [220] in table;START:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl ol ul,fieldset,p
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [221] in table;START:applet marquee,object
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          
push @$OE, $node;
push @$AFE, '#marker';

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [222] in table;START:area wbr,br,embed,img,keygen
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

            if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | KEY_OUT_ELS | OBJ_ELS | TEX_ELS)) {
              
          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
            }
          

          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [223] in table;START:b big code em i s small strike strong tt u,font
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [224] in table;START:base,basefont bgsound link
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [225] in table;START:body
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => 'duplicate body/html tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if ((@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS))) or 
($OE->[-1]->{et} & (HTM_ELS)) or 
(
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    )) {
            return;
          } else {
            
        $FRAMESET_OK = 0;
      

        push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[1]->{id}]
            if @{$token->{attr_list} or []};
      
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [226] in table;START:button
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (BUT_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (BUT_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'button',
                 attr_list => $token->{attr_list},
                 et => (BUTTON_EL), aet => (BUTTON_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [227] in table;START:caption
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }
push @$AFE, '#marker';

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'caption',
                 attr_list => $token->{attr_list},
                 et => (CAPTION_EL), aet => (CAPTION_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_CAPTION_IM;
          #warn "Insertion mode changed to |in caption| ($IM)";
        
        },
      ,
        ## [228] in table;START:col
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node_colgroup = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'colgroup',
                 attr_list => [],
                 et => (COLGROUP_EL), aet => (COLGROUP_EL) };
      

      push @$OP, ['insert', $node_colgroup => $OE->[-1]->{id}];
    

push @$OE, $node_colgroup;

          $IM = IN_COLUMN_GROUP_IM;
          #warn "Insertion mode changed to |in column group| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [229] in table;START:colgroup
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'colgroup',
                 attr_list => $token->{attr_list},
                 et => (COLGROUP_EL), aet => (COLGROUP_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_COLUMN_GROUP_IM;
          #warn "Insertion mode changed to |in column group| ($IM)";
        
        },
      ,
        ## [230] in table;START:dd dt
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        $FRAMESET_OK = 0;
      

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{et} & (DD_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (DD_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (DD_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (DT_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (DT_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (DT_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            last;
          } else {
            
          }
        
          }
        
          }
        
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [231] in table;START:form
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ((
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) or 
(defined $FORM_ELEMENT)) {
            return;
          } else {
            
        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'form',
                 attr_list => $token->{attr_list},
                 et => (FORM_EL), aet => (FORM_EL) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;
$FORM_ELEMENT = $node;
push @$OP, ['popped', [pop @$OE]];
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [232] in table;START:frame,head
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [233] in table;START:frameset
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (($OE->[-1]->{et} & (HTM_ELS)) or 
(@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS)))) {
            return;
          }
        

          if (not $FRAMESET_OK) {
            return;
          } else {
            
        push @$OP, ['remove', $OE->[1]->{id}];
      
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $OE->[1]);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'frameset',
                 attr_list => $token->{attr_list},
                 et => (FRAMESET_EL), aet => (FRAMESET_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          $IM = IN_FRAMESET_IM;
          #warn "Insertion mode changed to |in frameset| ($IM)";
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [234] in table;START:h1 h2 h3 h4 h5 h6
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (HHHHHH_ELS)) {
            push @$Errors, {type => 'in hn:hn',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [235] in table;START:hr
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'hr',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [236] in table;START:html
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => 'duplicate body/html tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
         $result;
      }
    ) {
            return;
          } else {
            
        push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[0]->{id}]
            if @{$token->{attr_list} or []};
      
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [237] in table;START:iframe
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        $FRAMESET_OK = 0;
      

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'iframe',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [238] in table;START:image
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$Errors, {type => 'image',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node_img = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'img',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | IMG_ELS), aet => (HTML_NS_ELS | IMG_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node_img => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node_img => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node_img => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node_img => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      
        },
      ,
        ## [239] in table;START:input
        sub {
          my $token = $_;

          if (
      not (
        defined $token->{attrs}->{type} and
        do {
          my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
          $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
          $value eq q@hidden@;
        }
      )
    ) {
            push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'input',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        

          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

          if (
      not (
        defined $token->{attrs}->{type} and
        do {
          my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
          $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
          $value eq q@hidden@;
        }
      )
    ) {
            
        $FRAMESET_OK = 0;
      
          }
        
          } else {
            push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'input',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        

          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
          }
        
        },
      ,
        ## [240] in table;START:li
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        $FRAMESET_OK = 0;
      

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ($_node->{et} & (LI_ELS)) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (LI_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
last;
          } else {
            
          if ($_node->{et} & (APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
            last;
          } else {
            
          }
        
          }
        
          }
        

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'li',
                 attr_list => $token->{attr_list},
                 et => (LI_EL), aet => (LI_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [241] in table;START:listing pre
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

        $FRAMESET_OK = 0;
      

        $ORIGINAL_IM = $IM;
        $IM = BEFORE_IGNORED_NEWLINE_IM;
      
        },
      ,
        ## [242] in table;START:math
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
my $ns = MATHMLNS;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
        },
      ,
        ## [243] in table;START:menu
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'menu',
                 attr_list => $token->{attr_list},
                 et => (MENU_EL), aet => (MENU_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [244] in table;START:menuitem
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($OE->[-1]->{et} & (MEN_ELS)) {
            push @$OP, ['popped', [pop @$OE]];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'menuitem',
                 attr_list => $token->{attr_list},
                 et => (MENUITEM_EL), aet => (MENUITEM_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [245] in table;START:meta
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'meta',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        

        if (defined $token->{attrs}->{charset}) {
          push @$OP, ['change-the-encoding',
                      (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                      $token->{attrs}->{charset}];
        } elsif (defined $token->{attrs}->{'http-equiv'} and
                 defined $token->{attrs}->{content}) {
          # IndexedString
          if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                  =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
              (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                  =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                        [\x09\x0A\x0C\x0D\x20]*=
                        [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                        ([^"'\x09\x0A\x0C\x0D\x20]
                         [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
            push @$OP, ['change-the-encoding',
                        defined $1 ? $1 : defined $2 ? $2 : $3,
                        $token->{attrs}->{content}];
          }
        }
      
        },
      ,
        ## [246] in table;START:nobr
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} == NOBR_EL) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
aaa_foster ($token, 'nobr');
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'nobr',
                 attr_list => $token->{attr_list},
                 et => (NOBR_EL), aet => (NOBR_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

        ## Noah's Ark
        my $found = 0;
        AFE: for my $i (reverse 0..$#$AFE) {
          if (not ref $AFE->[$i]) { # marker
            last;
          } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                   #and $node->{ns} == $AFE->[$i]->{ns}
          ) {
            ## Note that elements in $AFE are always HTML elements.
            for (keys %{$node->{token}->{attrs} or {}}) {
              my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
              next AFE unless defined $attr;
              #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
              # IndexedString
              next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                              (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
            }
            next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});

            $found++;
            if ($found == 3) {
              splice @$AFE, $i, 1, ();
              last AFE;
            }
          }
        } # AFE

        push @$AFE, $node;
      

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [247] in table;START:noembed
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noembed',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [248] in table;START:noframes
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noframes',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [249] in table;START:noscript
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($Scripting) {
            
        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
          } else {
            &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'noscript',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [250] in table;START:optgroup,option
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($OE->[-1]->{et} == OPTION_EL) {
            push @$OP, ['popped', [pop @$OE]];
          }
        
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [251] in table;START:param source track
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    


          if (delete $token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc', level => 'w',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        
        },
      ,
        ## [252] in table;START:plaintext
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'plaintext',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = PLAINTEXT_STATE;
        },
      ,
        ## [253] in table;START:rb rtc
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (RUB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (RUB_ELS))) {
            push @$Errors, {type => 'in body',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
          }
        
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [254] in table;START:rp rt
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (RUB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS);

          if (not ($OE->[-1]->{et} & (RTC_ELS | RUB_ELS))) {
            push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
          }
        

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [255] in table;START:select
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'select',
                 attr_list => $token->{attr_list},
                 et => (SELECT_EL), aet => (SELECT_EL) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

        $FRAMESET_OK = 0;
      

          if ($IM == IN_TABLE_IM or $IM == IN_CAPTION_IM or $IM == IN_TABLE_BODY_IM or $IM == IN_ROW_IM or $IM == IN_CELL_IM) {
            
          $IM = IN_SELECT_IN_TABLE_IM;
          #warn "Insertion mode changed to |in select in table| ($IM)";
        
          } else {
            
          $IM = IN_SELECT_IM;
          #warn "Insertion mode changed to |in select| ($IM)";
        
          }
        

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [256] in table;START:svg
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
my $ns = SVGNS;

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => $ns,
                    local_name => $token->{tag_name},
                    attr_list => $token->{attr_list},
                    et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                    aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
      

        if (defined $token->{attrs}->{xmlns}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
          if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
            #
          } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
            #
          } else {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{xmlns}->{di},
                            index => $token->{attrs}->{xmlns}->{index}};
          }
        }
        if (defined $token->{attrs}->{'xmlns:xlink'}) {
          # IndexedString
          my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
          unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
            push @$Errors, {type => 'foreign:bad xmlns value',
                            level => 'm',
                            value => $xmlns,
                            di => $token->{attrs}->{'xmlns:xlink'}->{di},
                            index => $token->{attrs}->{'xmlns:xlink'}->{index}};
          }
        }

        ## Adjust foreign attributes
        ## Adjust SVG attributes
        ## Adjust MathML attributes
        my $map = $ForeignAttrMap->[$ns];
        for my $attr (@{$token->{attr_list} or []}) {
          $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
        }
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
        },
      ,
        ## [257] in table;START:table
        sub {
          my $token = $_;
push @$Errors, {type => 'parser:element not nestable',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TAB_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
          }
        }
        not $result;
      }
    ) {
            
          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
          } else {
            {
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TAB_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [258] in table;START:tbody tfoot thead
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => $token->{tag_name},
                 attr_list => $token->{attr_list},
                 et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
      

      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        
        },
      ,
        ## [259] in table;START:td th,tr
        sub {
          my $token = $_;
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
          push @$OP, ['popped', \@popped];
        }

        my $node_tbody = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'tbody',
                 attr_list => [],
                 et => (TBODY_EL), aet => (TBODY_EL) };
      

      push @$OP, ['insert', $node_tbody => $OE->[-1]->{id}];
    

push @$OE, $node_tbody;

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [260] in table;START:textarea
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'textarea',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | TEX_ELS), aet => (HTML_NS_ELS | TEX_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

          if (defined $FORM_ELEMENT) {
            FORM: {
              last FORM if defined $token->{attrs}->{form} and
                           ($node->{et} & ()); # reassociateable
              for my $oe (@$OE) {
                if ($oe->{et} & (TEM_ELS)) { # template
                  last FORM;
                }
              }
              #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
              $node->{form} = $FORM_ELEMENT->{id};
            } # FORM
          }
        
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RCDATA_STATE;
$ORIGINAL_IM = $IM;

        $FRAMESET_OK = 0;
      

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        

        $IM = BEFORE_IGNORED_NEWLINE_AND_TEXT_IM;
      
        },
      ,
        ## [261] in table;START:title
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'title',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RCDATA_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [262] in table;START:xmp
        sub {
          my $token = $_;
push @$Errors, {type => 'in table',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (P_ELS)) {
            $result = 1;
            last;
          } elsif ($_->{et} & (APP_ELS | BUT_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
          }
        }
         $result;
      }
    ) {
            pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | MEN_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);

          if (not ($OE->[-1]->{et} & (P_ELS))) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
          }
        
&reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

        $FRAMESET_OK = 0;
      

        my $node = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'xmp',
                 attr_list => $token->{attr_list},
                 et => (HTML_NS_ELS), aet => (HTML_NS_ELS) };
      

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    

push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
$State = RAWTEXT_STATE;
$ORIGINAL_IM = $IM;

          $IM = TEXT_IM;
          #warn "Insertion mode changed to |text| ($IM)";
        
        },
      ,
        ## [263] in table;TEXT
        sub {
          my $token = $_;

          if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
            @$TABLE_CHARS = ();
$ORIGINAL_IM = $IM;

          $IM = IN_TABLE_TEXT_IM;
          #warn "Insertion mode changed to |in table text| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          } else {
            push @$Errors, {type => 'in table:#text',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];

      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      }
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
          }
        
        },
      ,
        ## [264] in template;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [265] in template;EOF
        sub {
          my $token = $_;

          if (
      do {
        my $result = 0;
        for (reverse @$OE) {
          if ($_->{et} & (TEM_ELS)) {
            $result = 1;
            last;
          
          }
        }
        not $result;
      }
    ) {
            push @$OP, ['stop-parsing'];
          } else {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }

        pop @$AFE while ref $AFE->[-1];
        pop @$AFE; # #marker
      
pop @$TEMPLATE_IMS;
&reset_im;

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [266] in template;START-ELSE
        sub {
          my $token = $_;
pop @$TEMPLATE_IMS;

        push @$TEMPLATE_IMS, IN_BODY_IM;
      

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [267] in template;START:caption,colgroup,tbody tfoot thead
        sub {
          my $token = $_;
pop @$TEMPLATE_IMS;

        push @$TEMPLATE_IMS, IN_TABLE_IM;
      

          $IM = IN_TABLE_IM;
          #warn "Insertion mode changed to |in table| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [268] in template;START:col
        sub {
          my $token = $_;
pop @$TEMPLATE_IMS;

        push @$TEMPLATE_IMS, IN_COLUMN_GROUP_IM;
      

          $IM = IN_COLUMN_GROUP_IM;
          #warn "Insertion mode changed to |in column group| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [269] in template;START:td th
        sub {
          my $token = $_;
pop @$TEMPLATE_IMS;

        push @$TEMPLATE_IMS, IN_ROW_IM;
      

          $IM = IN_ROW_IM;
          #warn "Insertion mode changed to |in row| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [270] in template;START:tr
        sub {
          my $token = $_;
pop @$TEMPLATE_IMS;

        push @$TEMPLATE_IMS, IN_TABLE_BODY_IM;
      

          $IM = IN_TABLE_BODY_IM;
          #warn "Insertion mode changed to |in table body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [271] in template;TEXT
        sub {
          my $token = $_;

            if (index ($token->{value}, "\x00") > -1) {
              pos ($token->{value}) = 0;
              while (pos $token->{value} < length $token->{value}) {
                if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    

        $FRAMESET_OK = 0;
      
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                  &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
                  $token->{index} += length $1;
                }
                if ($token->{value} =~ /\G([\x00]+)/gc) {
                  
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
                  $token->{index} += length $1;
                }
              }
            } else {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];

      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
            }
          
        },
      ,
        ## [272] initial;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [273] initial;DOCTYPE
        sub {
          my $token = $_;
push @$OP, ['doctype', $token => 0]; $NEXT_ID++;

        if (not defined $token->{name} or not $token->{name} eq 'html') {
          push @$Errors, {level => 'm',
                          type => 'bad DOCTYPE name',
                          text => 'html',
                          value => $token->{name},
                          di => $token->{di}, index => $token->{index}};
          unless ($IframeSrcdoc) {
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        } elsif (defined $token->{public_identifier}) {
          if (defined $OPPublicIDToSystemID->{$token->{public_identifier}}) {
            if (defined $token->{system_identifier}) {
              if ($OPPublicIDToSystemID->{$token->{public_identifier}} eq $token->{system_identifier}) {
                push @$Errors, {type => 'obsolete permitted DOCTYPE',
                                level => 's',
                                di => $token->{di}, index => $token->{index}};
              } else {
                push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                                di => $token->{di}, index => $token->{index}};
                unless ($IframeSrcdoc) {
                  my $sysid = $token->{system_identifier};
                  $sysid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
                  if ($QSystemIDs->{$sysid}) {
                    push @$OP, ['set-compat-mode', 'quirks'];
                    $QUIRKS = 1;
                  }
                }
              }
            } else {
              if ($OPPublicIDOnly->{$token->{public_identifier}}) {
                push @$Errors, {type => 'obsolete permitted DOCTYPE',
                                level => 's',
                                di => $token->{di}, index => $token->{index}};
              } else {
                push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                                di => $token->{di}, index => $token->{index}};
              }
            }
          } else {
            push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                            di => $token->{di}, index => $token->{index}};
            unless ($IframeSrcdoc) {
              my $pubid = $token->{public_identifier};
              $pubid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
              if ($QPublicIDs->{$pubid}) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif ($pubid =~ /^$QPublicIDPrefixPattern/o) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif (defined $token->{system_identifier} and
                       do {
                         my $sysid = $token->{system_identifier};
                         $sysid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
                         $QSystemIDs->{$sysid};
                       }) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif ($pubid =~ /^$LQPublicIDPrefixPattern/o) {
                push @$OP, ['set-compat-mode', 'limited quirks'];
              } elsif ($pubid =~ /^$QorLQPublicIDPrefixPattern/o) {
                if (defined $token->{system_identifier}) {
                  push @$OP, ['set-compat-mode', 'limited quirks'];
                } else {
                  push @$OP, ['set-compat-mode', 'quirks'];
                  $QUIRKS = 1;
                }
              }
            }
          }
        } elsif (defined $token->{system_identifier}) {
          if ($token->{system_identifier} eq 'about:legacy-compat') {
            push @$Errors, {type => 'legacy DOCTYPE', level => 's',
                            di => $token->{di}, index => $token->{index}};
          } else {
            push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                            di => $token->{di}, index => $token->{index}};
            unless ($IframeSrcdoc) {
              my $sysid = $token->{system_identifier};
              $sysid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
              if ($QSystemIDs->{$sysid}) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              }
            }
          }
        }
        if ($token->{force_quirks_flag}) {
          unless ($IframeSrcdoc) {
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        }
      

          $IM = BEFORE_HTML_IM;
          #warn "Insertion mode changed to |before html| ($IM)";
        
        },
      ,
        ## [274] initial;END-ELSE
        sub {
          my $token = $_;

          unless ($IframeSrcdoc) {
            push @$Errors, {type => 'no DOCTYPE',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        

          $IM = BEFORE_HTML_IM;
          #warn "Insertion mode changed to |before html| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [275] initial;EOF
        sub {
          my $token = $_;

          unless ($IframeSrcdoc) {
            push @$Errors, {type => 'no DOCTYPE',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        

          $IM = BEFORE_HTML_IM;
          #warn "Insertion mode changed to |before html| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [276] initial;START-ELSE
        sub {
          my $token = $_;

          unless ($IframeSrcdoc) {
            push @$Errors, {type => 'no DOCTYPE',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        

          $IM = BEFORE_HTML_IM;
          #warn "Insertion mode changed to |before html| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [277] initial;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          
          unless ($IframeSrcdoc) {
            push @$Errors, {type => 'no DOCTYPE',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
            push @$OP, ['set-compat-mode', 'quirks'];
            $QUIRKS = 1;
          }
        

          $IM = BEFORE_HTML_IM;
          #warn "Insertion mode changed to |before html| ($IM)";
        

        my $node = {id => $NEXT_ID++,
                    token => $token,
                    di => $token->{di}, index => $token->{index},
                    ns => HTMLNS,
                    local_name => 'html',
                    attr_list => [],
                    et => (HTML_EL), aet => (HTML_EL)};
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          $IM = BEFORE_HEAD_IM;
          #warn "Insertion mode changed to |before head| ($IM)";
        

        my $node_head = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'head',
                 attr_list => [],
                 et => (HEAD_EL), aet => (HEAD_EL) };
      

      push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
    

push @$OE, $node_head;
$HEAD_ELEMENT = $node_head;

          $IM = IN_HEAD_IM;
          #warn "Insertion mode changed to |in head| ($IM)";
        
push @$OP, ['popped', [pop @$OE]];

          $IM = AFTER_HEAD_IM;
          #warn "Insertion mode changed to |after head| ($IM)";
        

        my $node_body = {id => $NEXT_ID++,
                 token => $token,
                 di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'body',
                 attr_list => [],
                 et => (BODY_EL), aet => (BODY_EL) };
      

      push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
    

push @$OE, $node_body;

          $IM = IN_BODY_IM;
          #warn "Insertion mode changed to |in body| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        }
      
        },
      ,
        ## [278] text;COMMENT
        sub {
          
        },
      ,
        ## [279] text;DOCTYPE
        sub {
          
        },
      ,
        ## [280] text;END-ELSE
        sub {
          push @$OP, ['popped', [pop @$OE]];

            $IM = $ORIGINAL_IM;
          
        },
      ,
        ## [281] text;END:script
        sub {
          my $script = $OE->[-1];
push @$OP, ['popped', [pop @$OE]];

            $IM = $ORIGINAL_IM;
          
push @$OP, ['script', $script->{id}];
        },
      ,
        ## [282] text;EOF
        sub {
          my $token = $_;
push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};

          if ($OE->[-1]->{et} == SCRIPT_EL) {
            push @$OP, ['ignore-script', $OE->[-1]->{id}];
          }
        
push @$OP, ['popped', [pop @$OE]];

            $IM = $ORIGINAL_IM;
          

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [283] text;START-ELSE
        sub {
          my $token = $_;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [284] text;TEXT
        sub {
          my $token = $_;

      push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
        },
      ];
    
$ProcessIM = [undef,
[undef, [$TCA->[62]], [$TCA->[1]], [$TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2]], [$TCA->[3]], [$TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[91], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4]], [$TCA->[5]]],
[undef, [$TCA->[62]], [$TCA->[6]], [$TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7]], [$TCA->[8]], [$TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[91], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[169], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9]], [$TCA->[10]]],
[undef, [$TCA->[12]], [$TCA->[11]], [$TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[14], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13]], [$TCA->[15]], [$TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[91], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16]], [$TCA->[17]]],
[undef, [$TCA->[19]], [$TCA->[18]], [$TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[21], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20]], [$TCA->[22]], [$TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[91], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[169], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23]], [$TCA->[24]]],
[undef, [$TCA->[26]], [$TCA->[25]], [$TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[28], $TCA->[28], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[28], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[163], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27]], [$TCA->[29]], [$TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[31], $TCA->[31], $TCA->[30], $TCA->[32], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[33], $TCA->[30], $TCA->[34], $TCA->[30], $TCA->[91], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[35], $TCA->[30], $TCA->[30], $TCA->[36], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[37], $TCA->[30], $TCA->[36], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[38], $TCA->[30], $TCA->[39], $TCA->[30], $TCA->[30]], [$TCA->[40]]],
[undef, [$TCA->[42]], [$TCA->[41]], [$TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[44], $TCA->[44], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[44], $TCA->[43], $TCA->[44], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43]], [$TCA->[45]], [$TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[47], $TCA->[46], $TCA->[91], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46]], [$TCA->[48]]],
[undef, [$TCA->[50]], [$TCA->[49]], [$TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[52], $TCA->[52], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[52], $TCA->[51], $TCA->[52], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51]], [$TCA->[53]], [$TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[55], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54]], [$TCA->[56]]],
[undef, [$TCA->[59]], [$TCA->[59]], [$TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59]], [$TCA->[59]], [$TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59]], [$TCA->[60]]],
[undef, [$TCA->[57]], [$TCA->[57]], [$TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57]], [$TCA->[57]], [$TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57]], [$TCA->[58]]],
[undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[67], $TCA->[68], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[72], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[163], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[166], $TCA->[166], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[85], $TCA->[85], $TCA->[85], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[98], $TCA->[99], $TCA->[168], $TCA->[100], $TCA->[101], $TCA->[169], $TCA->[102], $TCA->[80], $TCA->[103], $TCA->[103], $TCA->[77], $TCA->[79], $TCA->[104], $TCA->[105], $TCA->[106], $TCA->[107], $TCA->[77], $TCA->[77], $TCA->[171], $TCA->[108], $TCA->[169], $TCA->[109], $TCA->[110], $TCA->[85], $TCA->[85], $TCA->[172], $TCA->[111], $TCA->[173], $TCA->[85], $TCA->[112]], [$TCA->[113]]],
[undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[114], $TCA->[68], $TCA->[65], $TCA->[115], $TCA->[114], $TCA->[114], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[114], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[116], $TCA->[114], $TCA->[114], $TCA->[163], $TCA->[63], $TCA->[63], $TCA->[114], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[166], $TCA->[166], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[117], $TCA->[117], $TCA->[117], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[98], $TCA->[99], $TCA->[168], $TCA->[100], $TCA->[101], $TCA->[169], $TCA->[102], $TCA->[80], $TCA->[103], $TCA->[103], $TCA->[77], $TCA->[79], $TCA->[104], $TCA->[105], $TCA->[106], $TCA->[107], $TCA->[77], $TCA->[77], $TCA->[171], $TCA->[108], $TCA->[169], $TCA->[109], $TCA->[110], $TCA->[117], $TCA->[117], $TCA->[172], $TCA->[111], $TCA->[173], $TCA->[117], $TCA->[112]], [$TCA->[118]]],
[undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[119], $TCA->[68], $TCA->[65], $TCA->[119], $TCA->[119], $TCA->[119], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[119], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[120], $TCA->[120], $TCA->[121], $TCA->[163], $TCA->[63], $TCA->[63], $TCA->[120], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[166], $TCA->[166], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[122], $TCA->[122], $TCA->[122], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[98], $TCA->[99], $TCA->[168], $TCA->[100], $TCA->[101], $TCA->[169], $TCA->[102], $TCA->[80], $TCA->[103], $TCA->[103], $TCA->[77], $TCA->[79], $TCA->[104], $TCA->[105], $TCA->[106], $TCA->[107], $TCA->[77], $TCA->[77], $TCA->[171], $TCA->[108], $TCA->[169], $TCA->[109], $TCA->[110], $TCA->[122], $TCA->[122], $TCA->[172], $TCA->[111], $TCA->[173], $TCA->[122], $TCA->[112]], [$TCA->[123]]],
[undef, [$TCA->[125]], [$TCA->[124]], [$TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[127], $TCA->[128], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[163], $TCA->[126], $TCA->[126], $TCA->[126], $TCA->[126]], [$TCA->[76]], [$TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[130], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[91], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[172], $TCA->[129], $TCA->[129], $TCA->[129], $TCA->[129]], [$TCA->[131]]],
[undef, [$TCA->[133]], [$TCA->[132]], [$TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[135], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134], $TCA->[134]], [$TCA->[136]], [$TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[138], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[138], $TCA->[137], $TCA->[139], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[138], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[138], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[138], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137], $TCA->[137]], [$TCA->[140]]],
[undef, [$TCA->[142]], [$TCA->[141]], [$TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[144], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143], $TCA->[143]], [$TCA->[145]], [$TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[147], $TCA->[148], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[91], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[169], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146], $TCA->[146]], [$TCA->[149]]],
[undef, [$TCA->[159]], [$TCA->[158]], [$TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[161], $TCA->[161], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[162], $TCA->[160], $TCA->[161], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[163], $TCA->[160], $TCA->[160], $TCA->[160], $TCA->[160]], [$TCA->[164]], [$TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[166], $TCA->[166], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[167], $TCA->[165], $TCA->[91], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[168], $TCA->[165], $TCA->[165], $TCA->[169], $TCA->[170], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[171], $TCA->[165], $TCA->[169], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[165], $TCA->[172], $TCA->[165], $TCA->[173], $TCA->[165], $TCA->[165]], [$TCA->[174]]],
[undef, [$TCA->[150]], [$TCA->[158]], [$TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[152], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[153], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151], $TCA->[151]], [$TCA->[154]], [$TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[166], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[156], $TCA->[155], $TCA->[91], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[168], $TCA->[155], $TCA->[155], $TCA->[169], $TCA->[156], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[169], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155], $TCA->[155]], [$TCA->[157]]],
[undef, [$TCA->[211]], [$TCA->[210]], [$TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[175], $TCA->[215], $TCA->[212], $TCA->[175], $TCA->[175], $TCA->[175], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[175], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[216], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[176], $TCA->[177], $TCA->[175], $TCA->[163], $TCA->[212], $TCA->[212], $TCA->[178], $TCA->[212]], [$TCA->[76]], [$TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[223], $TCA->[224], $TCA->[224], $TCA->[220], $TCA->[225], $TCA->[222], $TCA->[226], $TCA->[179], $TCA->[179], $TCA->[179], $TCA->[230], $TCA->[222], $TCA->[220], $TCA->[223], $TCA->[231], $TCA->[232], $TCA->[233], $TCA->[234], $TCA->[232], $TCA->[235], $TCA->[236], $TCA->[237], $TCA->[238], $TCA->[222], $TCA->[239], $TCA->[222], $TCA->[240], $TCA->[241], $TCA->[218], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[246], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[221], $TCA->[250], $TCA->[250], $TCA->[218], $TCA->[220], $TCA->[251], $TCA->[252], $TCA->[253], $TCA->[254], $TCA->[218], $TCA->[218], $TCA->[171], $TCA->[255], $TCA->[169], $TCA->[256], $TCA->[257], $TCA->[179], $TCA->[180], $TCA->[172], $TCA->[260], $TCA->[261], $TCA->[179], $TCA->[262]], [$TCA->[181]]],
[undef, [$TCA->[186]], [$TCA->[185]], [$TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[188], $TCA->[189], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[190], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[163], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187]], [$TCA->[76]], [$TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[91], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[192], $TCA->[192], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[193], $TCA->[194], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[171], $TCA->[195], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[172], $TCA->[192], $TCA->[191], $TCA->[191], $TCA->[191]], [$TCA->[196]]],
[undef, [$TCA->[186]], [$TCA->[185]], [$TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[182], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[188], $TCA->[189], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[187], $TCA->[190], $TCA->[187], $TCA->[187], $TCA->[182], $TCA->[182], $TCA->[182], $TCA->[163], $TCA->[187], $TCA->[187], $TCA->[182], $TCA->[187]], [$TCA->[76]], [$TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[183], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[91], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[192], $TCA->[192], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[193], $TCA->[194], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[191], $TCA->[171], $TCA->[195], $TCA->[191], $TCA->[191], $TCA->[183], $TCA->[183], $TCA->[183], $TCA->[172], $TCA->[192], $TCA->[191], $TCA->[183], $TCA->[191]], [$TCA->[184]]],
[undef, [$TCA->[211]], [$TCA->[210]], [$TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[214], $TCA->[215], $TCA->[212], $TCA->[214], $TCA->[214], $TCA->[214], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[214], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[216], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[217], $TCA->[214], $TCA->[214], $TCA->[163], $TCA->[212], $TCA->[212], $TCA->[214], $TCA->[212]], [$TCA->[76]], [$TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[223], $TCA->[224], $TCA->[224], $TCA->[220], $TCA->[225], $TCA->[222], $TCA->[226], $TCA->[227], $TCA->[228], $TCA->[229], $TCA->[230], $TCA->[222], $TCA->[220], $TCA->[223], $TCA->[231], $TCA->[232], $TCA->[233], $TCA->[234], $TCA->[232], $TCA->[235], $TCA->[236], $TCA->[237], $TCA->[238], $TCA->[222], $TCA->[239], $TCA->[222], $TCA->[240], $TCA->[241], $TCA->[218], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[246], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[221], $TCA->[250], $TCA->[250], $TCA->[218], $TCA->[220], $TCA->[251], $TCA->[252], $TCA->[253], $TCA->[254], $TCA->[218], $TCA->[218], $TCA->[171], $TCA->[255], $TCA->[169], $TCA->[256], $TCA->[257], $TCA->[258], $TCA->[259], $TCA->[172], $TCA->[260], $TCA->[261], $TCA->[259], $TCA->[262]], [$TCA->[263]]],
[undef, [$TCA->[211]], [$TCA->[210]], [$TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[197], $TCA->[215], $TCA->[212], $TCA->[197], $TCA->[197], $TCA->[197], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[197], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[213], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[216], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[198], $TCA->[199], $TCA->[197], $TCA->[163], $TCA->[212], $TCA->[212], $TCA->[197], $TCA->[212]], [$TCA->[76]], [$TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[223], $TCA->[224], $TCA->[224], $TCA->[220], $TCA->[225], $TCA->[222], $TCA->[226], $TCA->[200], $TCA->[200], $TCA->[200], $TCA->[230], $TCA->[222], $TCA->[220], $TCA->[223], $TCA->[231], $TCA->[232], $TCA->[233], $TCA->[234], $TCA->[232], $TCA->[235], $TCA->[236], $TCA->[237], $TCA->[238], $TCA->[222], $TCA->[239], $TCA->[222], $TCA->[240], $TCA->[241], $TCA->[218], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[246], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[221], $TCA->[250], $TCA->[250], $TCA->[218], $TCA->[220], $TCA->[251], $TCA->[252], $TCA->[253], $TCA->[254], $TCA->[218], $TCA->[218], $TCA->[171], $TCA->[255], $TCA->[169], $TCA->[256], $TCA->[257], $TCA->[200], $TCA->[201], $TCA->[172], $TCA->[260], $TCA->[261], $TCA->[202], $TCA->[262]], [$TCA->[203]]],
[undef, [$TCA->[205]], [$TCA->[204]], [$TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206]], [$TCA->[207]], [$TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208], $TCA->[208]], [$TCA->[209]]],
[undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[163], $TCA->[264], $TCA->[264], $TCA->[264], $TCA->[264]], [$TCA->[265]], [$TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[166], $TCA->[166], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[267], $TCA->[268], $TCA->[267], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[168], $TCA->[266], $TCA->[266], $TCA->[169], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[266], $TCA->[171], $TCA->[266], $TCA->[169], $TCA->[266], $TCA->[266], $TCA->[267], $TCA->[269], $TCA->[172], $TCA->[266], $TCA->[173], $TCA->[270], $TCA->[266]], [$TCA->[271]]],
[undef, [$TCA->[273]], [$TCA->[272]], [$TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274], $TCA->[274]], [$TCA->[275]], [$TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276]], [$TCA->[277]]],
[undef, [$TCA->[279]], [$TCA->[278]], [$TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[281], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280], $TCA->[280]], [$TCA->[282]], [$TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283], $TCA->[283]], [$TCA->[284]]]];
my $ResetIMByET = {  (BODY_EL) => IN_BODY_IM,
  (CAPTION_EL) => IN_CAPTION_IM,
  (COLGROUP_EL) => IN_COLUMN_GROUP_IM,
  (FRAMESET_EL) => IN_FRAMESET_IM,
  (TABLE_EL) => IN_TABLE_IM,
  (TBODY_EL) => IN_TABLE_BODY_IM,
  (TFOOT_EL) => IN_TABLE_BODY_IM,
  (THEAD_EL) => IN_TABLE_BODY_IM,
  (TR_EL) => IN_ROW_IM,};
my $ResetIMByETUnlessLast = {  (HEAD_EL) => IN_HEAD_IM,
  (TD_EL) => IN_CELL_IM,
  (TH_EL) => IN_CELL_IM,};

      sub reset_im () {
        my $last = 0;
        my $node_i = $#$OE;
        my $node = $OE->[$node_i];
        LOOP: {
          if ($node_i == 0) {
            $last = 1;
            $node = $CONTEXT if defined $CONTEXT;
          }

          if ($node->{et} == SELECT_EL) {
            SELECT: {
              last SELECT if $last;
              my $ancestor_i = $node_i;
              INNERLOOP: {
                if ($ancestor_i == 0) {
                  last SELECT;
                }
                $ancestor_i--;
                my $ancestor = $OE->[$ancestor_i];
                if ($ancestor->{et} & (TEM_ELS)) {
                  last SELECT;
                }
                if ($ancestor->{et} & (TAB_ELS)) {
                  $IM = IN_SELECT_IN_TABLE_IM;
                  return;
                }
                redo INNERLOOP;
              } # INNERLOOP
            } # SELECT
            $IM = IN_SELECT_IM;
            return;
          }

          $IM = $ResetIMByET->{$node->{et}};
          return if defined $IM;

          unless ($last) {
            $IM = $ResetIMByETUnlessLast->{$node->{et}};
            return if defined $IM;
          }

          if ($node->{et} & (TEM_ELS)) {
            $IM = $TEMPLATE_IMS->[-1];
            return;
          }
          if ($node->{et} & (HTM_ELS)) {
            if (not defined $HEAD_ELEMENT) {
              $IM = BEFORE_HEAD_IM;
              return;
            } else {
              $IM = AFTER_HEAD_IM;
              return;
            }
          }
          if ($last) {
            $IM = IN_BODY_IM;
            return;
          }
          $node_i--;
          $node = $OE->[$node_i];
          redo LOOP;
        } # LOOP
      } # reset_im
    

        sub aaa ($$;%) {
          my ($token, $tag_name, %args) = @_;
          my @popped;
          if ($OE->[-1]->{ns} == HTMLNS and
              $OE->[-1]->{local_name} eq $tag_name) {
            my $found;
            for (reverse @$AFE) {
              if ($_ eq $OE->[-1]) {
                $found = 1;
                last;
              }
            }
            unless ($found) {
              #push @popped,
              pop @$OE;
              ## $args{remove_from_afe_and_oe} - nop
              #push @$OP, ['popped', \@popped];
              return;
            }
          }

          my $outer_loop_counter = 0;
          OUTER_LOOP: {
            if ($outer_loop_counter >= 8) {
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            $outer_loop_counter++;
            my $formatting_element;
            my $formatting_element_afe_i;
            for (reverse 0..$#$AFE) {
              if (not ref $AFE->[$_]) {
                last;
              } elsif ($AFE->[$_]->{local_name} eq $tag_name) { # ->{ns} == HTMLNS
                $formatting_element = $AFE->[$_];
                $formatting_element_afe_i = $_;
                last;
              }
            }
            unless (defined $formatting_element) {
              ## The "in body" insertion mode, END_TAG_TOKEN, ELSE
              local $_ = $token;
              $ProcessIM->[IN_BODY_IM]->[END_TAG_TOKEN]->[0]->();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            my $beyond_scope;
            my $formatting_element_i;
            my $furthest_block;
            my $furthest_block_i;
            for (reverse 0..$#$OE) {
              if ($OE->[$_] eq $formatting_element) {
                $formatting_element_i = $_;
                last;
              } else {
                if ($OE->[$_]->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                  $beyond_scope = 1;
                }
                if ($OE->[$_]->{et} & (ADD_DIV_ELS | APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                  $furthest_block = $OE->[$_];
                  $furthest_block_i = $_;
                }
              }
            }
            unless (defined $formatting_element_i) {
              push @$Errors, {type => 'AAA:in afe but not in open elements',
                              value => $token->{tag_name},
                              level => 'm',
                              di => $token->{di}, index => $token->{index}};
              splice @$AFE, $formatting_element_afe_i, 1, ();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            if ($beyond_scope) {
              push @$Errors, {type => 'AAA:formatting element not in scope',
                              level => 'm', value => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
              if ($args{remove_from_afe_and_oe}) {
                splice @$AFE, $formatting_element_afe_i, 1, ();
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
              }
              push @$OP, ['popped', \@popped];
              return;
            }
            unless ($formatting_element eq $OE->[-1]) {
              push @$Errors, {type => 'AAA:formatting element not current',
                              level => 'm', value => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
            unless (defined $furthest_block) {
              #push @popped,
              splice @$OE, $formatting_element_i;
              splice @$AFE, $formatting_element_afe_i, 1, ();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }

        my $common_ancestor = $OE->[$formatting_element_i-1];
        my $bookmark = $formatting_element_afe_i;
        my $node = $furthest_block;
        my $node_i = $furthest_block_i;
        my $last_node = $furthest_block;
        my $inner_loop_counter = 0;
        INNER_LOOP: {
          $inner_loop_counter++;
          $node_i--;
          $node = $OE->[$node_i];
          last INNER_LOOP if $node eq $formatting_element;
          my $node_afe_i;
          for (reverse 0..$#$AFE) {
            if ($AFE->[$_] eq $node) {
              $node_afe_i = $_;
              last;
            }
          }
          if ($inner_loop_counter > 3 and defined $node_afe_i) {
            $formatting_element_afe_i-- if $node_afe_i < $formatting_element_afe_i;
            $bookmark-- if $node_afe_i < $bookmark;
            splice @$AFE, $node_afe_i, 1, ();
            undef $node_afe_i;
          }
          if (not defined $node_afe_i) {
            $furthest_block_i-- if $node_i < $furthest_block_i;
            push @popped, splice @$OE, $node_i, 1, ();
            redo INNER_LOOP;
          }

          ## Create an HTML element
          $node = {id => $NEXT_ID++,
                   token => $node->{token},
                   di => $node->{token}->{di}, index => $node->{token}->{index},
                   ns => HTMLNS,
                   local_name => $node->{token}->{tag_name},
                   attr_list => $node->{token}->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$node->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
          $node->{aet} = $node->{et};
          $AFE->[$node_afe_i] = $node;
          $OE->[$node_i] = $node;
          ## As $node seems never to be a form-assosicated element,
          ## and it will be appended (not inserted) to another node
          ## later anyway, we don't have to associate the form owner
          ## here.  Note that /intended parent/ is $common_ancestor.

          if ($last_node eq $furthest_block) {
            $bookmark = $node_afe_i + 1;
          }

          push @$OP,
              ['create', $node],
              ['append', $last_node->{id} => $node->{id}];
          $last_node = $node;
          redo INNER_LOOP;
        } # INNER_LOOP

            
      push @$OP, ['append', $last_node->{id} => $common_ancestor->{id}];
    

            ## Create an HTML element
            my $new_element = {id => $NEXT_ID++,
                               token => $formatting_element->{token},
                               di => $formatting_element->{token}->{di},
                               index => $formatting_element->{token}->{index},
                               ns => HTMLNS,
                               local_name => $formatting_element->{token}->{tag_name},
                               attr_list => $formatting_element->{token}->{attr_list},
                               et => $Element2Type->[HTMLNS]->{$formatting_element->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $new_element->{aet} = $new_element->{et};
            push @$OP,
                ['create', $new_element],
                ['move-children', $furthest_block->{id} => $new_element->{id}],
                ['append', $new_element->{id} => $furthest_block->{id}];
            ## As $formatting_element is always a formatting element,
            ## it can't be a form-associated element.  Note that
            ## /intended parent/ is $furthest_block.

            if ($bookmark <= $formatting_element_afe_i) {
              splice @$AFE, $formatting_element_afe_i, 1, ();
              splice @$AFE, $bookmark, 0, $new_element;
            } else {
              splice @$AFE, $bookmark, 0, $new_element;
              splice @$AFE, $formatting_element_afe_i, 1, ();
              $bookmark--;
            }

            if ($formatting_element_i < $furthest_block_i) {
              splice @$OE, $furthest_block_i + 1, 0, ($new_element);
              #push @popped,
              splice @$OE, $formatting_element_i, 1, ();
              $furthest_block_i--;
            } else {
              #push @popped,
              splice @$OE, $formatting_element_i, 1, ();
              splice @$OE, $furthest_block_i + 1, 0, ($new_element);
            }

            redo OUTER_LOOP;
          } # OUTER_LOOP
        }
      

        sub aaa_foster ($$;%) {
          my ($token, $tag_name, %args) = @_;
          my @popped;
          if ($OE->[-1]->{ns} == HTMLNS and
              $OE->[-1]->{local_name} eq $tag_name) {
            my $found;
            for (reverse @$AFE) {
              if ($_ eq $OE->[-1]) {
                $found = 1;
                last;
              }
            }
            unless ($found) {
              #push @popped,
              pop @$OE;
              ## $args{remove_from_afe_and_oe} - nop
              #push @$OP, ['popped', \@popped];
              return;
            }
          }

          my $outer_loop_counter = 0;
          OUTER_LOOP: {
            if ($outer_loop_counter >= 8) {
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            $outer_loop_counter++;
            my $formatting_element;
            my $formatting_element_afe_i;
            for (reverse 0..$#$AFE) {
              if (not ref $AFE->[$_]) {
                last;
              } elsif ($AFE->[$_]->{local_name} eq $tag_name) { # ->{ns} == HTMLNS
                $formatting_element = $AFE->[$_];
                $formatting_element_afe_i = $_;
                last;
              }
            }
            unless (defined $formatting_element) {
              ## The "in body" insertion mode, END_TAG_TOKEN, ELSE
              local $_ = $token;
              $ProcessIM->[IN_BODY_IM]->[END_TAG_TOKEN]->[0]->();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            my $beyond_scope;
            my $formatting_element_i;
            my $furthest_block;
            my $furthest_block_i;
            for (reverse 0..$#$OE) {
              if ($OE->[$_] eq $formatting_element) {
                $formatting_element_i = $_;
                last;
              } else {
                if ($OE->[$_]->{et} & (APP_ELS | CAP_ELS | HTM_ELS | MAR_M_ANN_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                  $beyond_scope = 1;
                }
                if ($OE->[$_]->{et} & (ADD_DIV_ELS | APP_ELS | AAABBBBBCCDDDEFFFFFFHHHHILLMMMNNNNPPPSSSSTTW_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | MAR_M_ANN_ELS | MEN_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                  $furthest_block = $OE->[$_];
                  $furthest_block_i = $_;
                }
              }
            }
            unless (defined $formatting_element_i) {
              push @$Errors, {type => 'AAA:in afe but not in open elements',
                              value => $token->{tag_name},
                              level => 'm',
                              di => $token->{di}, index => $token->{index}};
              splice @$AFE, $formatting_element_afe_i, 1, ();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }
            if ($beyond_scope) {
              push @$Errors, {type => 'AAA:formatting element not in scope',
                              level => 'm', value => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
              if ($args{remove_from_afe_and_oe}) {
                splice @$AFE, $formatting_element_afe_i, 1, ();
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
              }
              push @$OP, ['popped', \@popped];
              return;
            }
            unless ($formatting_element eq $OE->[-1]) {
              push @$Errors, {type => 'AAA:formatting element not current',
                              level => 'm', value => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
            unless (defined $furthest_block) {
              #push @popped,
              splice @$OE, $formatting_element_i;
              splice @$AFE, $formatting_element_afe_i, 1, ();
              ## $args{remove_from_afe_and_oe} - nop
              push @$OP, ['popped', \@popped];
              return;
            }

        my $common_ancestor = $OE->[$formatting_element_i-1];
        my $bookmark = $formatting_element_afe_i;
        my $node = $furthest_block;
        my $node_i = $furthest_block_i;
        my $last_node = $furthest_block;
        my $inner_loop_counter = 0;
        INNER_LOOP: {
          $inner_loop_counter++;
          $node_i--;
          $node = $OE->[$node_i];
          last INNER_LOOP if $node eq $formatting_element;
          my $node_afe_i;
          for (reverse 0..$#$AFE) {
            if ($AFE->[$_] eq $node) {
              $node_afe_i = $_;
              last;
            }
          }
          if ($inner_loop_counter > 3 and defined $node_afe_i) {
            $formatting_element_afe_i-- if $node_afe_i < $formatting_element_afe_i;
            $bookmark-- if $node_afe_i < $bookmark;
            splice @$AFE, $node_afe_i, 1, ();
            undef $node_afe_i;
          }
          if (not defined $node_afe_i) {
            $furthest_block_i-- if $node_i < $furthest_block_i;
            push @popped, splice @$OE, $node_i, 1, ();
            redo INNER_LOOP;
          }

          ## Create an HTML element
          $node = {id => $NEXT_ID++,
                   token => $node->{token},
                   di => $node->{token}->{di}, index => $node->{token}->{index},
                   ns => HTMLNS,
                   local_name => $node->{token}->{tag_name},
                   attr_list => $node->{token}->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$node->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
          $node->{aet} = $node->{et};
          $AFE->[$node_afe_i] = $node;
          $OE->[$node_i] = $node;
          ## As $node seems never to be a form-assosicated element,
          ## and it will be appended (not inserted) to another node
          ## later anyway, we don't have to associate the form owner
          ## here.  Note that /intended parent/ is $common_ancestor.

          if ($last_node eq $furthest_block) {
            $bookmark = $node_afe_i + 1;
          }

          push @$OP,
              ['create', $node],
              ['append', $last_node->{id} => $node->{id}];
          $last_node = $node;
          redo INNER_LOOP;
        } # INNER_LOOP

            
      if ($common_ancestor->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['append-foster', $last_node->{id} => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['append', $last_node->{id} => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['append', $last_node->{id} => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['append', $last_node->{id} => $common_ancestor->{id}];
      }
    

            ## Create an HTML element
            my $new_element = {id => $NEXT_ID++,
                               token => $formatting_element->{token},
                               di => $formatting_element->{token}->{di},
                               index => $formatting_element->{token}->{index},
                               ns => HTMLNS,
                               local_name => $formatting_element->{token}->{tag_name},
                               attr_list => $formatting_element->{token}->{attr_list},
                               et => $Element2Type->[HTMLNS]->{$formatting_element->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $new_element->{aet} = $new_element->{et};
            push @$OP,
                ['create', $new_element],
                ['move-children', $furthest_block->{id} => $new_element->{id}],
                ['append', $new_element->{id} => $furthest_block->{id}];
            ## As $formatting_element is always a formatting element,
            ## it can't be a form-associated element.  Note that
            ## /intended parent/ is $furthest_block.

            if ($bookmark <= $formatting_element_afe_i) {
              splice @$AFE, $formatting_element_afe_i, 1, ();
              splice @$AFE, $bookmark, 0, $new_element;
            } else {
              splice @$AFE, $bookmark, 0, $new_element;
              splice @$AFE, $formatting_element_afe_i, 1, ();
              $bookmark--;
            }

            if ($formatting_element_i < $furthest_block_i) {
              splice @$OE, $furthest_block_i + 1, 0, ($new_element);
              #push @popped,
              splice @$OE, $formatting_element_i, 1, ();
              $furthest_block_i--;
            } else {
              #push @popped,
              splice @$OE, $formatting_element_i, 1, ();
              splice @$OE, $furthest_block_i + 1, 0, ($new_element);
            }

            redo OUTER_LOOP;
          } # OUTER_LOOP
        }
      

        sub reconstruct_afe () {
          #return unless @$AFE;
          #return if not ref $AFE->[-1];
          for (reverse @$OE) {
            return if $_ eq $AFE->[-1];
          }
          my $entry_i = $#$AFE;
          my $entry = $AFE->[$entry_i];
          E: {
            last E if $entry_i == 0;
            $entry_i--;
            $entry = $AFE->[$entry_i];
            ($entry_i++, last E) if not ref $entry;
            for (reverse @$OE) {
              ($entry_i++, last E) if $_ eq $entry;
            }
            redo E;
          } # E

          for my $entry_i ($entry_i..$#$AFE) {
            $entry = $AFE->[$entry_i];

            ## Insert an HTML element
            my $node = {id => $NEXT_ID++,
                        token => $entry->{token},
                        di => $entry->{token}->{di},
                        index => $entry->{token}->{index},
                        ns => HTMLNS,
                        local_name => $entry->{token}->{tag_name},
                        attr_list => $entry->{token}->{attr_list},
                        et => $Element2Type->[HTMLNS]->{$entry->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $node->{aet} = $node->{et};
            
      push @$OP, ['insert', $node => $OE->[-1]->{id}];
    
            push @$OE, $node;

            $AFE->[$entry_i] = $node;
          }
        }
      

        sub reconstruct_afe_foster () {
          #return unless @$AFE;
          #return if not ref $AFE->[-1];
          for (reverse @$OE) {
            return if $_ eq $AFE->[-1];
          }
          my $entry_i = $#$AFE;
          my $entry = $AFE->[$entry_i];
          E: {
            last E if $entry_i == 0;
            $entry_i--;
            $entry = $AFE->[$entry_i];
            ($entry_i++, last E) if not ref $entry;
            for (reverse @$OE) {
              ($entry_i++, last E) if $_ eq $entry;
            }
            redo E;
          } # E

          for my $entry_i ($entry_i..$#$AFE) {
            $entry = $AFE->[$entry_i];

            ## Insert an HTML element
            my $node = {id => $NEXT_ID++,
                        token => $entry->{token},
                        di => $entry->{token}->{di},
                        index => $entry->{token}->{index},
                        ns => HTMLNS,
                        local_name => $entry->{token}->{tag_name},
                        attr_list => $entry->{token}->{attr_list},
                        et => $Element2Type->[HTMLNS]->{$entry->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $node->{aet} = $node->{et};
            
      if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
        FOSTER: {
          for my $i (reverse 1..$#$OE) {
            if ($OE->[$i]->{et} & (TAB_ELS)) { # table
              push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
              last FOSTER;
            } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
              push @$OP, ['insert', $node => $OE->[$i]->{id}];
              last FOSTER;
            }
          }
          push @$OP, ['insert', $node => $OE->[0]->{id}];
        } # FOSTER
      } else {
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      }
    
            push @$OE, $node;

            $AFE->[$entry_i] = $node;
          }
        }
      my $StateByElementName = {'iframe' => RAWTEXT_STATE, 'noembed' => RAWTEXT_STATE, 'noframes' => RAWTEXT_STATE, 'plaintext' => PLAINTEXT_STATE, 'script' => SCRIPT_DATA_STATE, 'style' => RAWTEXT_STATE, 'textarea' => RCDATA_STATE, 'title' => RCDATA_STATE, 'xmp' => RAWTEXT_STATE, };

    ## ------ Input byte stream ------
    

## ------ Character encoding processing ------

sub locale_tag ($;$) {
  if (@_ > 1) {
    $_[0]->{locale_tag} = $_[1];
    $_[0]->{locale_tag} =~ tr/A-Z/a-z/ if defined $_[0]->{locale_tag};
  }
  return $_[0]->{locale_tag};
} # locale_tag

sub known_definite_encoding ($;$) {
  if (@_ > 1) {
    $_[0]->{known_definite_encoding} = $_[1];
  }
  return $_[0]->{known_definite_encoding};
} # known_definite_encoding

## Encoding sniffing algorithm
## <http://www.whatwg.org/specs/web-apps/current-work/#determining-the-character-encoding>.
sub _encoding_sniffing ($;%) {
  my ($self, %args) = @_;

  ## One of followings:
  ##   - Step 1. User-specified encoding
  ##   - The new character encoding by change the encoding
  ##     <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>
  ##     step 5. Encoding from <meta charset>
  ##   - A known definite encoding
  my $kde = $self->known_definite_encoding;
  if (defined $kde) {
    ## If specified, it must be an encoding label from the Encoding
    ## Standard.
    my $name = Web::Encoding::encoding_label_to_name $kde;
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 1; # certain
      return;
    }
  }

  return if $args{no_body_data_yet};
  ## $args{no_body_data_yet} flag must be set to true if the body of
  ## the resource is not available to the parser such that
  ## $args{read_head} callback ought not be invoked yet.

  ## Step 2. Wait 500ms or 1024 bytes, whichever came first (See
  ## Web::HTML::Parser for how and when to use this callback).
  my $head = $args{read_head} ? $args{read_head}->() : undef;
  ## $args{read_head} must be a callback which, when invoked, returns
  ## a byte string used to sniff the character encoding of the input
  ## stream.  As described in the HTML Standard, it should be at most
  ## 1024 bytes.  The callback should not invoke sync I/O.  This
  ## method should be invoked with $args{no_body_data_yet} flag unset
  ## only after 500ms has past or 1024 bytes has been received.  The
  ## callback should not invoke any exception.

  ## Step 3. BOM
  ## XXX Now this step is part of "decode" in the specs
  if (defined $head) {
    if ($$head =~ /^\xFE\xFF/) {
      $self->{input_encoding} = 'utf-16be';
      $Confident = 1; # certain
      return;
    } elsif ($$head =~ /^\xFF\xFE/) {
      $self->{input_encoding} = 'utf-16le';
      $Confident = 1; # certain
      return;
    } elsif ($$head =~ /^\xEF\xBB\xBF/) {
      $self->{input_encoding} = 'utf-8';
      $Confident = 1; # certain
      return;
    }
  }

  ## Step 4. Transport-layer encoding
  if ($args{transport_encoding_name}) {
    ## $args{transport_encoding_name} must be specified iff the
    ## underlying protocol provides the character encoding for the
    ## input stream.  For HTTP, the |charset=""| parameter in the
    ## |Content-Type:| header specifies the character encoding.  The
    ## value is interpreted as an encoding name or alias defined in
    ## the Encoding Standard.  (Invalid encoding name will be
    ## ignored.)
    my $name = Web::Encoding::encoding_label_to_name $args{transport_encoding_name};
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 1; # certain
      return;
    }
  }

  ## Step 5. <meta charset>
  if (defined $head) {
    my $name = $self->_prescan_byte_stream ($$head);
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 6. Parent browsing context
  if ($args{parent_document}) {
    ## $args{parent_document}, if specified, must be the |Document|
    ## through which the new (to be parsed) document is nested, or the
    ## active document of the parent browsing context of the new
    ## document.

    # XXX
    # if $args{parent_document}->origin equals $self->document->origin and
    #    $args{parent_document}->charset is ASCII compatible {
    #   $self->{input_encoding} = $args{parent_document}->charset;
    #   $Confident = 0; # tentative
    #   return;
    # }
  }

  ## Step 7. History
  if ($args{get_history_encoding_name}) {
    ## EXPERIMENTAL: $args{get_history_encoding_name}, if specified,
    ## must be a callback which returns the canonical character
    ## encoding name for the input stream, guessed by e.g. last visit
    ## to this page.
    # XXX how to handle async access to history DB?
    my $name = Web::Encoding::encoding_label_to_name $args{get_history_encoding_name}->();
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. UniversalCharDet
  if (defined $head) {
    require Web::Encoding::UnivCharDet;
    my $det = Web::Encoding::UnivCharDet->new;
    # XXX locale-dependent configuration
    my $name = Web::Encoding::encoding_label_to_name $det->detect_byte_string ($$head);
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. Locale-dependent default
  my $locale = $self->locale_tag;
  if ($locale) {
    my $name = Web::Encoding::encoding_label_to_name (
        Web::Encoding::locale_default_encoding_name $locale ||
        Web::Encoding::locale_default_encoding_name [split /-/, $locale, 2]->[0]
    );
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. Default of default
  $self->{input_encoding} = Web::Encoding::encoding_label_to_name 'windows-1252';
  $Confident = 0; # tentative
  return;

  # XXX expose sniffing info for validator
} # _encoding_sniffing

# prescan a byte stream to determine its encoding
# <http://www.whatwg.org/specs/web-apps/current-work/#prescan-a-byte-stream-to-determine-its-encoding>
sub _prescan_byte_stream ($$) {
  # 1.
  (pos $_[1]) = 0;

  # 2.
  LOOP: {
    $_[1] =~ /\G<!--+>/gc;
    $_[1] =~ /\G<!--.*?-->/gcs;
    if ($_[1] =~ /\G<[Mm][Ee][Tt][Aa](?=[\x09\x0A\x0C\x0D\x20\x2F])/gc) {
      # 1.
      #

      # 2.-5.
      my $attr_list = {};
      my $got_pragma = 0;
      my $need_pragma = undef;
      my $charset;

      # 6.
      ATTRS: {
        my $attr = $_[0]->_get_attr ($_[1]) or last ATTRS;

        # 7.
        redo ATTRS if $attr_list->{$attr->{name}};
        
        # 8.
        $attr_list->{$attr->{name}} = $attr;

        # 9.
        if ($attr->{name} eq 'http-equiv') {
          $got_pragma = 1 if $attr->{value} eq 'content-type';
        } elsif ($attr->{name} eq 'content') {
          # algorithm for extracting a character encoding from a
          # |meta| element
          # <http://www.whatwg.org/specs/web-apps/current-work/#algorithm-for-extracting-a-character-encoding-from-a-meta-element>
          if (not defined $charset and
              $attr->{value} =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                                 [\x09\x0A\x0C\x0D\x20]*=
                                 [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                                 ([^"'\x09\x0A\x0C\x0D\x20]
                                  [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
            $charset = Web::Encoding::encoding_label_to_name
                (defined $1 ? $1 : defined $2 ? $2 : $3);
            $need_pragma = 1;
          }
        } elsif ($attr->{name} eq 'charset') {
          $charset = Web::Encoding::encoding_label_to_name $attr->{value};
          $need_pragma = 0;
        }

        # 10.
        return undef if pos $_[1] >= length $_[1];
        redo ATTRS;
      } # ATTRS

      # 11. Processing, 12.
      if (not defined $need_pragma or
          ($need_pragma and not $got_pragma)) {
        #
      } elsif (defined $charset) {
        # 13.-14.
        $charset = Web::Encoding::fixup_html_meta_encoding_name $charset;

        # 15.-16.
        return $charset if defined $charset;
      }
    } elsif ($_[1] =~ m{\G</?[A-Za-z][^\x09\x0A\x0C\x0D\x20>]*}gc) {
      {
        $_[0]->_get_attr ($_[1]) and redo;
      }
    } elsif ($_[1] =~ m{\G<[!/?][^>]*}gc) {
      #
    }

    # 3. Next byte
    $_[1] =~ /\G[^<]+/gc || $_[1] =~ /\G</gc;
    return undef if pos $_[1] >= length $_[1];
    redo LOOP;
  } # LOOP
} # _prescan_byte_stream

# get an attribute
# <http://www.whatwg.org/specs/web-apps/current-work/#concept-get-attributes-when-sniffing>
sub _get_attr ($$) {
  # 1.
  $_[1] =~ /\G[\x09\x0A\x0C\x0D\x20\x2F]+/gc;

  # 2.
  if ($_[1] =~ /\G>/gc) {
    pos ($_[1])--;
    return undef;
  }
  
  # 3.
  my $attr = {name => '', value => ''};

  # 4.-5.
  if ($_[1] =~ m{\G([^\x09\x0A\x0C\x0D\x20/>][^\x09\x0A\x0C\x0D\x20/>=]*)}gc) {
    $attr->{name} .= $1;
    $attr->{name} =~ tr/A-Z/a-z/;
  }
  return undef if $_[1] =~ m{\G\z}gc;
  return $attr if $_[1] =~ m{\G(?=[/>])}gc;

  # 6.
  $_[1] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;

  # 7.-8.
  return $attr unless $_[1] =~ m{\G=}gc;

  # 9.
  $_[1] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;

  # 10.-12.
  if ($_[1] =~ m{\G\x22([^\x22]*)\x22}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  } elsif ($_[1] =~ m{\G\x27([^\x27]*)\x27}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  } elsif ($_[1] =~ m{\G([^\x09\x0A\x0C\x0D\x20>]+)}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  }
  return undef if $_[1] =~ m{\G\z}gc;
  return $attr;
} # _get_attr

sub _change_the_encoding ($$$) {
  my ($self, $name, $attr) = @_;

  ## "meta" start tag
  ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inhead>.

  ## "meta". Confidence is /tentative/
  #return undef if $Confident; # certain or irrelevant

  $name = Web::Encoding::encoding_label_to_name $name;
  unless (defined $name) {
    ## "meta". Supported encoding
    return undef;
  }

  ## "meta". ASCII-compatible or UTF-16
  ## All encodings in Encoding Standard are ASCII-compatible or UTF-16.

  ## Change the encoding
  ## <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>.

  ## Step 1. UTF-16
  if (Web::Encoding::is_utf16_encoding_key $self->{input_encoding}) {
    $Confident = 1; # certain
    return undef;
  }

  ## Step 2.-3.
  $name = Web::Encoding::fixup_html_meta_encoding_name $name;
  
  ## Step 4. Same
  if ($name eq $self->{input_encoding}) {
    $Confident = 1; # certain
    return undef;
  }

  push @$Errors, {type => 'charset label detected',
                  text => $self->{input_encoding},
                  value => $name,
                  level => 'i',
                  di => $attr->{di}, index => $attr->{index}};

  ## Step 5. Change the encoding on the fly
  ## Not implemented.

  ## Step 6. Navigate with replace.
  return $name; # change!

#XXX move this to somewhere else (when callback can't handle restart)
  ## Step 6. If can't restart
  $Confident = 1; # certain
  return undef;
} # _change_the_encoding

    sub di_data_set ($;$) {
      if (@_ > 1) {
        $_[0]->{di_data_set} = $_[1];
      }
      return $_[0]->{di_data_set} ||= [];
    } # di_data_set

    sub di ($;$) {
      if (@_ > 1) {
        $_[0]->{di} = $_[1];
      }
      return $_[0]->{di}; # or undef
    } # di

  
    ## ------ Tokenizer ------
    
    my $StateActions = [];
    $StateActions->[CDATA_SECTION_BRACKET_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_END_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
        
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - 1};
        

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_END_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - 2};
        

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_STATE] = sub {
if ($Input =~ /\G([^\\]]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_BRACKET_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = CDATA_SECTION_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_BRACKET_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\>ABCDEFGHJKNQRVWZILMOPSTUXY\ ]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<name>} .= chr ((ord $1) + 32);
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} .= q@�@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\ \>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\\'\ \>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = q@�@;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = chr ((ord $1) + 32);
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\ \>]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\\'\ \>]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@�@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PLAINTEXT_STATE] = sub {
if ($Input =~ /\G([^\\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = PLAINTEXT_STATE_CR;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PLAINTEXT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = PLAINTEXT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = PLAINTEXT_STATE_CR;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = PLAINTEXT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = PLAINTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = PLAINTEXT_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RAWTEXT_END_TAG_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RAWTEXT_STATE_CR;
} elsif ($Input =~ /\G([\/])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = SELF_CLOSING_START_TAG_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $LastStartTagName and
            $Token->{tag_name} eq $LastStartTagName) {
          $State = DATA_STATE;
          $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
          push @$Tokens, $Token;
          return 1;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Token->{q<tag_name>} .= $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RAWTEXT_END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RAWTEXT_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = RAWTEXT_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = RAWTEXT_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RAWTEXT_LESS_THAN_SIGN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RAWTEXT_STATE_CR;
} elsif ($Input =~ /\G([\/])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = RAWTEXT_END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RAWTEXT_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RAWTEXT_STATE] = sub {
if ($Input =~ /\G([^\\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RAWTEXT_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = RAWTEXT_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RAWTEXT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = RAWTEXT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RAWTEXT_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = RAWTEXT_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = RAWTEXT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = RAWTEXT_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = RAWTEXT_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_END_TAG_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = SELF_CLOSING_START_TAG_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $LastStartTagName and
            $Token->{tag_name} eq $LastStartTagName) {
          $State = DATA_STATE;
          $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
          push @$Tokens, $Token;
          return 1;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Token->{q<tag_name>} .= $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = RCDATA_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = RCDATA_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_LESS_THAN_SIGN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = RCDATA_END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE] = sub {
if ($Input =~ /\G([^\\&\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
return 1 if $return;
} elsif ($Input =~ /\G(.)/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} else {
if ($EOF) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([X])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE___CHARREF_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = RCDATA_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[RCDATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = RCDATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_S;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_S;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_P] = sub {
if ($Input =~ /\G([U])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PU;
} elsif ($Input =~ /\G([u])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PU;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PU] = sub {
if ($Input =~ /\G([B])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUB;
} elsif ($Input =~ /\G([b])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUB;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUB] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBL;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUBL] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUBLI] = sub {
if ($Input =~ /\G([C])/gcs) {
$State = A_DOCTYPE_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G([c])/gcs) {
$State = A_DOCTYPE_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_S] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SY;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SY] = sub {
if ($Input =~ /\G([S])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYS;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYS;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYS] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYST;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYST;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYST] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYSTE] = sub {
if ($Input =~ /\G([M])/gcs) {
$State = A_DOCTYPE_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G([m])/gcs) {
$State = A_DOCTYPE_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_PUBLIC_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_SYSTEM_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {
$State = B_ATTR_VALUE_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = q@�@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G(.)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTR_VALUE__QUOTED__STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = q@�@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\/\=\>ABCDEFGHJKNQRVWZILMOPSTUXY\ \"\'\<]+)/gcs) {
$Attr->{q<name>} .= $1;

} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*([^\ \	\
\\\ \"\&\'\<\=\>\`])([^\ \	\
\\\ \"\&\'\<\=\>\`]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*([^\ \	\
\\\ \"\&\'\<\=\>\`])([^\ \	\
\\\ \"\&\'\<\=\>\`]*)\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*([^\ \	\
\\\ \"\&\'\<\=\>\`])([^\ \	\
\\\ \"\&\'\<\=\>\`]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*([^\ \	\
\\\ \"\'\/\<\=\>A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = A_ATTR_NAME_STATE;
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \\&\']*)\'[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\=[\	\
\\\ ]*([^\ \	\
\\\ \"\&\'\<\=\>\`])([^\ \	\
\\\ \"\&\'\<\=\>\`]*)\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*([A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = A_ATTR_NAME_STATE;
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \\&\']*)\'\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \\&\']*)\'\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \\&\']*)\'[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \\&\']*)\'\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \\&\']*)\'\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \\"\&]*)\"\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = A_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = B_ATTR_VALUE_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Attr->{q<name>} .= chr ((ord $1) + 32);
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= q@�@;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} else {
if ($EOF) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\&\ ]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G(.)/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([X])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE] = sub {
if ($Input =~ /\G([^\\&\'\ ]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G(.)/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([X])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\>\ \"\'\<\=\`]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
return 1 if $return;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G(.)/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([X])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\"])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\'])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\"])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\'])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = chr ((ord $1) + 32);
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = q@�@;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([^\ \	\
\\\ \"\'\/\<\=\>A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
} elsif ($Input =~ /\G([A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
} elsif ($Input =~ /\G\/\>/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\>/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = q@�@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTR_VALUE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@�@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_DOCTYPE_STATE] = sub {
if ($Input =~ /\G([^\>]+)/gcs) {

} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_COMMENT_STATE] = sub {
if ($Input =~ /\G([^\ \\>]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CHARREF_IN_RCDATA_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = RCDATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_RCDATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = RCDATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = RCDATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CHARREF_IN_DATA_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_BANG_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--!�@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-�@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--�@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = COMMENT_END_BANG_STATE;
} elsif ($Input =~ /\G([\-])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_START_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-�@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_START_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_START_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_STATE] = sub {
if ($Input =~ /\G([^\\-\ ]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = COMMENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE] = sub {
if ($Input =~ /\G([^\\&\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## 
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G(.)/gcs) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} else {
if ($EOF) {

          my $return;
          REF: {
            ## 

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## <HTML>
                  push @$Errors, {type => 'no refc',
                                  level => 'm',
                                  di => $DI,
                                  index => $TempIndex + $_};
                  ## </HTML>

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## 

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## 
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([X])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DATA_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare etago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[q@�@, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare etago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'empty end tag', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare etago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE] = sub {
if ($Input =~ /\G([\-])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;
} elsif ($Input =~ /\G([D])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE_D;
} elsif ($Input =~ /\G([\[])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__5B;
} elsif ($Input =~ /\G([d])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE_D;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[q@�@, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__] = sub {
if ($Input =~ /\G([\-])/gcs) {

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_D] = sub {
if ($Input =~ /\G([O])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DO;
} elsif ($Input =~ /\G([o])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DO;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DO] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOC;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOC;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOC] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCT] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTY;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCTY] = sub {
if ($Input =~ /\G([P])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTYP;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTYP;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCTYP] = sub {
if ($Input =~ /\G([E])/gcs) {
$State = DOCTYPE_STATE;
} elsif ($Input =~ /\G([e])/gcs) {
$State = DOCTYPE_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5B] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BC;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BC] = sub {
if ($Input =~ /\G([D])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCD;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCD] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDA;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDA] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDAT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDAT] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDATA;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDATA] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@�@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\[])/gcs) {

          if (not defined $InForeign) {
            pos ($Input) -= length $1;
            return 1;
          } else {
            if ($InForeign) {
              $State = CDATA_SECTION_STATE;
              return 0;
            }
          }
        

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\>])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= chr ((ord $1) + 32);

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\
])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\>])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
$Temp .= chr ((ord $1) + 32);

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
$Temp .= $1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Temp .= chr ((ord $1) + 32);

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Temp .= $1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\
])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;

        if ($Temp eq 'script') {
          $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        } else {
          $State = SCRIPT_DATA_ESCAPED_STATE;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
$Temp .= chr ((ord $1) + 32);

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
$Temp .= $1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\>])/gcs) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@>@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@/@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE] = sub {
if ($Input =~ /\G([^\\-\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_END_TAG_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\/])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = SELF_CLOSING_START_TAG_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $LastStartTagName and
            $Token->{tag_name} eq $LastStartTagName) {
          $State = DATA_STATE;
          $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
          push @$Tokens, $Token;
          return 1;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Token->{q<tag_name>} .= $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = SCRIPT_DATA_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = SCRIPT_DATA_END_TAG_NAME_STATE;
$Token->{q<tag_name>} = $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPE_START_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPE_START_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPE_START_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@>@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = B_ATTR_NAME_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {

          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = SELF_CLOSING_START_TAG_STATE;
            return 1;
          }
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $LastStartTagName and
            $Token->{tag_name} eq $LastStartTagName) {
          $State = DATA_STATE;
          $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
          push @$Tokens, $Token;
          return 1;
        }
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
$Token->{q<tag_name>} .= $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
        

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
$Temp .= $1;
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
$Token->{q<tag_name>} .= $1;
$Temp .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@</@,
                          di => $DI, index => $AnchoredIndex};
        

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\/])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
$Temp .= chr ((ord $1) + 32);

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
$Temp .= $1;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_STATE] = sub {
if ($Input =~ /\G([^\\-\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_ESCAPED_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_ESCAPED_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = SCRIPT_DATA_ESCAPED_DASH_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@-@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_ESCAPED_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_LESS_THAN_SIGN_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {
$State = SCRIPT_DATA_ESCAPE_START_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<!@,
                          di => $DI, index => $AnchoredIndex};
        
} elsif ($Input =~ /\G([\/])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = SCRIPT_DATA_END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_STATE] = sub {
if ($Input =~ /\G([^\\<\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SCRIPT_DATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = SCRIPT_DATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = SCRIPT_DATA_STATE_CR;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = SCRIPT_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@�@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = SCRIPT_DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SELF_CLOSING_START_TAG_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = q@�@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\/])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = chr ((ord $1) + 32);
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TAG_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\/\>ABCDEFGHJKNQRVWZILMOPSTUXY\ ]+)/gcs) {
$Token->{q<tag_name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
$Token->{q<tag_name>} .= chr ((ord $1) + 32);
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<tag_name>} .= q@�@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TAG_OPEN_STATE] = sub {
if ($Input =~ /\G\!(\-)\-\-([^\ \\-\>])([^\ \\-]*)\-([^\ \\-])([^\ \\-]*)/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = COMMENT_END_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
} elsif ($Input =~ /\G\/([A-Z])([^\ \	\
\\\ \/\>A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\/([a-z])([^\ \	\
\\\ \/\>A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\!(\-)\-([^\ \\-\>])([^\ \\-]*)\-([^\ \\-])([^\ \\-]*)/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = COMMENT_END_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
} elsif ($Input =~ /\G([a-z])([^\ \	\
\\\ \/\>A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([A-Z])([^\ \	\
\\\ \/\>A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\>])([^\ \\-]*)\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G\!(\-)\-([^\ \\-\>])([^\ \\-]*)\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G\/([a-z])([^\ \	\
\\\ \/\>A-Z]*)\/\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\/([A-Z])([^\ \	\
\\\ \/\>A-Z]*)\/\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([a-z])([^\ \	\
\\\ \/\>A-Z]*)\/\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\/([a-z])([^\ \	\
\\\ \/\>A-Z]*)\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([A-Z])([^\ \	\
\\\ \/\>A-Z]*)\/\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\/([A-Z])([^\ \	\
\\\ \/\>A-Z]*)\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([a-z])([^\ \	\
\\\ \/\>A-Z]*)\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G([A-Z])([^\ \	\
\\\ \/\>A-Z]*)\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
$Token->{q<tag_name>} .= $2;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma><HTML>
            undef $InForeign;
            ## </HTML></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## 
          }
        
} elsif ($Input =~ /\G\!(\-)\-\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\!])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = chr ((ord $1) + 32);
} elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = TAG_NAME_STATE;
$Token->{q<tag_name>} = $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, 
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};

    sub _tokenize ($) {
      TOKENIZER: while (1) {
        my $code = $StateActions->[$State]
            or die "Unknown state |$State|";
        &$code and last TOKENIZER;
      } # TOKENIZER
    } # _tokenize
  
    ## ------ Tree constructor ------
    
    sub _construct_tree ($$) {
      my $self = shift;

      for my $token (@$Tokens) {
        local $_ = $token;
        if ((not @$OE) or 
($OE->[-1]->{aet} & (HTML_NS_ELS)) or 
(($OE->[-1]->{aet} & (M_MI_M_MN_M_MO_M_MS_M_MTE_ELS)) and 
($token->{type} == START_TAG_TOKEN and not ($token->{tn} == TAG_NAME_MALIGNMARK_MGLYPH))) or 
(($OE->[-1]->{aet} & (M_MI_M_MN_M_MO_M_MS_M_MTE_ELS)) and 
($token->{type} == 6)) or 
(($OE->[-1]->{aet} & (M_ANN_ELS)) and 
($token->{type} == START_TAG_TOKEN and $token->{tn} == TAG_NAME_SVG)) or 
(($OE->[-1]->{aet} & (M_ANN_M_ANN_ELS | S_DES_S_FOR_S_TIT_ELS)) and 
($token->{type} == 5)) or 
(($OE->[-1]->{aet} & (M_ANN_M_ANN_ELS | S_DES_S_FOR_S_TIT_ELS)) and 
($token->{type} == 6)) or 
($token->{type} == 4)) {
          &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        } else {
          &{$ProcessIM->[IN_FOREIGN_CONTENT_IM]->[$token->{type}]->[$token->{tn}]};
        }
      }

      ## Adjusted current node
      $InForeign = !!(
        @$OE and $OE->[-1]->{aet} & (MATHML_NS_ELS | SVG_NS_ELS)
      );

      $self->dom_tree ($OP);
      @$OP = ();
      @$Tokens = ();
    } # _construct_tree
  
    ## ------ DOM integration ------
    
sub dom_tree ($$) {
  my ($self, $ops) = @_;

  my $doc = $self->{document};
  my $strict = $doc->strict_error_checking;
  $doc->strict_error_checking (0);

  my $nodes = $self->{nodes};
  for my $op (@$ops) {
    if ($op->[0] eq 'insert' or
        $op->[0] eq 'insert-foster' or
        $op->[0] eq 'create') {
      my $data = $op->[1];
      my $el = $doc->create_element_ns
          ($NSToURL->[$data->{ns}], [$data->{prefix}, $data->{local_name}]);
      $el->manakai_set_source_location (['', $data->{di}, $data->{index}]);
      ## Note that $data->{ns} can be 0.
      for my $attr (@{$data->{attr_list} or []}) {
        $el->manakai_set_attribute_indexed_string_ns
            (@{$attr->{name_args}} => $attr->{value}); # IndexedString
      }
      if ($data->{et} & (TEM_ELS)) {
        $nodes->[$data->{id}] = $el->content;
        $el->content->manakai_set_source_location
            (['', $data->{di}, $data->{index}]);
      } else {
        $nodes->[$data->{id}] = $el;
      }
      # XXX $data->{script_flags}

      if (defined $data->{form}) {
        my $form = $nodes->[$data->{form}];
        #warn "XXX set form owner of $el to $form if $nodes->[$op->[2]] and $form are in the same home subtree";
      }

      if ($op->[0] eq 'insert') {
        $nodes->[$op->[2]]->append_child ($el);
      } elsif ($op->[0] eq 'insert-foster') {
        my $next_sibling = $nodes->[$op->[2]];
        my $parent = $next_sibling->parent_node;
        if (defined $parent) {
          if ($parent->node_type == $parent->DOCUMENT_NODE) {
            #
          } else {
            $parent->insert_before ($el, $next_sibling);
          }
        } else {
          $nodes->[$op->[3]]->append_child ($el);
        }
      }
    } elsif ($op->[0] eq 'text') {
      $nodes->[$op->[2]]->manakai_append_indexed_string ($op->[1]); # IndexedString
    } elsif ($op->[0] eq 'text-foster') {
      my $next_sibling = $nodes->[$op->[2]];
      my $parent = $next_sibling->parent_node;
      if (defined $parent) {
        if ($parent->node_type == $parent->DOCUMENT_NODE) {
          #
        } else {
          my $prev_sibling = $next_sibling->previous_sibling;
          if (defined $prev_sibling and
              $prev_sibling->node_type == $prev_sibling->TEXT_NODE) {
            $prev_sibling->manakai_append_indexed_string ($op->[1]);
          } else {
            $prev_sibling = $doc->create_text_node ('');
            $prev_sibling->manakai_append_indexed_string ($op->[1]);
            $parent->insert_before ($prev_sibling, $next_sibling);
          }
        }
      } else {
        $nodes->[$op->[3]]->manakai_append_text ($op->[1]);
      }

    } elsif ($op->[0] eq 'append') {
      $nodes->[$op->[2]]->append_child ($nodes->[$op->[1]]);
    } elsif ($op->[0] eq 'append-by-list') {
      my @node = $op->[1]->to_list;
      if (@node and $node[0]->node_type == $node[0]->TEXT_NODE) {
        my $node = shift @node;
        $nodes->[$op->[2]]->manakai_append_indexed_string
            ($node->manakai_get_indexed_string);
      }
      $nodes->[$op->[2]]->append_child ($_) for @node;
    } elsif ($op->[0] eq 'append-foster') {
      my $next_sibling = $nodes->[$op->[2]];
      my $parent = $next_sibling->parent_node;
      if (defined $parent) {
        if ($parent->node_type == $parent->DOCUMENT_NODE) {
          #
        } else {
          $parent->insert_before ($nodes->[$op->[1]], $next_sibling);
        }
      } else {
        $nodes->[$op->[3]]->append_child ($nodes->[$op->[1]]);
      }
    } elsif ($op->[0] eq 'move-children') {
      my $new_parent = $nodes->[$op->[2]];
      # XXX mutation observer?
      for ($nodes->[$op->[1]]->child_nodes->to_list) {
        $new_parent->append_child ($_);
      }

    } elsif ($op->[0] eq 'comment') {
      my $comment = $doc->create_comment (join '', map { $_->[0] } @{$op->[1]->{data}}); # IndexedString
      $comment->manakai_set_source_location
          (['', $op->[1]->{di}, $op->[1]->{index}]);
      $nodes->[$op->[2]]->append_child ($comment);
    } elsif ($op->[0] eq 'pi') {
      my $pi = $doc->create_processing_instruction ($op->[1]->{target}, '');
      $pi->manakai_append_indexed_string ($op->[1]->{data});
      $pi->manakai_set_source_location
          (['', $op->[1]->{di}, $op->[1]->{index}]);
      if ($op->[2] == 1) { # DOCTYPE
        unless ($self->ignore_doctype_pis) {
          local $nodes->[$op->[2]]->owner_document->dom_config->{manakai_allow_doctype_children} = 1;
          $nodes->[$op->[2]]->append_child ($pi);
        }
      } else {
        $nodes->[$op->[2]]->append_child ($pi);
      }
    } elsif ($op->[0] eq 'doctype') {
      my $data = $op->[1];
      my $dt = $doc->implementation->create_document_type
          (defined $data->{name} ? $data->{name} : '',
           defined $data->{public_identifier} ? $data->{public_identifier} : '',
           defined $data->{system_identifier} ? $data->{system_identifier} : '');
      $dt->manakai_set_source_location (['', $data->{di}, $data->{index}]);
      $nodes->[1] = $dt;
      $nodes->[$op->[2]]->append_child ($dt);

    } elsif ($op->[0] eq 'set-if-missing') {
      my $el = $nodes->[$op->[2]];
      for my $attr (@{$op->[1]}) {
        $el->manakai_set_attribute_indexed_string_ns
            (@{$attr->{name_args}} => $attr->{value}) # IndexedString
            unless $el->has_attribute_ns ($attr->{name_args}->[0], $attr->{name_args}->[1]->[1]);
      }

    } elsif ($op->[0] eq 'change-the-encoding') {
      unless ($Confident) {
        my $changed = $self->_change_the_encoding ($op->[1], $op->[2]);
        push @$Callbacks, [$self->onrestartwithencoding, $changed]
            if defined $changed;
      }
      if ($op->[2]->{has_ref}) {
        push @$Errors, {type => 'charref in charset', level => 'm',
                        di => $op->[2]->{di}, index => $op->[2]->{index}};
      }

    } elsif ($op->[0] eq 'script') {
      # XXX insertion point setup
      push @$Callbacks, [$self->onscript, $nodes->[$op->[1]]];
    } elsif ($op->[0] eq 'ignore-script') {
      #warn "XXX set already started flag of $nodes->[$op->[1]]";
    } elsif ($op->[0] eq 'appcache') {
      if (defined $op->[1]) {
        my $value = join '', map { $_->[0] } @{$op->[1]->{value}}; # IndexedString
        push @$Callbacks, [$self->onappcacheselection, length $value ? $value : undef];
      } else {
        push @$Callbacks, [$self->onappcacheselection, undef];
      }

    } elsif ($op->[0] eq 'popped') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_ELS | AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @{$op->[1]}]];
    } elsif ($op->[0] eq 'stop-parsing') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_ELS | AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @$OE]];
      #@$OE = ();

      # XXX stop parsing
    } elsif ($op->[0] eq 'abort') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_ELS | AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @$OE]];
      #@$OE = ();

      # XXX abort

    } elsif ($op->[0] eq 'remove') {
      my $parent = $nodes->[$op->[1]]->parent_node;
      $parent->remove_child ($nodes->[$op->[1]]) if defined $parent;

    } elsif ($op->[0] eq 'set-compat-mode') {
      $doc->manakai_compat_mode ($op->[1]);
## 

    } else {
      die "Unknown operation |$op->[0]|";
    }
  }

  $doc->strict_error_checking ($strict);
} # dom_tree

    sub ignore_doctype_pis ($;$) {
      if (@_ > 1) {
        $_[0]->{ignore_doctype_pis} = $_[1];
      }
      return $_[0]->{ignore_doctype_pis};
    } # ignore_doctype_pis

  
    ## ------ API ------
    
    sub _run ($) {
      my ($self) = @_;
      return 1 if $self->{pause};
      my $is = $self->{input_stream};
      # XXX rewrite loop conditions
      my $length = @$is == 0 ? 0 : defined $is->[0]->[0] ? length $is->[0]->[0] : 0;
      my $in_offset = 0;
      {
        my $len = 10000;
        $len = $length - $in_offset if $in_offset + $len > $length;
        if ($len > 0) {
          $Input = substr $is->[0]->[0], $in_offset, $len;
        } elsif (@$is and not defined $is->[0]->[0]) {
          $Input = '';
          pos ($Input) = 0;
          $EOF = 1;
        } else {
          shift @$is;
          if (@$is) {
            if (defined $is->[0]->[0]) {
              $length = length $is->[0]->[0];
              $in_offset = 0;
              redo;
            } else {
              $Input = '';
              pos ($Input) = 0;
              $EOF = 1;
            }
          } else {
            last;
          }
        }
        {
          $self->_tokenize;
          $self->_construct_tree;

          if (@$Callbacks or @$Errors or $self->{is_sub_parser}) {
            $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
            {
              my $Errors = $Errors;
              my $Callbacks = $Callbacks;

              $self->onerrors->($self, $Errors) if @$Errors;
              @$Errors = ();
              while (@$Callbacks) {
                my $cb = shift @$Callbacks;
                $cb->[0]->($self, $cb->[1]);
              }

              if ($self->{restart}) {
                delete $self->{restart};
                return 0;
              }

              if ($self->{pause}) {
                my $pos = pos $Input;
                $is->[0] = [substr $is->[0]->[0], $in_offset + $pos]
                    if defined $is->[0]->[0];
                $Offset += $pos;
                $self->{saved_states}->{Offset} = $Offset;
                return 1;
              }
            }
            ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
() = @{$self->{saved_maps}}{qw()};
          }

          redo unless pos $Input == length $Input; # XXX parser pause flag
        }
        $Offset += $len;
        $in_offset += $len;
        redo unless $EOF;
      }
      if ($EOF) {
## 
        $self->onparsed->($self);
        $self->_cleanup_states;
      }
      return 1;
    } # _run
  

    sub _feed_chars ($$) {
      my ($self, $input) = @_;
      pos ($input->[0]) = 0;
      while ($input->[0] =~ /[\x{0001}-\x{0008}\x{000B}\x{000E}-\x{001F}\x{007F}-\x{009F}\x{D800}-\x{DFFF}\x{FDD0}-\x{FDEF}\x{FFFE}-\x{FFFF}\x{1FFFE}-\x{1FFFF}\x{2FFFE}-\x{2FFFF}\x{3FFFE}-\x{3FFFF}\x{4FFFE}-\x{4FFFF}\x{5FFFE}-\x{5FFFF}\x{6FFFE}-\x{6FFFF}\x{7FFFE}-\x{7FFFF}\x{8FFFE}-\x{8FFFF}\x{9FFFE}-\x{9FFFF}\x{AFFFE}-\x{AFFFF}\x{BFFFE}-\x{BFFFF}\x{CFFFE}-\x{CFFFF}\x{DFFFE}-\x{DFFFF}\x{EFFFE}-\x{EFFFF}\x{FFFFE}-\x{FFFFF}\x{10FFFE}-\x{10FFFF}]/gc) {
        my $index = $-[0];
        my $char = ord substr $input->[0], $index, 1;
        if ($char < 0x100) {
          push @$Errors, {type => 'control char', level => 'm',
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        } elsif ($char < 0xE000) {
          push @$Errors, {type => 'char:surrogate', level => 'm',
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        } else {
          push @$Errors, {type => 'nonchar', level => 'm',
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        }
      }
      push @{$self->{input_stream}}, $input;

      return $self->_run;
    } # _feed_chars
  

    sub _feed_eof ($) {
      my $self = $_[0];
      push @{$self->{input_stream}}, [undef];
      return $self->_run;
    } # _feed_eof
  

    sub parse_char_string ($$$) {
      my $self = $_[0];
      my $input = [$_[1]]; # string copy

      $self->{document} = my $doc = $_[2];
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      ## <HTML>
      $doc->manakai_is_html (1);
      ## </HTML>
      ## 
      $doc->manakai_compat_mode ('no quirks');
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];
      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $FRAMESET_OK = 1;
$AnchoredIndex = 0;
$NEXT_ID = 1;
$Offset = 0;
$self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {};
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      $Confident = 1; # irrelevant
      $State = DATA_STATE;;
      ## <!Temma>
      $IM = INITIAL_IM;
      ## </!Temma>

      $self->{input_stream} = [];
      my $dids = $self->di_data_set;
      $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
      $dids->[$DI] ||= {} if $DI >= 0;
      ## 
      $doc->manakai_set_source_location (['', $DI, 0]);

      local $self->{onextentref};
      $self->_feed_chars ($input) or die "Can't restart";
      $self->_feed_eof or die "Can't restart";

      return;
    } # parse_char_string
  

    sub parse_char_string_with_context ($$$$) {
      my $self = $_[0];
      my $context = $_[2]; # an Element or undef

      ## HTML fragment parsing algorithm
      ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-html-fragments>.

      ## XML fragment parsing algorithm
      ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-xhtml-fragments>

      ## 1.
      $self->{document} = my $doc = $_[3]; # an empty Document
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      my $nodes = $self->{nodes} = [$doc];
      ## <HTML>
      $doc->manakai_is_html (1);

      ## HTML 2.
      if (defined $context) {
        $doc->manakai_compat_mode ($context->owner_document->manakai_compat_mode);
      } else {
        ## Not in spec
        $doc->manakai_compat_mode ('no quirks');
      }
      ## </HTML>

      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $FRAMESET_OK = 1;
$AnchoredIndex = 0;
$NEXT_ID = 1;
$Offset = 0;
$self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {};
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      $State = DATA_STATE;;

      ## 3.
      my $input = [$_[1]]; # string copy
      $self->{input_stream} = [];
      my $dids = $self->di_data_set;
      $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
      $dids->[$DI] ||= {} if $DI >= 0;
      ## 

      ## HTML 4. / XML 3. (cnt.)
      my $root;
      if (defined $context) {
        $IM = INITIAL_IM;

        ## HTML 4.1. / XML 2., 4., 6.
        my $node_ns = $context->namespace_uri || '';
        my $node_ln = $context->local_name;
        if ($node_ns eq 'http://www.w3.org/1999/xhtml') {
          ## <HTML>
          if ($Scripting and $node_ln eq 'noscript') {
            $State = RAWTEXT_STATE;;
          } else {
            $State = $StateByElementName->{$node_ln} || $State;
          }
          ## </HTML>
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => $Element2Type->[HTMLNS]->{$node_ln} || $Element2Type->[HTMLNS]->{'*'},
                      aet => $Element2Type->[HTMLNS]->{$node_ln} || $Element2Type->[HTMLNS]->{'*'}};
        ## <HTML>
        } elsif ($node_ns eq 'http://www.w3.org/2000/svg') {
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => SVGNS,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => $Element2Type->[SVGNS]->{$node_ln} || $Element2Type->[SVGNS]->{'*'},
                      aet => $Element2Type->[SVGNS]->{$node_ln} || $Element2Type->[SVGNS]->{'*'}};
        } elsif ($node_ns eq 'http://www.w3.org/1998/Math/MathML') {
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => MATHMLNS,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => $Element2Type->[MATHMLNS]->{$node_ln} || $Element2Type->[MATHMLNS]->{'*'},
                      aet => $Element2Type->[MATHMLNS]->{$node_ln} || $Element2Type->[MATHMLNS]->{'*'}};
          if ($node_ln eq 'annotation-xml') {
            my $encoding = $context->get_attribute_ns (undef, 'encoding');
            if (defined $encoding) {
              $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml') {
                $CONTEXT->{et} |= M_ANN_M_ANN_ELS;
                $CONTEXT->{aet} |= M_ANN_M_ANN_ELS;
              }
            }
          }
        ## </HTML>
        } else {
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => 0,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => 0,
                      aet => 0};
        }
        ## 
        $nodes->[$CONTEXT->{id}] = $context;

        ## <HTML>
        ## HTML 4.2.
        $root = $doc->create_element ('html');
        ## </HTML>
        ## 

        ## HTML 4.3.
        $doc->append_child ($root);

        ## <HTML>
        ## HTML 4.4.
        @$OE = ({id => $NEXT_ID++,
                 #token => undef,
                 #di => $token->{di}, index => $token->{index},
                 ns => HTMLNS,
                 local_name => 'html',
                 attr_list => [],
                 et => $Element2Type->[HTMLNS]->{html},
                 aet => $CONTEXT->{aet}});
        ## </HTML>
        ## 

        ## HTML 4.5.
        if ($node_ns eq 'http://www.w3.org/1999/xhtml' and
            $node_ln eq 'template') {
          ## <HTML>
          push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
          ## </HTML>
          ## 
        }
        $nodes->[$OE->[-1]->{id}] = $root;

        ## <HTML>
        ## HTML 4.6.
        &reset_im;

        ## HTML 4.7.
        my $anode = $context;
        while (defined $anode) {
          if ($anode->node_type == 1 and
              ($anode->namespace_uri || '') eq 'http://www.w3.org/1999/xhtml' and
              $anode->local_name eq 'form') {
            if ($anode eq $context) {
              $FORM_ELEMENT = $CONTEXT;
            } else {
              $FORM_ELEMENT = {id => $NEXT_ID++,
                               #token => undef,
                               #di => $token->{di}, index => $token->{index},
                               ns => HTMLNS,
                               local_name => 'form',
                               attr_list => [], # not relevant
                               et => $Element2Type->[HTMLNS]->{form},
                               aet => $Element2Type->[HTMLNS]->{form}};
            }
            last;
          }
          $anode = $anode->parent_node;
        }
        ## </HTML>
      } else { # $context
        $IM = INITIAL_IM;
      } # $context

      ## HTML 5.
      $Confident = 1; # irrelevant

      ## HTML 6. / XML 3. (cnt.)
      local $self->{onextentref};
      $self->_feed_chars ($input) or die "Can't restart";
      $self->_feed_eof or die "Can't restart";

      ## XML 5. If not well-formed, throw SyntaxError - should be
      ## handled by callee using $self->onerror.

      ## 7.
      return defined $context ? $root->child_nodes : $doc->child_nodes;
    } # parse_char_string_with_context
  

    sub parse_chars_start ($$) {
      my ($self, $doc) = @_;

      $self->{input_stream} = [];
      $self->{document} = $doc;
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->manakai_is_html (1);
      $doc->manakai_compat_mode ('no quirks');
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];

      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $FRAMESET_OK = 1;
$AnchoredIndex = 0;
$NEXT_ID = 1;
$Offset = 0;
$self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {};
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      $Confident = 1; # irrelevant
      $State = DATA_STATE;;
      $IM = INITIAL_IM;

      my $dids = $self->di_data_set;
      $DI = @$dids || 1;
      $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
      $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
      $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
      $doc->manakai_set_source_location (['', $DI, 0]);
      ## Note that $DI != $source_di to support document.write()'s
      ## insertion.
      ## 

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
      return;
    } # parse_chars_start
  

    sub parse_chars_feed ($$) {
      my $self = $_[0];
      my $input = [$_[1]]; # string copy

      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
() = @{$self->{saved_maps}}{qw()};

      $self->_feed_chars ($input) or die "Can't restart";

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
      return;
    } # parse_chars_feed

    sub parse_chars_end ($) {
      my $self = $_[0];
      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
() = @{$self->{saved_maps}}{qw()};

      $self->_feed_eof or die "Can't restart";
      
      return;
    } # parse_chars_end

## NOTE: HTML5 spec says that the encoding layer MUST NOT strip BOM
## and the HTML layer MUST ignore it.  However, we does strip BOM in
## the encoding layer and the HTML layer does not ignore any U+FEFF,
## because the core part of our HTML parser expects a string of
## character, not a string of bytes or code units or anything which
## might contain a BOM.  Therefore, any parser interface that accepts
## a string of bytes, such as |parse_byte_string| in this module, must
## ensure that it does strip the BOM and never strip any ZWNBSP.

## XXX The policy mentioned above might change when we implement
## Encoding Standard spec.

  

    sub parse_byte_string ($$$$) {
      my $self = $_[0];

      $self->{document} = my $doc = $_[3];
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->manakai_is_html (1);
      $doc->manakai_compat_mode ('no quirks');
      $self->{can_restart} = 1;

      PARSER: {
        $self->{input_stream} = [];
        $self->{nodes} = [$doc];
        $doc->remove_child ($_) for $doc->child_nodes->to_list;

        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $FRAMESET_OK = 1;
$AnchoredIndex = 0;
$NEXT_ID = 1;
$Offset = 0;
$self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {};
        $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};

        my $inputref = \($_[2]);
        $self->_encoding_sniffing
            (transport_encoding_name => $_[1],
             read_head => sub {
          return \substr $$inputref, 0, 1024;
        }); # $Confident is set within this method.
        $doc->input_encoding ($self->{input_encoding});

        my $input = [decode $self->{input_encoding}, $$inputref]; # XXXencoding
        my $dids = $self->di_data_set;
        $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
        $dids->[$DI] ||= {} if $DI >= 0;
        $doc->manakai_set_source_location (['', $DI, 0]);
        ## 

        $State = DATA_STATE;;
        $IM = INITIAL_IM;

        local $self->{onextentref};
        $self->_feed_chars ($input) or redo PARSER;
        $self->_feed_eof or redo PARSER;
      } # PARSER

      return;
    } # parse_byte_string
  

    sub _parse_bytes_init ($) {
      my $self = $_[0];

      my $doc = $self->{document};
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];

      delete $self->{parse_bytes_started};
      $self->{input_stream} = [];
      $FRAMESET_OK = 1;
$AnchoredIndex = 0;
$NEXT_ID = 1;
$Offset = 0;
$self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {};
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      $State = DATA_STATE;;
      $IM = INITIAL_IM;

      my $dids = $self->di_data_set;
      $DI = @$dids || 1;
      $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
      $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
      $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
      $doc->manakai_set_source_location (['', $DI, 0]);
      ## Note that $DI != $source_di to support document.write()'s
      ## insertion.
      ## 
    } # _parse_bytes_init
  

    sub _parse_bytes_start_parsing ($;%) {
      my ($self, %args) = @_;
      
      $self->_encoding_sniffing
          (transport_encoding_name => $self->{transport_encoding_label},
           no_body_data_yet => $args{no_body_data_yet},
           read_head => sub {
             return \(substr $self->{byte_buffer}, 0, 1024);
           }); # $Confident is set within this method.
      if (not defined $self->{input_encoding} and $args{no_body_data_yet}) {
        return 1;
      }
      $self->{document}->input_encoding ($self->{input_encoding});

      $self->{parse_bytes_started} = 1;

      my $input = [decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET]; # XXXencoding

      $self->_feed_chars ($input) or return 0;

      return 1;
    } # _parse_bytes_start_parsing
  

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{document} = my $doc = $_[2];
      $doc->manakai_is_html (1);
      $self->{can_restart} = 1;

      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
      return;
    } # parse_bytes_start
  

    ## The $args{start_parsing} flag should be set true if it has
    ## taken more than 500ms from the start of overall parsing
    ## process. XXX should this be a separate method?
    sub parse_bytes_feed ($$;%) {
      my ($self, undef, %args) = @_;

      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
() = @{$self->{saved_maps}}{qw()};

      $self->{byte_buffer} .= $_[1];
      $self->{byte_buffer_orig} .= $_[1];
      PARSER: {
        if ($self->{parse_bytes_started}) {
          my $input = [decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET]; # XXXencoding
          if (length $self->{byte_buffer} and 0 == length $input->[0]) {
            substr ($self->{byte_buffer}, 0, 1) = '';
            $input->[0] .= "\x{FFFD}" . decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET; # XXX Encoding Standard
          }

          $self->_feed_chars ($input) or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        } else {
          if ($args{start_parsing} or 1024 <= length $self->{byte_buffer}) {
            $self->_parse_bytes_start_parsing or do {
              $self->{byte_buffer} = $self->{byte_buffer_orig};
              $self->_parse_bytes_init;
              redo PARSER;
            };
          }
        }
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
      return;
    } # parse_bytes_feed

    sub parse_bytes_end ($) {
      my $self = $_[0];
      local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
      $IframeSrcdoc = $self->{IframeSrcdoc};
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
() = @{$self->{saved_maps}}{qw()};

      PARSER: {
        unless ($self->{parse_bytes_started}) {
          $self->_parse_bytes_start_parsing or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        }

        if (length $self->{byte_buffer}) {
          my $input = [decode $self->{input_encoding}, $self->{byte_buffer}]; # XXX encoding
          $self->_feed_chars ($input) or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        }

        $self->_feed_eof or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          $self->_parse_bytes_init;
          redo PARSER;
        };
      } # PARSER
      
      return;
    } # parse_bytes_end
  

    1;

=head1 LICENSE

Copyright 2007-2015 Wakaba <wakaba@suikawiki.org>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

This library derived from a JSON file, which contains data extracted
from HTML Standard.  "Written by Ian Hickson (Google, ian@hixie.ch) -
Parts Â© Copyright 2004-2014 Apple Inc., Mozilla Foundation, and Opera
Software ASA; You are granted a license to use, reproduce and create
derivative works of this document."

=cut

  