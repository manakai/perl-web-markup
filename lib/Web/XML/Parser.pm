
    package Web::XML::Parser;
    use strict;
    use warnings;
    no warnings 'utf8';
    use warnings FATAL => 'recursion';
    use warnings FATAL => 'redefine';
    use warnings FATAL => 'uninitialized';
    use utf8;
    our $VERSION = '8.0';
    use Carp qw(croak);
    
    use Encode qw(decode); # XXX
    use Web::Encoding;
    use Web::HTML::ParserData;
    use Web::HTML::_SyntaxDefs;

    
        sub HTMLNS () { q<http://www.w3.org/1999/xhtml> }
      
    my $TagName2Group = {};

    ## ------ Common handlers ------

    sub new ($) {
      return bless {
        ## Input parameters
        # Scripting IframeSrcdoc DI known_definite_encoding locale_tag
        # di_data_set is_sub_parser

        ## Callbacks
        # onerror onerrors onappcacheselection onscript
        # onelementspopped onrestartwithencoding
        # onextentref onparsed

        ## Parser internal states
        # input_stream input_encoding saved_states saved_lists saved_maps
        # nodes document can_restart restart
        # parse_bytes_started transport_encoding_label
        # byte_bufer byte_buffer_orig
      }, $_[0];
    } # new

my $GetDefaultErrorHandler = sub {
  my $dids = $_[0]->di_data_set;
  return sub {
    my $error = {@_};
    require Web::HTML::SourceMap;
    my ($di, $index) = Web::HTML::SourceMap::resolve_index_pair ($dids, $error->{di}, $error->{index});
    my $text = defined $error->{text} ? qq{ - $error->{text}} : '';
    my $value = defined $error->{value} ? qq{ "$error->{value}"} : '';
    my $level = {
      m => 'Parse error',
      s => 'SHOULD-level error',
      w => 'Warning',
      i => 'Information',
    }->{$error->{level} || ''} || $error->{level};
    my $doc = 'document #' . $error->{di};
    if (not $di == -1) {
      my $did = $dids->[$di];
      if (defined $did->{name}) {
        $doc = $did->{name};
      } elsif (defined $did->{url}) {
        $doc = 'document <' . $did->{url} . '>';
      }
    }
    warn "$level ($error->{type}$text) at $doc index $index$value\n";
  };
}; # $GetDefaultErrorHandler

sub onerror ($;$) {
  if (@_ > 1) {
    $_[0]->{onerror} = $_[1];
  }
  return $_[0]->{onerror} ||= $GetDefaultErrorHandler->($_[0]);
} # onerror

sub onerrors ($;$) {
  if (@_ > 1) {
    $_[0]->{onerrors} = $_[1];
  }
  return $_[0]->{onerrors} || sub {
    my $onerror = $_[0]->onerror;
    $onerror->(%$_) for @{$_[1]};
  };
} # onerrors

sub onappcacheselection ($;$) {
  if (@_ > 1) {
    $_[0]->{onappcacheselection} = $_[1];
  }
  return $_[0]->{onappcacheselection} || sub { };
} # onappcacheselection

sub onscript ($;$) {
  if (@_ > 1) {
    $_[0]->{onscript} = $_[1];
  }
  return $_[0]->{onscript} || sub { };
} # onscript

sub onextentref ($;$) {
  if (@_ > 1) {
    $_[0]->{onextentref} = $_[1];
  }
  return $_[0]->{onextentref} || sub {
    my ($self, $data, $sub) = @_;
    $self->cant_expand_extentref ($data, $sub);
  };
} # onextentref

sub max_entity_depth ($;$) {
  if (@_ > 1) {
    $_[0]->{max_entity_depth} = $_[1];
  }
  return $_[0]->{max_entity_depth} || 10;
} # max_entity_depth

sub max_entity_expansions ($;$) {
  if (@_ > 1) {
    return $_[0]->{max_entity_expansions} = $_[1];
  }
  return $_[0]->{max_entity_expansions} || 1000;
} # max_entity_expansions

sub onelementspopped ($;$) {
  if (@_ > 1) {
    $_[0]->{onelementspopped} = $_[1];
  }
  return $_[0]->{onelementspopped} || sub { };
} # onelementspopped

sub onrestartwithencoding ($;$) {
  if (@_ > 1) {
    $_[0]->{onrestartwithencoding} = $_[1];
  }
  return $_[0]->{onrestartwithencoding} || sub {
    my ($self, $encoding) = @_;
    $self->known_definite_encoding ($encoding);
    $self->restart;
  };
} # onrestartwithencoding

    sub throw ($$) { $_[1]->() }

    sub restart ($) {
      unless ($_[0]->{can_restart}) {
        croak "The current parsing method can't restart the parser";
      }
      $_[0]->{restart} = 1;
    } # restart

    sub scripting ($;$) {
      if (@_ > 1) {
        $_[0]->{Scripting} = $_[1];
      }
      return $_[0]->{Scripting};
    } # scripting

    sub onparsed ($;$) {
      if (@_ > 1) {
        $_[0]->{onparsed} = $_[1];
      }
      return $_[0]->{onparsed} || sub { };
    } # onparsed

    sub _cleanup_states ($) {
      my $self = $_[0];
      delete $self->{input_stream};
      delete $self->{input_encoding};
      delete $self->{saved_states};
      delete $self->{saved_lists};
      delete $self->{saved_maps};
      delete $self->{nodes};
      delete $self->{document};
      delete $self->{can_restart};
      delete $self->{restart};
      delete $self->{pause};
      delete $self->{main_parser};
    } # _cleanup_states

    ## ------ Common defs ------
    our $AnchoredIndex;our $Attr;our $BaseURLDI;our $CONTEXT;our $Callbacks;our $Confident;our $DI;our $DTDDefs;our $DTDMode;our $EOF;our $Errors;our $IM;our $IframeSrcdoc;our $InLiteral;our $InMDEntity;our $InitialCMGroupDepth;our $Input;our $LastCMItem;our $LastStartTagName;our $NEXT_ID;our $OE;our $OP;our $ORIGINAL_IM;our $Offset;our $OpenCMGroups;our $OpenMarkedSections;our $OriginalState;our $SC;our $Scripting;our $State;our $Temp;our $TempIndex;our $TempRef;our $Token;our $Tokens;
    ## ------ Tokenizer defs ------
    my $InvalidCharRefs = $Web::HTML::_SyntaxDefs->{xml_charref_invalid};
sub ATTLIST_TOKEN () { 1 }
sub DOCTYPE_TOKEN () { 2 }
sub ELEMENT_TOKEN () { 3 }
sub ENTITY_TOKEN () { 4 }
sub NOTATION_TOKEN () { 5 }
sub COMMENT_TOKEN () { 6 }
sub END_TAG_TOKEN () { 7 }
sub END_OF_DOCTYPE_TOKEN () { 8 }
sub END_OF_FILE_TOKEN () { 9 }
sub PROCESSING_INSTRUCTION_TOKEN () { 10 }
sub START_TAG_TOKEN () { 11 }
sub TEXT_TOKEN () { 12 }
sub ATTLIST_ATTR_DEFAULT_STATE () { 1 }
sub ATTLIST_ATTR_NAME_STATE () { 2 }
sub ATTLIST_ATTR_TYPE_STATE () { 3 }
sub ATTLIST_NAME_STATE () { 4 }
sub ATTLIST_STATE () { 5 }
sub CDATA_SECTION_BRACKET_STATE () { 6 }
sub CDATA_SECTION_END_STATE () { 7 }
sub CDATA_SECTION_STATE () { 8 }
sub CDATA_SECTION_STATE_CR () { 9 }
sub DOCTYPE_PI_DATA_STATE () { 10 }
sub DOCTYPE_PI_DATA_STATE_CR () { 11 }
sub DOCTYPE_PI_STATE () { 12 }
sub DOCTYPE_PI_TARGET_QUESTION_STATE () { 13 }
sub DOCTYPE_PI_TARGET_STATE () { 14 }
sub DOCTYPE_AFTER_PI_TARGET_STATE () { 15 }
sub DOCTYPE_AFTER_PI_TARGET_STATE_CR () { 16 }
sub DOCTYPE_BOGUS_COMMENT_STATE () { 17 }
sub DOCTYPE_BOGUS_COMMENT_STATE_CR () { 18 }
sub DOCTYPE_COMMENT_END_BANG_STATE () { 19 }
sub DOCTYPE_COMMENT_END_DASH_STATE () { 20 }
sub DOCTYPE_COMMENT_END_STATE () { 21 }
sub DOCTYPE_COMMENT_START_DASH_STATE () { 22 }
sub DOCTYPE_COMMENT_START_STATE () { 23 }
sub DOCTYPE_COMMENT_STATE () { 24 }
sub DOCTYPE_COMMENT_STATE_CR () { 25 }
sub DOCTYPE_IN_PIC_STATE () { 26 }
sub DOCTYPE_MDO_STATE () { 27 }
sub DOCTYPE_MDO_STATE__ () { 28 }
sub DOCTYPE_MDO_STATE_A () { 29 }
sub DOCTYPE_MDO_STATE_AT () { 30 }
sub DOCTYPE_MDO_STATE_ATT () { 31 }
sub DOCTYPE_MDO_STATE_ATTL () { 32 }
sub DOCTYPE_MDO_STATE_ATTLI () { 33 }
sub DOCTYPE_MDO_STATE_ATTLIS () { 34 }
sub DOCTYPE_MDO_STATE_E () { 35 }
sub DOCTYPE_MDO_STATE_EL () { 36 }
sub DOCTYPE_MDO_STATE_ELE () { 37 }
sub DOCTYPE_MDO_STATE_ELEM () { 38 }
sub DOCTYPE_MDO_STATE_ELEME () { 39 }
sub DOCTYPE_MDO_STATE_ELEMEN () { 40 }
sub DOCTYPE_MDO_STATE_EN () { 41 }
sub DOCTYPE_MDO_STATE_ENT () { 42 }
sub DOCTYPE_MDO_STATE_ENTI () { 43 }
sub DOCTYPE_MDO_STATE_ENTIT () { 44 }
sub DOCTYPE_MDO_STATE_N () { 45 }
sub DOCTYPE_MDO_STATE_NO () { 46 }
sub DOCTYPE_MDO_STATE_NOT () { 47 }
sub DOCTYPE_MDO_STATE_NOTA () { 48 }
sub DOCTYPE_MDO_STATE_NOTAT () { 49 }
sub DOCTYPE_MDO_STATE_NOTATI () { 50 }
sub DOCTYPE_MDO_STATE_NOTATIO () { 51 }
sub DOCTYPE_NAME_STATE () { 52 }
sub DOCTYPE_PUBLIC_ID__DQ__STATE () { 53 }
sub DOCTYPE_PUBLIC_ID__DQ__STATE_CR () { 54 }
sub DOCTYPE_PUBLIC_ID__SQ__STATE () { 55 }
sub DOCTYPE_PUBLIC_ID__SQ__STATE_CR () { 56 }
sub DOCTYPE_STATE () { 57 }
sub DOCTYPE_SYSTEM_ID__DQ__STATE () { 58 }
sub DOCTYPE_SYSTEM_ID__DQ__STATE_CR () { 59 }
sub DOCTYPE_SYSTEM_ID__SQ__STATE () { 60 }
sub DOCTYPE_SYSTEM_ID__SQ__STATE_CR () { 61 }
sub DOCTYPE_TAG_OPEN_STATE () { 62 }
sub DTD_STATE () { 63 }
sub ELEMENT_CONTENT_KWD_STATE () { 64 }
sub ELEMENT_NAME_STATE () { 65 }
sub ELEMENT_STATE () { 66 }
sub ENT_NAME_STATE () { 67 }
sub ENT_PUBLIC_ID__DQ__STATE () { 68 }
sub ENT_PUBLIC_ID__DQ__STATE_CR () { 69 }
sub ENT_PUBLIC_ID__SQ__STATE () { 70 }
sub ENT_PUBLIC_ID__SQ__STATE_CR () { 71 }
sub ENT_STATE () { 72 }
sub ENT_SYSTEM_ID__DQ__STATE () { 73 }
sub ENT_SYSTEM_ID__DQ__STATE_CR () { 74 }
sub ENT_SYSTEM_ID__SQ__STATE () { 75 }
sub ENT_SYSTEM_ID__SQ__STATE_CR () { 76 }
sub ENT_VALUE__DQ__STATE () { 77 }
sub ENT_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 78 }
sub ENT_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 79 }
sub ENT_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE () { 80 }
sub ENT_VALUE__DQ__STATE___CHARREF_NAME_STATE () { 81 }
sub ENT_VALUE__DQ__STATE___CHARREF_NUM_STATE () { 82 }
sub ENT_VALUE__DQ__STATE___CHARREF_STATE () { 83 }
sub ENT_VALUE__DQ__STATE_CR () { 84 }
sub ENT_VALUE__SQ__STATE () { 85 }
sub ENT_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 86 }
sub ENT_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 87 }
sub ENT_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE () { 88 }
sub ENT_VALUE__SQ__STATE___CHARREF_NAME_STATE () { 89 }
sub ENT_VALUE__SQ__STATE___CHARREF_NUM_STATE () { 90 }
sub ENT_VALUE__SQ__STATE___CHARREF_STATE () { 91 }
sub ENT_VALUE__SQ__STATE_CR () { 92 }
sub ENT_VALUE_IN_ENT_STATE () { 93 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 94 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE () { 95 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE () { 96 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE () { 97 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE () { 98 }
sub ENT_VALUE_IN_ENT_STATE___CHARREF_STATE () { 99 }
sub ENT_VALUE_IN_ENT_STATE_CR () { 100 }
sub NDATA_ID_STATE () { 101 }
sub NOTATION_NAME_STATE () { 102 }
sub NOTATION_PUBLIC_ID__DQ__STATE () { 103 }
sub NOTATION_PUBLIC_ID__DQ__STATE_CR () { 104 }
sub NOTATION_PUBLIC_ID__SQ__STATE () { 105 }
sub NOTATION_PUBLIC_ID__SQ__STATE_CR () { 106 }
sub NOTATION_STATE () { 107 }
sub NOTATION_SYSTEM_ID__DQ__STATE () { 108 }
sub NOTATION_SYSTEM_ID__DQ__STATE_CR () { 109 }
sub NOTATION_SYSTEM_ID__SQ__STATE () { 110 }
sub NOTATION_SYSTEM_ID__SQ__STATE_CR () { 111 }
sub PI_DATA_STATE () { 112 }
sub PI_DATA_STATE_CR () { 113 }
sub PI_STATE () { 114 }
sub PI_TARGET_QUESTION_STATE () { 115 }
sub PI_TARGET_STATE () { 116 }
sub A_ATTLIST_ATTR_DEFAULT_STATE () { 117 }
sub A_ATTLIST_ATTR_DEFAULT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 118 }
sub A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 119 }
sub A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 120 }
sub A_ATTLIST_ATTR_NAME_STATE () { 121 }
sub A_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 122 }
sub A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 123 }
sub A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 124 }
sub A_ATTLIST_ATTR_TYPE_STATE () { 125 }
sub A_ATTLIST_ATTR_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 126 }
sub A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 127 }
sub A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 128 }
sub A_ATTLIST_DEFAULT_VALUE_STATE () { 129 }
sub A_DOCTYPE_INTERNAL_SUBSET_STATE () { 130 }
sub A_DOCTYPE_NAME_STATE () { 131 }
sub A_DOCTYPE_NAME_STATE_P () { 132 }
sub A_DOCTYPE_NAME_STATE_PU () { 133 }
sub A_DOCTYPE_NAME_STATE_PUB () { 134 }
sub A_DOCTYPE_NAME_STATE_PUBL () { 135 }
sub A_DOCTYPE_NAME_STATE_PUBLI () { 136 }
sub A_DOCTYPE_NAME_STATE_S () { 137 }
sub A_DOCTYPE_NAME_STATE_SY () { 138 }
sub A_DOCTYPE_NAME_STATE_SYS () { 139 }
sub A_DOCTYPE_NAME_STATE_SYST () { 140 }
sub A_DOCTYPE_NAME_STATE_SYSTE () { 141 }
sub A_DOCTYPE_PUBLIC_ID_STATE () { 142 }
sub A_DOCTYPE_PUBLIC_KWD_STATE () { 143 }
sub A_DOCTYPE_SYSTEM_ID_STATE () { 144 }
sub A_DOCTYPE_SYSTEM_KWD_STATE () { 145 }
sub A_DTD_MSC_STATE () { 146 }
sub A_ELEMENT_CONTENT_STATE () { 147 }
sub A_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 148 }
sub A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 149 }
sub A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 150 }
sub A_ENT_NAME_STATE () { 151 }
sub A_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 152 }
sub A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 153 }
sub A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 154 }
sub A_ENT_NAME_STATE_P () { 155 }
sub A_ENT_NAME_STATE_PU () { 156 }
sub A_ENT_NAME_STATE_PUB () { 157 }
sub A_ENT_NAME_STATE_PUBL () { 158 }
sub A_ENT_NAME_STATE_PUBLI () { 159 }
sub A_ENT_NAME_STATE_S () { 160 }
sub A_ENT_NAME_STATE_SY () { 161 }
sub A_ENT_NAME_STATE_SYS () { 162 }
sub A_ENT_NAME_STATE_SYST () { 163 }
sub A_ENT_NAME_STATE_SYSTE () { 164 }
sub A_ENT_PARAMETER_STATE () { 165 }
sub A_ENT_PARAMETER_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 166 }
sub A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 167 }
sub A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 168 }
sub A_ENT_PUBLIC_ID_STATE () { 169 }
sub A_ENT_PUBLIC_KWD_STATE () { 170 }
sub A_ENT_SYSTEM_ID_STATE () { 171 }
sub A_ENT_SYSTEM_KWD_STATE () { 172 }
sub A_IGNORE_KWD_STATE () { 173 }
sub A_IGNORE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 174 }
sub A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 175 }
sub A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 176 }
sub A_INCLUDE_KWD_STATE () { 177 }
sub A_INCLUDE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 178 }
sub A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 179 }
sub A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 180 }
sub A_NDATA_KWD_STATE () { 181 }
sub A_NOTATION_NAME_STATE () { 182 }
sub A_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 183 }
sub A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 184 }
sub A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 185 }
sub A_NOTATION_NAME_STATE_P () { 186 }
sub A_NOTATION_NAME_STATE_PU () { 187 }
sub A_NOTATION_NAME_STATE_PUB () { 188 }
sub A_NOTATION_NAME_STATE_PUBL () { 189 }
sub A_NOTATION_NAME_STATE_PUBLI () { 190 }
sub A_NOTATION_NAME_STATE_S () { 191 }
sub A_NOTATION_NAME_STATE_SY () { 192 }
sub A_NOTATION_NAME_STATE_SYS () { 193 }
sub A_NOTATION_NAME_STATE_SYST () { 194 }
sub A_NOTATION_NAME_STATE_SYSTE () { 195 }
sub A_NOTATION_PUBLIC_ID_STATE () { 196 }
sub A_NOTATION_PUBLIC_KWD_STATE () { 197 }
sub A_NOTATION_SYSTEM_ID_STATE () { 198 }
sub A_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 199 }
sub A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 200 }
sub A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 201 }
sub A_NOTATION_SYSTEM_KWD_STATE () { 202 }
sub A_PI_TARGET_STATE () { 203 }
sub A_PI_TARGET_STATE_CR () { 204 }
sub A_AFTER_ALLOWED_TOKEN_LIST_STATE () { 205 }
sub A_AFTER_ALLOWED_TOKEN_LIST_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 206 }
sub A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 207 }
sub A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 208 }
sub A_ALLOWED_TOKEN_LIST_STATE () { 209 }
sub A_ALLOWED_TOKEN_STATE () { 210 }
sub A_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 211 }
sub A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 212 }
sub A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 213 }
sub A_ATTR_NAME_STATE () { 214 }
sub A_ATTR_VALUE__QUOTED__STATE () { 215 }
sub A_CM_GROUP_STATE () { 216 }
sub A_CM_ITEM_STATE () { 217 }
sub A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 218 }
sub A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 219 }
sub A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 220 }
sub A_IGNORED_SECTION_MSC_STATE () { 221 }
sub A_MSC_STATE () { 222 }
sub A_MSS_STATE () { 223 }
sub A_MSS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 224 }
sub A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 225 }
sub A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 226 }
sub A_MSS_STATE_I () { 227 }
sub A_MSS_STATE_IG () { 228 }
sub A_MSS_STATE_IGN () { 229 }
sub A_MSS_STATE_IGNO () { 230 }
sub A_MSS_STATE_IGNOR () { 231 }
sub A_MSS_STATE_IN () { 232 }
sub A_MSS_STATE_INC () { 233 }
sub A_MSS_STATE_INCL () { 234 }
sub A_MSS_STATE_INCLU () { 235 }
sub A_MSS_STATE_INCLUD () { 236 }
sub ALLOWED_TOKEN_STATE () { 237 }
sub ATTR_NAME_STATE () { 238 }
sub ATTR_VALUE__DQ__STATE () { 239 }
sub ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 240 }
sub ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 241 }
sub ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE () { 242 }
sub ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE () { 243 }
sub ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE () { 244 }
sub ATTR_VALUE__DQ__STATE___CHARREF_STATE () { 245 }
sub ATTR_VALUE__DQ__STATE_CR () { 246 }
sub ATTR_VALUE__SQ__STATE () { 247 }
sub ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 248 }
sub ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 249 }
sub ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE () { 250 }
sub ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE () { 251 }
sub ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE () { 252 }
sub ATTR_VALUE__SQ__STATE___CHARREF_STATE () { 253 }
sub ATTR_VALUE__SQ__STATE_CR () { 254 }
sub ATTR_VALUE__UNQUOTED__STATE () { 255 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 256 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE () { 257 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE () { 258 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE () { 259 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE () { 260 }
sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE () { 261 }
sub ATTR_VALUE__UNQUOTED__STATE_CR () { 262 }
sub ATTR_VALUE_IN_ENT_STATE () { 263 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 264 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE () { 265 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE () { 266 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE () { 267 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE () { 268 }
sub ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE () { 269 }
sub ATTR_VALUE_IN_ENT_STATE_CR () { 270 }
sub B_ATTLIST_ATTR_DEFAULT_STATE () { 271 }
sub B_ATTLIST_ATTR_NAME_STATE () { 272 }
sub B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 273 }
sub B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 274 }
sub B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 275 }
sub B_ATTLIST_NAME_STATE () { 276 }
sub B_ATTLIST_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 277 }
sub B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 278 }
sub B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 279 }
sub B_DOCTYPE_NAME_STATE () { 280 }
sub B_DOCTYPE_PUBLIC_ID_STATE () { 281 }
sub B_DOCTYPE_SYSTEM_ID_STATE () { 282 }
sub B_ELEMENT_CONTENT_STATE () { 283 }
sub B_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 284 }
sub B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 285 }
sub B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 286 }
sub B_ELEMENT_NAME_STATE () { 287 }
sub B_ELEMENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 288 }
sub B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 289 }
sub B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 290 }
sub B_ENT_NAME_STATE () { 291 }
sub B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 292 }
sub B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 293 }
sub B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 294 }
sub B_ENT_PUBLIC_ID_STATE () { 295 }
sub B_ENT_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 296 }
sub B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 297 }
sub B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 298 }
sub B_ENT_SYSTEM_ID_STATE () { 299 }
sub B_ENT_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 300 }
sub B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 301 }
sub B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 302 }
sub B_ENT_TYPE_STATE () { 303 }
sub B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 304 }
sub B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 305 }
sub B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 306 }
sub B_ENT_VALUE_IN_ENT_STATE () { 307 }
sub B_NDATA_ID_STATE () { 308 }
sub B_NDATA_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 309 }
sub B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 310 }
sub B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 311 }
sub B_NDATA_KWD_STATE () { 312 }
sub B_NDATA_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 313 }
sub B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 314 }
sub B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 315 }
sub B_NDATA_KWD_STATE_N () { 316 }
sub B_NDATA_KWD_STATE_ND () { 317 }
sub B_NDATA_KWD_STATE_NDA () { 318 }
sub B_NDATA_KWD_STATE_NDAT () { 319 }
sub B_NOTATION_NAME_STATE () { 320 }
sub B_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 321 }
sub B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 322 }
sub B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 323 }
sub B_NOTATION_PUBLIC_ID_STATE () { 324 }
sub B_NOTATION_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 325 }
sub B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 326 }
sub B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 327 }
sub B_NOTATION_SYSTEM_ID_STATE () { 328 }
sub B_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 329 }
sub B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 330 }
sub B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 331 }
sub B_ALLOWED_TOKEN_STATE () { 332 }
sub B_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 333 }
sub B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 334 }
sub B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 335 }
sub B_ATTR_NAME_STATE () { 336 }
sub B_ATTR_VALUE_STATE () { 337 }
sub B_CM_ITEM_STATE () { 338 }
sub B_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 339 }
sub B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 340 }
sub B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 341 }
sub BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE () { 342 }
sub BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE () { 343 }
sub BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 344 }
sub BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 345 }
sub BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 346 }
sub BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE () { 347 }
sub BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE () { 348 }
sub BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE () { 349 }
sub BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR () { 350 }
sub BOGUS_DOCTYPE_STATE () { 351 }
sub BOGUS_AFTER_DOCTYPE_INTERNAL_SUBSET_STATE () { 352 }
sub BOGUS_COMMENT_STATE () { 353 }
sub BOGUS_COMMENT_STATE_CR () { 354 }
sub BOGUS_MARKUP_DECL_STATE () { 355 }
sub BOGUS_STATUS_KWD_STATE () { 356 }
sub CHARREF_IN_DATA_STATE () { 357 }
sub COMMENT_END_BANG_STATE () { 358 }
sub COMMENT_END_DASH_STATE () { 359 }
sub COMMENT_END_STATE () { 360 }
sub COMMENT_START_DASH_STATE () { 361 }
sub COMMENT_START_STATE () { 362 }
sub COMMENT_STATE () { 363 }
sub COMMENT_STATE_CR () { 364 }
sub CM_ELEMENT_STATE () { 365 }
sub DATA_STATE () { 366 }
sub DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 367 }
sub DATA_STATE___CHARREF_DECIMAL_NUM_STATE () { 368 }
sub DATA_STATE___CHARREF_HEX_NUM_STATE () { 369 }
sub DATA_STATE___CHARREF_NAME_STATE () { 370 }
sub DATA_STATE___CHARREF_NUM_STATE () { 371 }
sub DATA_STATE___CHARREF_STATE () { 372 }
sub DATA_STATE___CHARREF_STATE_CR () { 373 }
sub DATA_STATE_CR () { 374 }
sub DEFAULT_ATTR_VALUE__DQ__STATE () { 375 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 376 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 377 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE () { 378 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE () { 379 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE () { 380 }
sub DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE () { 381 }
sub DEFAULT_ATTR_VALUE__DQ__STATE_CR () { 382 }
sub DEFAULT_ATTR_VALUE__SQ__STATE () { 383 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 384 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 385 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE () { 386 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE () { 387 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE () { 388 }
sub DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE () { 389 }
sub DEFAULT_ATTR_VALUE__SQ__STATE_CR () { 390 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE () { 391 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 392 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE () { 393 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE () { 394 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE () { 395 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE () { 396 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE () { 397 }
sub DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR () { 398 }
sub END_TAG_OPEN_STATE () { 399 }
sub IGNORED_SECTION_MDO_STATE () { 400 }
sub IGNORED_SECTION_STATE () { 401 }
sub IGNORED_SECTION_TAG_OPEN_STATE () { 402 }
sub IN_IGNORED_SECTION_MSC_STATE () { 403 }
sub IN_MSC_STATE () { 404 }
sub IN_PIC_STATE () { 405 }
sub MDO_STATE () { 406 }
sub MDO_STATE__ () { 407 }
sub MDO_STATE_D () { 408 }
sub MDO_STATE_DO () { 409 }
sub MDO_STATE_DOC () { 410 }
sub MDO_STATE_DOCT () { 411 }
sub MDO_STATE_DOCTY () { 412 }
sub MDO_STATE_DOCTYP () { 413 }
sub MDO_STATE__5B () { 414 }
sub MDO_STATE__5BC () { 415 }
sub MDO_STATE__5BCD () { 416 }
sub MDO_STATE__5BCDA () { 417 }
sub MDO_STATE__5BCDAT () { 418 }
sub MDO_STATE__5BCDATA () { 419 }
sub PE_DECL_OR_REF_AFTER_SPACE_STATE () { 420 }
sub PE_DECL_OR_REF_STATE () { 421 }
sub PE_NAME_IN_DTD_STATE () { 422 }
sub PE_NAME_IN_ENT_VALUE__DQ__STATE () { 423 }
sub PE_NAME_IN_ENT_VALUE__SQ__STATE () { 424 }
sub PE_NAME_IN_ENT_VALUE_IN_ENT_STATE () { 425 }
sub PE_NAME_IN_MARKUP_DECL_STATE () { 426 }
sub PE_NAME_IN_STATUS_KWD_STATE () { 427 }
sub SELF_CLOSING_START_TAG_STATE () { 428 }
sub TAG_NAME_STATE () { 429 }
sub TAG_OPEN_STATE () { 430 }
sub TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE () { 431 }
sub TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE_CR () { 432 }

my $OnAttrEntityReference = sub {
  my ($main, $data) = @_;
  if (($main->{entity_depth} || 0) > $main->max_entity_depth) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too deep',
                               text => $main->max_entity_depth,
                               value => '&'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } elsif ((${$main->{entity_expansion_count} || \0}) > $main->max_entity_expansions + 1) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too many refs',
                               text => $main->max_entity_expansions,
                               value => '&'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } else {
    my $sub = Web::XML::Parser::AttrEntityParser->new;
    $sub->{_sc} = $main->_sc;
    local $data->{entity}->{open} = 1;
    $sub->parse ($main, $data);
  }
}; # $OnAttrEntityReference

my $OnContentEntityReference = sub {
  my ($main, $data) = @_;
  if (($main->{entity_depth} || 0) > $main->max_entity_depth) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too deep',
                               text => $main->max_entity_depth,
                               value => '&'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } elsif ((${$main->{entity_expansion_count} || \0}) > $main->max_entity_expansions + 1) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too many refs',
                               text => $main->max_entity_expansions,
                               value => '&'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } else {
    my $sub = Web::XML::Parser::ContentEntityParser->new;
    $sub->{_sc} = $main->_sc;
    my $ops = $data->{ops};
    my $parent_cm_type = $main->{saved_lists}->{OE}->[-1]->{cm_type};
    if (defined $parent_cm_type and $parent_cm_type eq 'EMPTY') {
      $main->onerrors->($main, [{level => 'm',
                                 type => 'entity:in EMPTY',
                                 value => '&'.$data->{entity}->{name}.';',
                                 di => $data->{ref}->{di},
                                 index => $data->{ref}->{index}}]);
    }
    my $parent_id = $main->{saved_lists}->{OE}->[-1]->{id};
    my $main2 = $main;
    $sub->onparsed (sub {
      my $sub = $_[0];
      my $nodes = $sub->{nodes}->[$sub->{saved_lists}->{OE}->[0]->{id}]->child_nodes;
      push @$ops, ['append-by-list', $nodes => $parent_id];
      $data->{entity}->{open}--;
      $main2->{pause}--;
      $main2->_parse_sub_done;
      undef $main2;
    });
    $data->{entity}->{open}++;
    $main->{pause}++;
    $main->{pause}++;
    if (defined $data->{entity}->{value}) { # internal
      $sub->parse ($main, $data);
    } else { # external
      $main->onerrors->($main, [{level => 'i',
                                 type => 'external entref',
                                 value => '&'.$data->{entity}->{name}.';',
                                 di => $data->{ref}->{di},
                                 index => $data->{ref}->{index}}]);
      $main->onextentref->($main, $data, $sub);
    }
    $main->{pause}--;
  }
}; # $OnContentEntityReference

my $OnDTDEntityReference = sub {
  my ($main, $data) = @_;
  if (defined $data->{entity}->{name} and
      ($main->{entity_depth} || 0) > $main->max_entity_depth) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too deep',
                               text => $main->max_entity_depth,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } elsif (defined $data->{entity}->{name} and
           (${$main->{entity_expansion_count} || \0}) > $main->max_entity_expansions + 1) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too many refs',
                               text => $main->max_entity_expansions,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } else {
    my $sub = Web::XML::Parser::DTDEntityParser->new;
    $sub->{_sc} = $main->_sc;
    my $main2 = $main;
    $sub->onparsed (sub {
      my $sub = $_[0];
      $data->{entity}->{open}--;
      $main2->{pause}--;
      $main2->_parse_sub_done;
      undef $main2;
    });
    $data->{entity}->{open}++;
    $main->{pause}++;
    $main->{pause}++;
    if (defined $data->{entity}->{value}) { # internal
      $sub->parse ($main, $data);
    } else { # external
      $main->onerrors->($main, [{level => 'i',
                                 type => 'external entref',
                                 value => (defined $data->{entity}->{name} ? '%'.$data->{entity}->{name}.';' : undef),
                                 di => $data->{ref}->{di},
                                 index => $data->{ref}->{index}}]);
      $main->onextentref->($main, $data, $sub);
    }
    $main->{pause}--;
  }
}; # $OnDTDEntityReference

my $OnEntityValueEntityReference = sub {
  my ($main, $data) = @_;
  if (($main->{entity_depth} || 0) > $main->max_entity_depth) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too deep',
                               text => $main->max_entity_depth,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } elsif ((${$main->{entity_expansion_count} || \0}) > $main->max_entity_expansions + 1) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too many refs',
                               text => $main->max_entity_expansions,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } else {
    my $sub = Web::XML::Parser::EntityValueEntityParser->new;
    $sub->{_sc} = $main->_sc;
    my $main2 = $main;
    $sub->onparsed (sub {
      my $sub = $_[0];
      $data->{entity}->{open}--;
      $main2->{pause}--;
      $main2->_parse_sub_done;
      undef $main2;
    });
    $data->{entity}->{open}++;
    $main->{pause}++;
    $main->{pause}++;
    if (defined $data->{entity}->{value}) { # internal
      $sub->parse ($main, $data);
    } else { # external
      $main->onerrors->($main, [{level => 'i',
                                 type => 'external entref',
                                 value => '%'.$data->{entity}->{name}.';',
                                 di => $data->{ref}->{di},
                                 index => $data->{ref}->{index}}]);
      $main->onextentref->($main, $data, $sub);
    }
    $main->{pause}--;
  }
}; # $OnEntityValueEntityReference

my $OnMDEntityReference = sub {
  my ($main, $data) = @_;
  if (($main->{entity_depth} || 0) > $main->max_entity_depth) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too deep',
                               text => $main->max_entity_depth,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } elsif ((${$main->{entity_expansion_count} || \0}) > $main->max_entity_expansions + 1) {
    $main->onerrors->($main, [{level => 'm',
                               type => 'entity:too many refs',
                               text => $main->max_entity_expansions,
                               value => '%'.$data->{entity}->{name}.';',
                               di => $data->{ref}->{di},
                               index => $data->{ref}->{index}}]);
  } else {
    my $sub = Web::XML::Parser::MDEntityParser->new;
    $sub->{_sc} = $main->_sc;
    my $main2 = $main;
    $sub->onparsed (sub {
      my $sub = $_[0];
      package Web::XML::Parser;
      if ($sub->{saved_states}->{InLiteral}) {
        $main2->{saved_states}->{State} = BOGUS_MARKUP_DECL_STATE ();
        $main2->onerrors->($main2, [{level => 'm',
                                     type => 'unclosed literal',
                                     di => $sub->{saved_states}->{Token}->{di},
                                     index => $sub->{saved_states}->{Token}->{index}}]);
      } else {
        $main2->{saved_states}->{State} = $sub->{saved_states}->{State};
      }
      $main2->{saved_states}->{Attr} = $sub->{saved_states}->{Attr};

      my $sub2 = Web::XML::Parser::MDEntityParser->new;
      $sub2->onparsed (sub {
        $main2->{saved_states}->{State} = $_[0]->{saved_states}->{State};
        $main2->{saved_states}->{Attr} = $_[0]->{saved_states}->{Attr};
        if ($main2->{saved_states}->{State} == BOGUS_MARKUP_DECL_STATE) {
          #
        } elsif ($sub->{saved_states}->{InitialCMGroupDepth} < @{$sub2->{saved_lists}->{OpenCMGroups}}) {
          $main2->onerrors->($main2, [{level => 'm',
                                       type => 'unclosed cmgroup',
                                       di => $sub->{saved_states}->{Token}->{di},
                                       index => $sub->{saved_states}->{Token}->{index}}]);
          $#{$main2->{saved_lists}->{OpenCMGroups}} = $sub->{saved_states}->{InitialCMGroupDepth}-1;
        } elsif (@{$main2->{saved_lists}->{OpenCMGroups}}) {
          my $last = $sub->{saved_states}->{LastCMItem};
          if (not defined $last) {
            $main2->onerrors->($main2, [{level => 's',
                                         type => 'xml:dtd:cm:empty entity',
                                         di => $data->{ref}->{di},
                                         index => $data->{ref}->{index}}]);
          } elsif ($last eq 'separator') {
            $main2->onerrors->($main2, [{level => 's',
                                         type => 'xml:dtd:cm:entity ends with connector',
                                         di => $data->{ref}->{di},
                                         index => $data->{ref}->{index}}]);
          }
        }
      });
      {
        local $main2->{saved_states}->{OriginalState} = [$main2->{saved_states}->{State}];
        $sub2->{InitialCMGroupDepth} = $sub->{saved_states}->{InitialCMGroupDepth};
        $sub2->parse ($main2, {entity => {value => [[' ', -1, 0]], name => ''}});
      }

      $data->{entity}->{open}--;
      $main2->{pause}--;
      $main2->_parse_sub_done;
      undef $main2;
    });
    $data->{entity}->{open}++;
    $main->{pause}++;
    $main->{pause}++;
    if (defined $data->{entity}->{value}) { # internal
      $sub->parse ($main, $data);
    } else { # external
      $main->onerrors->($main, [{level => 'i',
                                 type => 'external entref',
                                 value => '%'.$data->{entity}->{name}.';',
                                 di => $data->{ref}->{di},
                                 index => $data->{ref}->{index}}]);
      $main->onextentref->($main, $data, $sub);
    }
    $main->{pause}--;
  }
}; # $OnMDEntityReference
    

      sub cant_expand_extentref ($$$) {
        my ($self, $data, $sub) = @_;
        $self->onerrors->($self, [{level => 'w',
                                   type => 'external entref not expanded',
                                   value => (defined $data->{entity}->{name} ? ($data->{entity}->{is_parameter_entity_flag} ? '%' : '&').$data->{entity}->{name}.';' : undef),
                                   di => $data->{ref}->{di},
                                   index => $data->{ref}->{index}}]);
        if (not $self->{saved_states}->{DTDDefs}->{StopProcessing} and
            not $self->{saved_states}->{DTDDefs}->{XMLStandalone}) {
          $self->onerrors->($self, [{level => 'i',
                                     type => 'stop processing',
                                     di => $data->{ref}->{di},
                                   index => $data->{ref}->{index}}])
              if defined $data->{entity}->{name} and
                 $data->{entity}->{is_parameter_entity_flag};
          $self->{saved_maps}->{DTDDefs}->{StopProcessing} = 1;
        }

        $sub->parse_bytes_start (undef, $self);
        $sub->parse_bytes_feed ('<?xml encoding="utf-8"?>');
        $sub->parse_bytes_end;
      } # cant_expand_extentref
    

my $TokenizerAbortingTagNames = {
  title => 1,
  textarea => 1,
  plaintext => 1,
  style => 1,
  script => 1,
  xmp => 1,
  iframe => 1,
  noembed => 1,
  noframes => 1,
  noscript => 1,

  #html => 1, # for <html manifest> -> see the line with "first start tag"
  #meta => 1, # for <meta charset>
};
  


sub _tokenize_attr_value ($) { # IndexedString
  my $token = $_[0];
  my @v;
  my $non_sp = 0;
  for my $v (@{$token->{value}}) {
    next unless length $v->[0];
    if ($v->[0] =~ /\x20/) {
      my $pos = $v->[2];
      for (grep { length } split /(\x20+)/, $v->[0], -1) {
        if (/\x20/) {
          push @v, [' ', $v->[1], $pos] if $non_sp;
          $non_sp = 0;
        } else {
          push @v, [$_, $v->[1], $pos];
          $non_sp = 1;
        }
        $pos += length;
      }
    } else {
      push @v, $v;
      $non_sp = 1;
    }
  } # $v
  if (@v and $v[-1]->[0] eq ' ') {
    pop @v;
  }
  return 0 if (join '', map { $_->[0] } @{$token->{value}}) eq
              (join '', map { $_->[0] } @v);
  $token->{value} = \@v;
  return 1;
} # _tokenize_attr_value

  


sub strict_checker ($;$) {
  if (@_ > 1) {
    $_[0]->{strict_checker} = $_[1];
  }
  return $_[0]->{strict_checker} || 'Web::XML::Parser::MinimumChecker';
} # strict_checker

  


sub _sc ($) {
  return $_[0]->{_sc} ||= do {
    my $sc = $_[0]->strict_checker;
    eval qq{ require $sc } or die $@;
    $sc;
  };
} # _sc

    sub _process_xml_decl ($) {
      my $token = $_[0];
      my $data = join '', map { $_->[0] } @{$token->{data}}; # IndexedString

      my $di = $token->{data}->[0]->[1];
      my $pos = $token->{data}->[0]->[2];
      for (@{$token->{data}}) {
        $di = $_->[1];
        $pos = $_->[2];
        last if length $_->[0];
      }
      my $req_sp = 0;

      if ($data =~ s/\Aversion[\x09\x0A\x20]*=[\x09\x0A\x20]*
                       (?>"([^"]*)"|'([^']*)')([\x09\x0A\x20]*)//x) {
          my $v = defined $1 ? $1 : $2;
          my $p = $pos + (defined $-[1] ? $-[1] : $-[2]);
          $pos += $+[0] - $-[0];
          $req_sp = not length $3;
          $SC->check_hidden_version
              (name => $v,
               onerror => sub {
                 push @$Errors, {@_, di => $di, index => $p};
               });
          unless (defined $CONTEXT) { # XML declaration
            push @$OP, ['xml-version', $v];
          }
      } else {
          if (not defined $CONTEXT) { # XML declaration
            push @$Errors, {level => 'm',
                            type => 'attribute missing:version',
                            di => $di, index => $pos};
          }
      }

      if ($data =~ s/\Aencoding[\x09\x0A\x20]*=[\x09\x0A\x20]*
                       (?>"([^"]*)"|'([^']*)')([\x09\x0A\x20]*)//x) {
          my $v = defined $1 ? $1 : $2;
          my $p = $pos + (defined $-[1] ? $-[1] : $-[2]);
          if ($req_sp) {
            push @$Errors, {level => 'm',
                            type => 'no space before attr name',
                            di => $di, index => $pos};
          }
          $pos += $+[0] - $-[0];
          $req_sp = not length $3;
          $SC->check_hidden_encoding
              (name => $v,
               onerror => sub {
                 push @$Errors, {@_, di => $di, index => $p};
               });
          unless (defined $CONTEXT) { # XML declaration
            push @$OP, ['xml-encoding', $v];
          }
      } else {
        if (defined $CONTEXT) { # text declaration
          push @$Errors, {level => 'm',
                          type => 'attribute missing:encoding',
                          di => $di, index => $pos};
        }
      }

      if ($data =~ s/\Astandalone[\x09\x0A\x20]*=[\x09\x0A\x20]*
                       (?>"([^"]*)"|'([^']*)')[\x09\x0A\x20]*//x) {
          my $v = defined $1 ? $1 : $2;
          if ($req_sp) {
            push @$Errors, {level => 'm',
                            type => 'no space before attr name',
                            di => $di, index => $pos};
          }
          if ($v eq 'yes' or $v eq 'no') {
            if (defined $CONTEXT) { # text declaration
              push @$Errors, {level => 'm',
                              type => 'attribute not allowed:standalone',
                              di => $di, index => $pos};
            } else {
              push @$OP, ['xml-standalone',
                          $DTDDefs->{XMLStandalone} = ($v ne 'no')];
            }
          } else {
            my $p = $pos + (defined $-[1] ? $-[1] : $-[2]);
            push @$Errors, {level => 'm',
                            type => 'XML standalone:syntax error',
                            di => $di, index => $p, value => $v};
          }
          $pos += $+[0] - $-[0];
      }

      if (length $data) {
          push @$Errors, {level => 'm',
                          type => 'bogus XML declaration',
                          di => $di, index => $pos};
      }
    } # _process_xml_decl
  
    ## ------ Tree constructor defs ------
    my $Element2Type = {};
my $ProcessIM = [];
sub TAG_NAME_BUTTON_FIELDSET_IMG_INPUT_OBJECT_OUTPUT_SELECT_TEXTAREA () { 1 }
$TagName2Group->{q@button@} = 1;
$TagName2Group->{q@fieldset@} = 1;
$TagName2Group->{q@img@} = 1;
$TagName2Group->{q@input@} = 1;
$TagName2Group->{q@object@} = 1;
$TagName2Group->{q@output@} = 1;
$TagName2Group->{q@select@} = 1;
$TagName2Group->{q@textarea@} = 1;

        ## HTML:*
        sub HTML_NS_ELS () { 1 }
      

        ## HTML:applet,HTML:audio,HTML:style,HTML:video
        sub APP_AUD_STY_VID_ELS () { 2 }
      

        ## HTML:button,HTML:fieldset,HTML:input,HTML:output,HTML:select
        sub BUT_FIE_INP_OUT_SEL_ELS () { 4 }
      

        ## HTML:img
        sub IMG_ELS () { 8 }
      

        ## HTML:object,HTML:textarea
        sub OBJ_TEX_ELS () { 16 }
      
$Element2Type->{(HTMLNS)}->{q@*@} = HTML_NS_ELS;
$Element2Type->{(HTMLNS)}->{q@applet@} = HTML_NS_ELS | APP_AUD_STY_VID_ELS;
$Element2Type->{(HTMLNS)}->{q@audio@} = HTML_NS_ELS | APP_AUD_STY_VID_ELS;
$Element2Type->{(HTMLNS)}->{q@button@} = HTML_NS_ELS | BUT_FIE_INP_OUT_SEL_ELS;
$Element2Type->{(HTMLNS)}->{q@fieldset@} = HTML_NS_ELS | BUT_FIE_INP_OUT_SEL_ELS;
sub HEAD_EL () { HTML_NS_ELS | 32 } $Element2Type->{(HTMLNS)}->{q@head@} = HEAD_EL;
sub HTML_EL () { HTML_NS_ELS | 64 } $Element2Type->{(HTMLNS)}->{q@html@} = HTML_EL;
$Element2Type->{(HTMLNS)}->{q@img@} = HTML_NS_ELS | IMG_ELS;
$Element2Type->{(HTMLNS)}->{q@input@} = HTML_NS_ELS | BUT_FIE_INP_OUT_SEL_ELS;
$Element2Type->{(HTMLNS)}->{q@object@} = HTML_NS_ELS | OBJ_TEX_ELS;
$Element2Type->{(HTMLNS)}->{q@output@} = HTML_NS_ELS | BUT_FIE_INP_OUT_SEL_ELS;
sub SELECT_EL () { HTML_NS_ELS | BUT_FIE_INP_OUT_SEL_ELS } $Element2Type->{(HTMLNS)}->{q@select@} = SELECT_EL;
$Element2Type->{(HTMLNS)}->{q@style@} = HTML_NS_ELS | APP_AUD_STY_VID_ELS;
sub TABLE_EL () { HTML_NS_ELS | 96 } $Element2Type->{(HTMLNS)}->{q@table@} = TABLE_EL;
sub TEMPLATE_EL () { HTML_NS_ELS | 128 } $Element2Type->{(HTMLNS)}->{q@template@} = TEMPLATE_EL;
$Element2Type->{(HTMLNS)}->{q@textarea@} = HTML_NS_ELS | OBJ_TEX_ELS;
$Element2Type->{(HTMLNS)}->{q@video@} = HTML_NS_ELS | APP_AUD_STY_VID_ELS;
sub AFTER_DOCTYPE_IM () { 1 }
sub AFTER_ROOT_ELEMENT_IM () { 2 }
sub BEFORE_DOCTYPE_IM () { 3 }
sub BEFORE_DTD_TEXT_DECLARATION_IM () { 4 }
sub BEFORE_XML_DECLARATION_IM () { 5 }
sub BEFORE_CONTENT_TEXT_DECLARATION_IM () { 6 }
sub BEFORE_IGNORED_NEWLINE_IM () { 7 }
sub BEFORE_ROOT_ELEMENT_IM () { 8 }
sub IN_ELEMENT_IM () { 9 }
sub IN_SUBSET_IM () { 10 }
sub IN_SUBSET_AFTER_ROOT_ELEMENT_IM () { 11 }
sub IN_SUBSET_BEFORE_ROOT_ELEMENT_IM () { 12 }
sub IN_SUBSET_IN_ELEMENT_IM () { 13 }
sub INITIAL_IM () { 14 }

      my $TCA = [undef,
        ## [1] after DOCTYPE;ATTLIST
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [2] after DOCTYPE;COMMENT
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [3] after DOCTYPE;DOCTYPE
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [4] after DOCTYPE;ELEMENT
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [5] after DOCTYPE;END-ELSE
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [6] after DOCTYPE;ENTITY
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [7] after DOCTYPE;EOD
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [8] after DOCTYPE;EOF
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [9] after DOCTYPE;NOTATION
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [10] after DOCTYPE;PI
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [11] after DOCTYPE;START-ELSE
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [12] after DOCTYPE;TEXT
        sub {
          my $token = $_;
push @$OP, ['construct-doctype'];

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [13] after root element;ATTLIST
        sub {
          
        },
      ,
        ## [14] after root element;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [15] after root element;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{has_internal_subset_flag}) {
            $DTDDefs->{StopProcessing} = 1;

          $IM = IN_SUBSET_AFTER_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |in subset after root element| ($IM)";
        
          }
        
        },
      ,
        ## [16] after root element;ELEMENT
        sub {
          
        },
      ,
        ## [17] after root element;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [18] after root element;ENTITY
        sub {
          
        },
      ,
        ## [19] after root element;EOD
        sub {
          
        },
      ,
        ## [20] after root element;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [21] after root element;NOTATION
        sub {
          
        },
      ,
        ## [22] after root element;PI
        sub {
          my $token = $_;

            push @$OP, ['pi', $token => 0];
          

          $SC->check_pi_target
              (name => $token->{target},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
        
        },
      ,
        ## [23] after root element;START-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'second root element',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [24] after root element;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'text outside of root element',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
        }
      
        },
      ,
        ## [25] before DOCTYPE;ATTLIST
        sub {
          
        },
      ,
        ## [26] before DOCTYPE;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [27] before DOCTYPE;DOCTYPE
        sub {
          my $token = $_;

        push @$OP, ['doctype', $token => 0];

        ## Public identifier normalization is intentionally not done
        ## (Chrome behavior).
        if (defined $token->{public_identifier} and
            $Web::HTML::_SyntaxDefs->{charrefs_pubids}->{$token->{public_identifier}}) {
          $DTDDefs->{has_charref_decls} = 1;
          $DTDDefs->{is_charref_declarations_entity} = 1;
        } else {
          $DTDDefs->{need_predefined_decls} = 1;

          if (defined $token->{public_identifier}) {
            $SC->check_hidden_pubid
                (name => $token->{public_identifier},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
          }
        }
      

        $DTDDefs->{system_identifier} = $token->{system_identifier};
        $DTDDefs->{di} = $token->{di};
        $DTDDefs->{index} = $token->{index};
      

          if ($token->{has_internal_subset_flag}) {
            
          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        
          } else {
            
          if (defined $DTDDefs->{system_identifier} and length $DTDDefs->{system_identifier}) {
            
        push @$Callbacks, [$OnDTDEntityReference,
                           {entity => {system_identifier => $DTDDefs->{system_identifier},
                                       base_url_di => $BaseURLDI},
                            ref => {di => $DTDDefs->{di},
                                    index => $DTDDefs->{index}}}]
            if not $DTDDefs->{is_charref_declarations_entity} and
               not $DTDDefs->{StopProcessing};
      

          $IM = AFTER_DOCTYPE_IM;
          #warn "Insertion mode changed to |after DOCTYPE| ($IM)";
        
          } else {
            
          $IM = AFTER_DOCTYPE_IM;
          #warn "Insertion mode changed to |after DOCTYPE| ($IM)";
        
          }
        
          }
        
        },
      ,
        ## [28] before DOCTYPE;ELEMENT
        sub {
          
        },
      ,
        ## [29] before DOCTYPE;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [30] before DOCTYPE;ENTITY
        sub {
          
        },
      ,
        ## [31] before DOCTYPE;EOD
        sub {
          
        },
      ,
        ## [32] before DOCTYPE;EOF
        sub {
          my $token = $_;

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [33] before DOCTYPE;NOTATION
        sub {
          
        },
      ,
        ## [34] before DOCTYPE;PI
        sub {
          my $token = $_;

            push @$OP, ['pi', $token => 0];
          

          $SC->check_pi_target
              (name => $token->{target},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
        
        },
      ,
        ## [35] before DOCTYPE;START-ELSE
        sub {
          my $token = $_;

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [36] before DOCTYPE;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'text outside of root element',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
        }
      
        },
      ,
        ## [37] before DTD text declaration;ATTLIST
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [38] before DTD text declaration;COMMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [39] before DTD text declaration;DOCTYPE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [40] before DTD text declaration;ELEMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [41] before DTD text declaration;END-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [42] before DTD text declaration;ENTITY
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [43] before DTD text declaration;EOD
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [44] before DTD text declaration;EOF
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [45] before DTD text declaration;NOTATION
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [46] before DTD text declaration;PI
        sub {
          my $token = $_;

          if ($token->{target} eq q@xml@) {
            _process_xml_decl $token;

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        
          } else {
            
        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [47] before DTD text declaration;START-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [48] before DTD text declaration;TEXT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_SUBSET_IM;
          #warn "Insertion mode changed to |in subset| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [49] before XML declaration;ATTLIST
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [50] before XML declaration;COMMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [51] before XML declaration;DOCTYPE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [52] before XML declaration;ELEMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [53] before XML declaration;END-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [54] before XML declaration;ENTITY
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [55] before XML declaration;EOD
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [56] before XML declaration;EOF
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [57] before XML declaration;NOTATION
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [58] before XML declaration;PI
        sub {
          my $token = $_;

          if ($token->{target} eq q@xml@) {
            _process_xml_decl $token;

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        
          } else {
            
        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [59] before XML declaration;START-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [60] before XML declaration;TEXT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [61] before content text declaration;ATTLIST
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [62] before content text declaration;COMMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [63] before content text declaration;DOCTYPE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [64] before content text declaration;ELEMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [65] before content text declaration;END-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [66] before content text declaration;ENTITY
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [67] before content text declaration;EOD
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [68] before content text declaration;EOF
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [69] before content text declaration;NOTATION
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [70] before content text declaration;PI
        sub {
          my $token = $_;

          if ($token->{target} eq q@xml@) {
            _process_xml_decl $token;

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        
          } else {
            
        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [71] before content text declaration;START-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [72] before content text declaration;TEXT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [73] before ignored newline;ELSE
        sub {
          
    $IM = $ORIGINAL_IM;
    goto &{$ProcessIM->[$IM]->[$_->{type}]->[$_->{tn}]};
  
        },
      ,
        ## [74] before ignored newline;TEXT
        sub {
          
    $_->{index}++ if $_->{value} =~ s/^\x0A//;
    $IM = $ORIGINAL_IM;
    goto &{$ProcessIM->[$IM]->[$_->{type}]->[0]} if length $_->{value};
  
        },
      ,
        ## [75] before root element;ATTLIST
        sub {
          
        },
      ,
        ## [76] before root element;COMMENT
        sub {
          my $token = $_;

            push @$OP, ['comment', $token => 0];
          
        },
      ,
        ## [77] before root element;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{has_internal_subset_flag}) {
            $DTDDefs->{StopProcessing} = 1;

          $IM = IN_SUBSET_BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |in subset before root element| ($IM)";
        
          }
        
        },
      ,
        ## [78] before root element;ELEMENT
        sub {
          
        },
      ,
        ## [79] before root element;END-ELSE
        sub {
          my $token = $_;
push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
        },
      ,
        ## [80] before root element;ENTITY
        sub {
          
        },
      ,
        ## [81] before root element;EOD
        sub {
          
        },
      ,
        ## [82] before root element;EOF
        sub {
          my $token = $_;
push @$Errors, {type => 'no root element',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
push @$OP, ['stop-parsing'];
        },
      ,
        ## [83] before root element;NOTATION
        sub {
          
        },
      ,
        ## [84] before root element;PI
        sub {
          my $token = $_;

            push @$OP, ['pi', $token => 0];
          

          $SC->check_pi_target
              (name => $token->{target},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
        
        },
      ,
        ## [85] before root element;START-ELSE
        sub {
          my $token = $_;

        my $nsmap = @$OE ? {%{$OE->[-1]->{nsmap}}} : {
          xml => q<http://www.w3.org/XML/1998/namespace>,
          xmlns => q<http://www.w3.org/2000/xmlns/>,
        };

        my $attrs = $token->{attrs};
        my $attrdefs = $DTDDefs->{attrdefs}->{$token->{tag_name}};
        for my $def (@{$attrdefs or []}) {
          my $attr_name = $def->{name};
          if (defined $attrs->{$attr_name}) {
            $attrs->{$attr_name}->{declared_type} = $def->{declared_type} || 0;
            if ($def->{tokenize}) {
              if (_tokenize_attr_value $attrs->{$attr_name} and
                  $def->{external} and
                  not $def->{external}->{vc_error_reported} and
                  $DTDDefs->{XMLStandalone}) {
                push @$Errors, {level => 'm',
                                type => 'VC:Standalone Document Declaration:attr',
                                di => $def->{di}, index => $def->{index},
                                value => $attr_name};
                $def->{external}->{vc_error_reported} = 1;
              }
            }
          } elsif (defined $def->{value}) {
            push @{$token->{attr_list}},
            $attrs->{$attr_name} = {
              name => $attr_name,
              value => $def->{value},
              declared_type => $def->{declared_type} || 0,
              not_specified => 1,
              di => $def->{di}, index => $def->{index},
            };

            if ($def->{external} and
                not $def->{external}->{vc_error_reported} and
                $DTDDefs->{XMLStandalone}) {
              push @$Errors, {level => 'm',
                              type => 'VC:Standalone Document Declaration:attr',
                              di => $def->{di}, index => $def->{index},
                              value => $attr_name};
              $def->{external}->{vc_error_reported} = 1;
            }
          }
        }
        
        for (keys %$attrs) {
          if (/^xmlns:./s) {
            my $prefix = substr $_, 6;
            my $value = join '', map { $_->[0] } @{$attrs->{$_}->{value}};
            if ($prefix eq 'xml' or $prefix eq 'xmlns' or
                $value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{$prefix} = $value;
            } else {
              delete $nsmap->{$prefix};
            }
          } elsif ($_ eq 'xmlns') {
            my $value = join '', map { $_->[0] } @{$attrs->{$_}->{value}};
            if ($value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{''} = $value;
            } else {
              delete $nsmap->{''};
            }
          }
        }
        
        my $ns;
        my ($prefix, $ln) = split /:/, $token->{tag_name}, 2;
        
        if (defined $ln and $prefix ne '' and $ln ne '') { # prefixed
          if (defined $nsmap->{$prefix}) {
            $ns = $nsmap->{$prefix};
          } else {
            ## NOTE: Error should be detected at the DOM layer.
            ($prefix, $ln) = (undef, $token->{tag_name});
          }
        } else {
          $ns = $nsmap->{''} if $prefix ne '' and not defined $ln;
          ($prefix, $ln) = (undef, $token->{tag_name});
        }

        my $nse = defined $ns ? $ns : '';
        my $node = {
          id => $NEXT_ID++,
          token => $token,
          di => $token->{di}, index => $token->{index},
          nsmap => $nsmap,
          ns => $ns, prefix => $prefix, local_name => $ln,
          attr_list => $token->{attr_list},
          et => $Element2Type->{($nse)}->{$ln} || $Element2Type->{($nse)}->{'*'} || 0,
          aet => $Element2Type->{($nse)}->{$ln} || $Element2Type->{($nse)}->{'*'} || 0,
          cm_type => ($DTDDefs->{elements}->{$token->{tag_name}} || {})->{cm_type},
        };
        $DTDDefs->{el_ncnames}->{$prefix} ||= $token if defined $prefix;
        $DTDDefs->{el_ncnames}->{$ln} ||= $token if defined $ln;

        my $has_attr;
        for my $attr (@{$node->{attr_list}}) {
          my $ns;
          my ($p, $l) = split /:/, $attr->{name}, 2;

          if ($attr->{name} eq 'xmlns:xmlns') {
            ($p, $l) = (undef, $attr->{name});
          } elsif (defined $l and $p ne '' and $l ne '') { # prefixed
            if (defined $nsmap->{$p}) {
              $ns = $nsmap->{$p};
            } else {
              ## NOTE: Error should be detected at the DOM-layer.
              ($p, $l) = (undef, $attr->{name});
            }
          } else {
            if ($attr->{name} eq 'xmlns') {
              $ns = $nsmap->{xmlns};
            }
            ($p, $l) = (undef, $attr->{name});
          }
          
          if ($has_attr->{defined $ns ? $ns : ''}->{$l}) {
            $ns = undef;
            ($p, $l) = (undef, $attr->{name});
          } else {
            $has_attr->{defined $ns ? $ns : ''}->{$l} = 1;
          }

          $attr->{name_args} = [$ns, [$p, $l]];
          $DTDDefs->{el_ncnames}->{$p} ||= $attr if defined $p;
          $DTDDefs->{el_ncnames}->{$l} ||= $attr if defined $l;
          if (defined $attr->{declared_type}) {
            #
          } elsif ($DTDDefs->{AllDeclsProcessed}) {
            $attr->{declared_type} = 0; # no value
          } else {
            $attr->{declared_type} = 11; # unknown
          }
        }

        if ($token->{self_closing_flag}) {
          if (defined $node->{cm_type} and not $node->{cm_type} eq 'EMPTY') {
            push @$Errors, {level => 's',
                            type => 'xml:empty element tag:non-EMPTY',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        } else {
          if (defined $node->{cm_type} and $node->{cm_type} eq 'EMPTY') {
            push @$Errors, {level => 's',
                            type => 'xml:start tag:EMPTY',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        }
      
push @$OP, ['insert', $node => 0];
push @$OE, $node;
push @$OP, ['appcache'];

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};

          $IM = AFTER_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |after root element| ($IM)";
        
          } else {
            
          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        
          }
        
        },
      ,
        ## [86] before root element;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'text outside of root element',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
        }
      
        },
      ,
        ## [87] in element;ATTLIST
        sub {
          
        },
      ,
        ## [88] in element;COMMENT
        sub {
          my $token = $_;

          push @$OP, ['comment', $token => $OE->[-1]->{id}];
        
        },
      ,
        ## [89] in element;DOCTYPE
        sub {
          my $token = $_;
push @$Errors, {type => 'doctype:bad context',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};

          if ($token->{has_internal_subset_flag}) {
            $DTDDefs->{StopProcessing} = 1;

          $IM = IN_SUBSET_IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in subset in element| ($IM)";
        
          }
        
        },
      ,
        ## [90] in element;ELEMENT
        sub {
          
        },
      ,
        ## [91] in element;END-ELSE
        sub {
          my $token = $_;
my $tag_name = length $token->{tag_name} ? $token->{tag_name} : $OE->[-1]->{token}->{tag_name};

          for my $i (reverse 0..$#$OE) {
            my $_node = $OE->[$i];
            
          if ((defined $CONTEXT) and 
($_node eq $OE->[0])) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        

          if ($tag_name eq $_node->{token}->{tag_name}) {
            
          if (not ($OE->[-1] eq $_node)) {
            push @$Errors, {type => 'not closed before ancestor end tag',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        

          if ($_node eq $OE->[0]) {
            
          $IM = AFTER_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |after root element| ($IM)";
        
          }
        
{
          my @popped;
          push @popped, pop @$OE while not ($OE->[-1] eq $_node);
          push @popped, pop @$OE;
          push @$OP, ['popped', \@popped];
        }
return;
          } else {
            
          if ($_node eq $OE->[0]) {
            push @$Errors, {type => 'stray end tag',
                                            level => 'm',
                                            value => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
return;
return;
          }
        
          }
        
          }
        
        },
      ,
        ## [92] in element;ENTITY
        sub {
          
        },
      ,
        ## [93] in element;EOD
        sub {
          
        },
      ,
        ## [94] in element;EOF
        sub {
          my $token = $_;

          if (defined $CONTEXT) {
            
          if (@$OE > 1) {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
          }
        
push @$OP, ['stop-parsing'];
          } else {
            push @$Errors, {type => 'in body:#eof',
                                            level => 'm',
                                            text => $OE->[-1]->{local_name},di => $token->{di},
                                index => $token->{index}};
push @$OP, ['stop-parsing'];
          }
        
        },
      ,
        ## [95] in element;NOTATION
        sub {
          
        },
      ,
        ## [96] in element;PI
        sub {
          my $token = $_;

          push @$OP, ['pi', $token => $OE->[-1]->{id}];
        

          $SC->check_pi_target
              (name => $token->{target},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
        
        },
      ,
        ## [97] in element;START-ELSE
        sub {
          my $token = $_;

        my $nsmap = @$OE ? {%{$OE->[-1]->{nsmap}}} : {
          xml => q<http://www.w3.org/XML/1998/namespace>,
          xmlns => q<http://www.w3.org/2000/xmlns/>,
        };

        my $attrs = $token->{attrs};
        my $attrdefs = $DTDDefs->{attrdefs}->{$token->{tag_name}};
        for my $def (@{$attrdefs or []}) {
          my $attr_name = $def->{name};
          if (defined $attrs->{$attr_name}) {
            $attrs->{$attr_name}->{declared_type} = $def->{declared_type} || 0;
            if ($def->{tokenize}) {
              if (_tokenize_attr_value $attrs->{$attr_name} and
                  $def->{external} and
                  not $def->{external}->{vc_error_reported} and
                  $DTDDefs->{XMLStandalone}) {
                push @$Errors, {level => 'm',
                                type => 'VC:Standalone Document Declaration:attr',
                                di => $def->{di}, index => $def->{index},
                                value => $attr_name};
                $def->{external}->{vc_error_reported} = 1;
              }
            }
          } elsif (defined $def->{value}) {
            push @{$token->{attr_list}},
            $attrs->{$attr_name} = {
              name => $attr_name,
              value => $def->{value},
              declared_type => $def->{declared_type} || 0,
              not_specified => 1,
              di => $def->{di}, index => $def->{index},
            };

            if ($def->{external} and
                not $def->{external}->{vc_error_reported} and
                $DTDDefs->{XMLStandalone}) {
              push @$Errors, {level => 'm',
                              type => 'VC:Standalone Document Declaration:attr',
                              di => $def->{di}, index => $def->{index},
                              value => $attr_name};
              $def->{external}->{vc_error_reported} = 1;
            }
          }
        }
        
        for (keys %$attrs) {
          if (/^xmlns:./s) {
            my $prefix = substr $_, 6;
            my $value = join '', map { $_->[0] } @{$attrs->{$_}->{value}};
            if ($prefix eq 'xml' or $prefix eq 'xmlns' or
                $value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{$prefix} = $value;
            } else {
              delete $nsmap->{$prefix};
            }
          } elsif ($_ eq 'xmlns') {
            my $value = join '', map { $_->[0] } @{$attrs->{$_}->{value}};
            if ($value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{''} = $value;
            } else {
              delete $nsmap->{''};
            }
          }
        }
        
        my $ns;
        my ($prefix, $ln) = split /:/, $token->{tag_name}, 2;
        
        if (defined $ln and $prefix ne '' and $ln ne '') { # prefixed
          if (defined $nsmap->{$prefix}) {
            $ns = $nsmap->{$prefix};
          } else {
            ## NOTE: Error should be detected at the DOM layer.
            ($prefix, $ln) = (undef, $token->{tag_name});
          }
        } else {
          $ns = $nsmap->{''} if $prefix ne '' and not defined $ln;
          ($prefix, $ln) = (undef, $token->{tag_name});
        }

        my $nse = defined $ns ? $ns : '';
        my $node = {
          id => $NEXT_ID++,
          token => $token,
          di => $token->{di}, index => $token->{index},
          nsmap => $nsmap,
          ns => $ns, prefix => $prefix, local_name => $ln,
          attr_list => $token->{attr_list},
          et => $Element2Type->{($nse)}->{$ln} || $Element2Type->{($nse)}->{'*'} || 0,
          aet => $Element2Type->{($nse)}->{$ln} || $Element2Type->{($nse)}->{'*'} || 0,
          cm_type => ($DTDDefs->{elements}->{$token->{tag_name}} || {})->{cm_type},
        };
        $DTDDefs->{el_ncnames}->{$prefix} ||= $token if defined $prefix;
        $DTDDefs->{el_ncnames}->{$ln} ||= $token if defined $ln;

        my $has_attr;
        for my $attr (@{$node->{attr_list}}) {
          my $ns;
          my ($p, $l) = split /:/, $attr->{name}, 2;

          if ($attr->{name} eq 'xmlns:xmlns') {
            ($p, $l) = (undef, $attr->{name});
          } elsif (defined $l and $p ne '' and $l ne '') { # prefixed
            if (defined $nsmap->{$p}) {
              $ns = $nsmap->{$p};
            } else {
              ## NOTE: Error should be detected at the DOM-layer.
              ($p, $l) = (undef, $attr->{name});
            }
          } else {
            if ($attr->{name} eq 'xmlns') {
              $ns = $nsmap->{xmlns};
            }
            ($p, $l) = (undef, $attr->{name});
          }
          
          if ($has_attr->{defined $ns ? $ns : ''}->{$l}) {
            $ns = undef;
            ($p, $l) = (undef, $attr->{name});
          } else {
            $has_attr->{defined $ns ? $ns : ''}->{$l} = 1;
          }

          $attr->{name_args} = [$ns, [$p, $l]];
          $DTDDefs->{el_ncnames}->{$p} ||= $attr if defined $p;
          $DTDDefs->{el_ncnames}->{$l} ||= $attr if defined $l;
          if (defined $attr->{declared_type}) {
            #
          } elsif ($DTDDefs->{AllDeclsProcessed}) {
            $attr->{declared_type} = 0; # no value
          } else {
            $attr->{declared_type} = 11; # unknown
          }
        }

        if ($token->{self_closing_flag}) {
          if (defined $node->{cm_type} and not $node->{cm_type} eq 'EMPTY') {
            push @$Errors, {level => 's',
                            type => 'xml:empty element tag:non-EMPTY',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        } else {
          if (defined $node->{cm_type} and $node->{cm_type} eq 'EMPTY') {
            push @$Errors, {level => 's',
                            type => 'xml:start tag:EMPTY',
                            text => $token->{tag_name},
                            di => $token->{di}, index => $token->{index}};
          }
        }
      
push @$OP, ['insert', $node => $OE->[-1]->{id}];
push @$OE, $node;

          if ($token->{self_closing_flag}) {
            push @$OP, ['popped', [pop @$OE]];
delete $token->{self_closing_flag};
          }
        
        },
      ,
        ## [98] in element;TEXT
        sub {
          my $token = $_;

          while (length $token->{value}) {
            if ($token->{value} =~ s/^([^\x00]+)//) {
              
            if (defined $token->{TempRef} and
                defined $OE->[-1]->{cm_type} and
                $OE->[-1]->{cm_type} eq 'element') {
              push @$Errors, {%{$token->{TempRef}},
                              level => 'm',
                              type => 'VC:Element Valid:charref in element content'};
            }
          

      push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
    
              $token->{index} += length $1;
            }
            if ($token->{value} =~ s/^([\x00]+)//) {
              
            my $value = $1;
            while ($value =~ /(.)/gs) {
              push @$Errors, {type => 'parser:NULL',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index} + $-[1]};
            }
            
          
              $token->{index} += length $1;
            }
          }
        
        },
      ,
        ## [99] in subset after root element;ATTLIST
        sub {
          return;
        },
      ,
        ## [100] in subset after root element;COMMENT
        sub {
          return;
        },
      ,
        ## [101] in subset after root element;DOCTYPE
        sub {
          return;
        },
      ,
        ## [102] in subset after root element;ELEMENT
        sub {
          return;
        },
      ,
        ## [103] in subset after root element;END-ELSE
        sub {
          return;
        },
      ,
        ## [104] in subset after root element;ENTITY
        sub {
          return;
        },
      ,
        ## [105] in subset after root element;EOD
        sub {
          
          $IM = AFTER_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |after root element| ($IM)";
        
        },
      ,
        ## [106] in subset after root element;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [107] in subset after root element;NOTATION
        sub {
          return;
        },
      ,
        ## [108] in subset after root element;PI
        sub {
          return;
        },
      ,
        ## [109] in subset after root element;START-ELSE
        sub {
          my $token = $_;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [110] in subset after root element;TEXT
        sub {
          
        },
      ,
        ## [111] in subset before root element;ATTLIST
        sub {
          return;
        },
      ,
        ## [112] in subset before root element;COMMENT
        sub {
          return;
        },
      ,
        ## [113] in subset before root element;DOCTYPE
        sub {
          return;
        },
      ,
        ## [114] in subset before root element;ELEMENT
        sub {
          return;
        },
      ,
        ## [115] in subset before root element;END-ELSE
        sub {
          return;
        },
      ,
        ## [116] in subset before root element;ENTITY
        sub {
          return;
        },
      ,
        ## [117] in subset before root element;EOD
        sub {
          
          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        
        },
      ,
        ## [118] in subset before root element;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [119] in subset before root element;NOTATION
        sub {
          return;
        },
      ,
        ## [120] in subset before root element;PI
        sub {
          return;
        },
      ,
        ## [121] in subset before root element;START-ELSE
        sub {
          my $token = $_;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [122] in subset before root element;TEXT
        sub {
          
        },
      ,
        ## [123] in subset in element;ATTLIST
        sub {
          return;
        },
      ,
        ## [124] in subset in element;COMMENT
        sub {
          return;
        },
      ,
        ## [125] in subset in element;DOCTYPE
        sub {
          return;
        },
      ,
        ## [126] in subset in element;ELEMENT
        sub {
          return;
        },
      ,
        ## [127] in subset in element;END-ELSE
        sub {
          return;
        },
      ,
        ## [128] in subset in element;ENTITY
        sub {
          return;
        },
      ,
        ## [129] in subset in element;EOD
        sub {
          
          $IM = IN_ELEMENT_IM;
          #warn "Insertion mode changed to |in element| ($IM)";
        
        },
      ,
        ## [130] in subset in element;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [131] in subset in element;NOTATION
        sub {
          return;
        },
      ,
        ## [132] in subset in element;PI
        sub {
          return;
        },
      ,
        ## [133] in subset in element;START-ELSE
        sub {
          my $token = $_;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
return;
        },
      ,
        ## [134] in subset in element;TEXT
        sub {
          
        },
      ,
        ## [135] in subset;ATTLIST
        sub {
          my $token = $_;

        if (defined $token->{name}) {
          $SC->check_hidden_name
              (name => $token->{name},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
          if ($token->{StopProcessing}) {
            push @$Errors, {level => 'w',
                            type => 'xml:dtd:attlist ignored',
                            di => $token->{di}, index => $token->{index}};
          } else { # not $StopProcessing
            push @$Errors, {level => 'w',
                            type => 'xml:dtd:ext decl',
                            di => $token->{di}, index => $token->{index}}
                unless $token->{DTDMode} eq 'internal subset'; # not in parameter entity

            if (not defined $DTDDefs->{elements}->{$token->{name}}) {
              $DTDDefs->{elements}->{$token->{name}}->{name} = $token->{name};
              $DTDDefs->{elements}->{$token->{name}}->{di} = $token->{di};
              $DTDDefs->{elements}->{$token->{name}}->{index} = $token->{index};
            } elsif ($DTDDefs->{elements}->{$token->{name}}->{has_attlist}) {
              push @$Errors, {level => 'w',
                              type => 'duplicate attlist decl',
                              value => $token->{name},
                              di => $token->{di}, index => $token->{index}};
            }
            $DTDDefs->{elements}->{$token->{name}}->{has_attlist} = 1;

            unless (@{$token->{attr_list} or []}) {
              push @$Errors, {level => 'w',
                              type => 'empty attlist decl',
                              value => $token->{name},
                              di => $token->{di}, index => $token->{index}};
            }
          } # not $StopProcessing
          
          for my $at (@{$token->{attr_list} or []}) {
            my $type = defined $at->{declared_type} ? {
              CDATA => 1, ID => 2, IDREF => 3, IDREFS => 4, ENTITY => 5,
              ENTITIES => 6, NMTOKEN => 7, NMTOKENS => 8, NOTATION => 9,
            }->{$at->{declared_type}} : 10;
            if (defined $type) {
              $at->{declared_type} = $type;
            } else {
              push @$Errors, {level => 'm',
                              type => 'unknown declared type',
                              value => $at->{declared_type},
                              di => $at->{di}, index => $at->{index}};
              $at->{declared_type} = $type = 0;
            }
            
            my $default = defined $at->{default_type} ? {
              FIXED => 1, REQUIRED => 2, IMPLIED => 3,
            }->{$at->{default_type}} : 4;
            if (defined $default) {
              $at->{default_type} = $default;
              if (defined $at->{value}) {
                if ($default == 1 or $default == 4) {
                  #
                } elsif (length $at->{value}) {
                  push @$Errors, {level => 'm',
                                  type => 'default value not allowed',
                                  di => $at->{di}, index => $at->{index}};
                }
              } else {
                if ($default == 1 or $default == 4) {
                  push @$Errors, {level => 'm',
                                  type => 'default value not provided',
                                  di => $at->{di}, index => $at->{index}};
                }
              }
            } else {
              push @$Errors, {level => 'm',
                              type => 'unknown default type',
                              value => $at->{default_type},
                              di => $at->{di}, index => $at->{index}};
              $at->{default_type} = 0;
            }
            $at->{value} = ($at->{default_type} and ($at->{default_type} == 1 or $at->{default_type} == 4))
                ? defined $at->{value} ? $at->{value} : [['', $at->{di}, $at->{index}]] : undef;

            $at->{tokenize} = (2 <= $type and $type <= 10);

            if (defined $at->{value}) {
              _tokenize_attr_value $at if $at->{tokenize};
            }

            if (not $token->{StopProcessing}) {
              if (not defined $DTDDefs->{attrdef_by_name}->{$token->{name}}->{$at->{name}}) {
                $DTDDefs->{attrdef_by_name}->{$token->{name}}->{$at->{name}} = $at;
                push @{$DTDDefs->{attrdefs}->{$token->{name}} ||= []}, $at;
                $at->{external} = {} unless $token->{DTDMode} eq 'internal subset'; # not in parameter entity
              } else {
                push @$Errors, {level => 'w',
                                type => 'duplicate attrdef',
                                value => $at->{name},
                                di => $at->{di}, index => $at->{index}};
                if ($at->{declared_type} == 10) { # ENUMERATION
                  for (@{$at->{allowed_tokens} or []}) {
                    $SC->check_hidden_nmtoken
                        (name => $_,
                         onerror => sub {
                           push @$Errors, {@_,
                                           di => $at->{di}, index => $at->{index}};
                         });
                  }
                } elsif ($at->{declared_type} == 9) { # NOTATION
                  for (@{$at->{allowed_tokens} or []}) {
                    $SC->check_hidden_name
                        (name => $_,
                         onerror => sub {
                           push @$Errors, {@_,
                                           di => $at->{di}, index => $at->{index}};
                         });
                  }
                }
              }
            } # not $StopProcessing
          } # attr_list
        }
      
        },
      ,
        ## [136] in subset;COMMENT
        sub {
          return;
        },
      ,
        ## [137] in subset;DOCTYPE
        sub {
          
        },
      ,
        ## [138] in subset;ELEMENT
        sub {
          my $token = $_;

        if (not defined $token->{name}) {
          #
        } elsif (not $DTDDefs->{elements}->{$token->{name}}->{has_element_decl}) {
          push @$Errors, {level => 'w',
                          type => 'xml:dtd:ext decl',
                          di => $token->{di}, index => $token->{index}}
              unless $token->{DTDMode} eq 'internal subset'; # not in parameter entity
          $SC->check_hidden_name
              (name => $token->{name},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
          my $def = $DTDDefs->{elements}->{$token->{name}};
          for (qw(name di index)) {
            $def->{$_} = $token->{$_};
          }
          if (defined $token->{content_keyword}) {
            if ({EMPTY => 1, ANY => 1}->{$token->{content_keyword}}) {
              $def->{cm_type} = $def->{content_keyword} = $token->{content_keyword};
            } else {
              push @$Errors, {level => 'm',
                              type => 'xml:dtd:unknown content keyword',
                              value => $token->{content_keyword},
                              di => $token->{di}, index => $token->{index}};
            }
          }
          if (defined $token->{cmgroup}) {
            CM: {
              my $root_group = $token->{cmgroup};
              if (@{$root_group->{items}} and
                  defined $root_group->{items}->[0]->{name} and
                  $root_group->{items}->[0]->{name} eq '#PCDATA') {
                my $rep = $root_group->{repetition} || '';
                if ($rep eq '+' or
                    $rep eq '?' or
                    ($rep eq '' and @{$root_group->{items}} > 1)) {
                  push @$Errors, {level => 'm',
                                  type => 'xml:dtd:cm:bad mixed repetition',
                                  value => $root_group->{repetition},
                                  di => $root_group->{di},
                                  index => $root_group->{index}};
                  $root_group->{repetition} = '*';
                }
                for (@{$root_group->{separators}}) {
                  unless ($_->{type} eq '|') {
                    push @$Errors, {level => 'm',
                                    type => 'xml:dtd:cm:bad mixed separator',
                                    value => $_->{type},
                                    di => $_->{di}, index => $_->{index}};
                    last CM;
                  }
                }
                for (0..$#{$root_group->{items}}) {
                  my $item = $root_group->{items}->[$_];
                  if (defined $item->{items}) {
                    push @$Errors, {level => 'm',
                                    type => 'xml:dtd:cm:nested mixed group',
                                    di => $item->{di}, index => $item->{index}};
                    last CM;
                  }
                  if (defined $item->{repetition}) {
                    push @$Errors, {level => 'm',
                                    type => 'xml:dtd:cm:mixed element with repetition',
                                    value => $item->{repetition},
                                    di => $item->{di}, index => $item->{index}};
                    last CM;
                  }
                  $SC->check_hidden_qname
                      (name => $item->{name},
                       onerror => sub {
                         push @$Errors, {@_, di => $item->{di}, index => $item->{index}};
                       })
                      unless $_ == 0;
                } # items
                $def->{cm_type} = 'mixed';
              } else { # element content
                my @group = ($root_group);
                while (@group) {
                  my $group = shift @group;
                  unless (@{$group->{items}}) {
                    push @$Errors, {level => 'm',
                                    type => 'xml:dtd:no group item',
                                    di => $group->{di}, index => $group->{index}};
                    last CM;
                  }
                  for my $item (@{$group->{items}}) {
                    if (defined $item->{items}) {
                      push @group, $item;
                    } else {
                      $SC->check_hidden_qname
                          (name => $item->{name},
                           onerror => sub {
                             push @$Errors, {@_, di => $item->{di}, index => $item->{index}};
                           });
                    }
                  }
                  if (@{$group->{separators}} > 1) {
                    my $sep = $group->{separators}->[0]->{type};
                    for (@{$group->{separators}}) {
                      unless ($_->{type} eq $sep) {
                        push @$Errors, {level => 'm',
                                        type => 'xml:dtd:cm:bad element separator',
                                        text => $sep,
                                        value => $_->{type},
                                        di => $_->{di}, index => $_->{index}};
                      }
                    }
                  }
                }
                $def->{cm_type} = 'element';
              }
              $def->{cmgroup} = $root_group;
            } # CM
          }
          $def->{has_element_decl} = 1;
        } else {
          push @$Errors, {level => 'm',
                          type => 'duplicate element decl',
                          value => $token->{name},
                          di => $token->{di}, index => $token->{index}};
        }
      
        },
      ,
        ## [139] in subset;END-ELSE
        sub {
          
        },
      ,
        ## [140] in subset;ENTITY
        sub {
          my $token = $_;

        if ($token->{StopProcessing}) {
          push @$Errors, {level => 'w',
                          type => 'xml:dtd:entity ignored',
                          di => $token->{di}, index => $token->{index}};
          $SC->check_hidden_name
              (name => $token->{name},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               })
              if defined $token->{name};
        } elsif (not defined $token->{name}) {
          #
        } else { # not stop processing
          if ($token->{is_parameter_entity_flag}) {
            if (not $DTDDefs->{pe}->{'%'.$token->{name} . ';'}) {
              push @$Errors, {level => 'w',
                              type => 'xml:dtd:ext decl',
                              di => $token->{di}, index => $token->{index}}
                  unless $token->{DTDMode} eq 'internal subset'; # and not in param entity
              $SC->check_hidden_name
                  (name => $token->{name},
                   onerror => sub {
                     push @$Errors, {@_,
                                     di => $token->{di}, index => $token->{index}};
                   });
              $DTDDefs->{pe}->{'%'.$token->{name} . ';'} = $token;
              $token->{base_url_di} = $BaseURLDI;
            } else {
              push @$Errors, {level => 'w',
                              type => 'duplicate entity decl',
                              value => '%'.$token->{name}.';',
                              di => $token->{di}, index => $token->{index}};
            }
          } else { # general entity
            if ({
              amp => 1, apos => 1, quot => 1, lt => 1, gt => 1,
            }->{$token->{name}}) {
              if (not defined $token->{value} or # external entity
                  not join ('', map { $_->[0] } @{$token->{value}}) =~ { # IndexedString
                    amp => qr/\A&#(?:x0*26|0*38);\z/,
                    lt => qr/\A&#(?:x0*3[Cc]|0*60);\z/,
                    gt => qr/\A(?>&#(?:x0*3[Ee]|0*62);|>)\z/,
                    quot => qr/\A(?>&#(?:x0*22|0*34);|")\z/,
                    apos => qr/\A(?>&#(?:x0*27|0*39);|')\z/,
                  }->{$token->{name}}) {
                push @$Errors, {level => 'm',
                                type => 'bad predefined entity decl',
                                value => $token->{name},
                                di => $token->{di}, index => $token->{index}};
              }

              $DTDDefs->{ge}->{'&'.$token->{name}.';'} = {
                name => $token->{name},
                value => [[{
                  amp => '&',
                  lt => '<',
                  gt => '>',
                  quot => '"',
                  apos => "'",
                }->{$token->{name}}, -1, 0]],
                only_text => 1,
                predefined => 1,
              };
            } elsif (not $DTDDefs->{ge}->{'&'.$token->{name}.';'}) {
              my $is_external = not $token->{DTDMode} eq 'internal subset'; # not in param entity
              push @$Errors, {level => 'w',
                              type => 'xml:dtd:ext decl',
                              di => $token->{di}, index => $token->{index}}
                  if $is_external;
              $SC->check_hidden_name
                  (name => $token->{name},
                   onerror => sub {
                     push @$Errors, {@_,
                                     di => $token->{di}, index => $token->{index}};
                   });

              $DTDDefs->{ge}->{'&'.$token->{name}.';'} = $token;
              if (defined $token->{value} and # IndexedString
                  do {
                    my $s = join ('', map { $_->[0] } @{$token->{value}});
                    length ($s) && not ($s =~ /[&<\x0D]/);
                  }) {
                $token->{only_text} = 1;
              }
              $token->{external} = {} if $is_external;
              $token->{base_url_di} = $BaseURLDI;
            } else {
              push @$Errors, {level => 'w',
                              type => 'duplicate entity decl',
                              value => '&'.$token->{name}.';',
                              di => $token->{di}, index => $token->{index}};
            }
          }

          if (defined $token->{public_identifier}) {
            $SC->check_hidden_pubid
                (name => $token->{public_identifier},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
          }
          if (defined $token->{system_identifier}) {
            $SC->check_hidden_sysid
                (name => $token->{system_identifier},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
          }
          if (defined $token->{notation_name}) {
            $SC->check_hidden_name
                (name => $token->{notation_name},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
            if ($token->{is_parameter_entity_flag}) {
              push @$Errors, {level => 'm',
                              type => 'xml:dtd:param entity with ndata',
                              value => '%'.$token->{name}.';',
                              di => $token->{di}, index => $token->{index}};
              delete $token->{notation_name};
            }
          }
        } # not stop processing
      
        },
      ,
        ## [141] in subset;EOD
        sub {
          
          if (defined $DTDDefs->{system_identifier} and length $DTDDefs->{system_identifier}) {
            
        push @$Callbacks, [$OnDTDEntityReference,
                           {entity => {system_identifier => $DTDDefs->{system_identifier},
                                       base_url_di => $BaseURLDI},
                            ref => {di => $DTDDefs->{di},
                                    index => $DTDDefs->{index}}}]
            if not $DTDDefs->{is_charref_declarations_entity} and
               not $DTDDefs->{StopProcessing};
      
          }
        

          $IM = AFTER_DOCTYPE_IM;
          #warn "Insertion mode changed to |after DOCTYPE| ($IM)";
        
        },
      ,
        ## [142] in subset;EOF
        sub {
          push @$OP, ['stop-parsing'];
        },
      ,
        ## [143] in subset;NOTATION
        sub {
          my $token = $_;

        if (defined $token->{name}) {
          if (defined $DTDDefs->{notations}->{$token->{name}}) {
            push @$Errors, {level => 'm',
                            type => 'duplicate notation decl',
                            value => $token->{name},
                            di => $token->{di}, index => $token->{index}};
          } else {
            push @$Errors, {level => 'w',
                            type => 'xml:dtd:ext decl',
                            di => $token->{di}, index => $token->{index}}
                unless $token->{DTDMode} eq 'internal subset'; # not in param entity
            $SC->check_hidden_name
                (name => $token->{name},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
            $token->{base_url_di} = $BaseURLDI;
            $DTDDefs->{notations}->{$token->{name}} = $token;
          }
          if (defined $token->{public_identifier}) {
            $SC->check_hidden_pubid
                (name => $token->{public_identifier},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
          }
          if (defined $token->{system_identifier}) {
            $SC->check_hidden_sysid
                (name => $token->{system_identifier},
                 onerror => sub {
                   push @$Errors, {@_,
                                   di => $token->{di}, index => $token->{index}};
                 });
          }
        }
      
        },
      ,
        ## [144] in subset;PI
        sub {
          my $token = $_;

            push @$OP, ['pi', $token => 1];
            push @$Errors, {level => 'w',
                            type => 'xml:dtd:pi',
                            di => $token->{di}, index => $token->{index}};
          

          $SC->check_pi_target
              (name => $token->{target},
               onerror => sub {
                 push @$Errors, {@_, di => $token->{di}, index => $token->{index}};
               });
        
        },
      ,
        ## [145] in subset;START-ELSE
        sub {
          my $token = $_;

          if ($token->{self_closing_flag}) {
            push @$Errors, {type => 'nestc',
                                            level => 'm',
                                            text => $token->{tag_name},di => $token->{di},
                                index => $token->{index}};
          }
        
        },
      ,
        ## [146] in subset;TEXT
        sub {
          my $token = $_;

        if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          
          $token->{index} += length $1;
        }
        if (length $token->{value}) {
          push @$Errors, {type => 'string in internal subset',
                                            level => 'm',
                                            di => $token->{di},
                                index => $token->{index}};
        }
      
        },
      ,
        ## [147] initial;ATTLIST
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [148] initial;COMMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [149] initial;DOCTYPE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [150] initial;ELEMENT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [151] initial;END-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [152] initial;ENTITY
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [153] initial;EOD
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [154] initial;EOF
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [155] initial;NOTATION
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [156] initial;PI
        sub {
          my $token = $_;

          if ($token->{target} eq q@xml@) {
            _process_xml_decl $token;

          $IM = BEFORE_ROOT_ELEMENT_IM;
          #warn "Insertion mode changed to |before root element| ($IM)";
        
          } else {
            
        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
          }
        
        },
      ,
        ## [157] initial;START-ELSE
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ,
        ## [158] initial;TEXT
        sub {
          my $token = $_;

        push @$Errors, {level => 's',
                        type => 'no XML decl',
                        di => $token->{di}, index => 0};
      

          $IM = BEFORE_DOCTYPE_IM;
          #warn "Insertion mode changed to |before DOCTYPE| ($IM)";
        

        goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      
        },
      ];
    
$ProcessIM = [undef,
[undef, [$TCA->[1]], [$TCA->[3]], [$TCA->[4]], [$TCA->[6]], [$TCA->[9]], [$TCA->[2]], [$TCA->[5], $TCA->[5]], [$TCA->[7]], [$TCA->[8]], [$TCA->[10]], [$TCA->[11], $TCA->[11]], [$TCA->[12]]],
[undef, [$TCA->[13]], [$TCA->[15]], [$TCA->[16]], [$TCA->[18]], [$TCA->[21]], [$TCA->[14]], [$TCA->[17], $TCA->[17]], [$TCA->[19]], [$TCA->[20]], [$TCA->[22]], [$TCA->[23], $TCA->[23]], [$TCA->[24]]],
[undef, [$TCA->[25]], [$TCA->[27]], [$TCA->[28]], [$TCA->[30]], [$TCA->[33]], [$TCA->[26]], [$TCA->[29], $TCA->[29]], [$TCA->[31]], [$TCA->[32]], [$TCA->[34]], [$TCA->[35], $TCA->[35]], [$TCA->[36]]],
[undef, [$TCA->[37]], [$TCA->[39]], [$TCA->[40]], [$TCA->[42]], [$TCA->[45]], [$TCA->[38]], [$TCA->[41], $TCA->[41]], [$TCA->[43]], [$TCA->[44]], [$TCA->[46]], [$TCA->[47], $TCA->[47]], [$TCA->[48]]],
[undef, [$TCA->[49]], [$TCA->[51]], [$TCA->[52]], [$TCA->[54]], [$TCA->[57]], [$TCA->[50]], [$TCA->[53], $TCA->[53]], [$TCA->[55]], [$TCA->[56]], [$TCA->[58]], [$TCA->[59], $TCA->[59]], [$TCA->[60]]],
[undef, [$TCA->[61]], [$TCA->[63]], [$TCA->[64]], [$TCA->[66]], [$TCA->[69]], [$TCA->[62]], [$TCA->[65], $TCA->[65]], [$TCA->[67]], [$TCA->[68]], [$TCA->[70]], [$TCA->[71], $TCA->[71]], [$TCA->[72]]],
[undef, [$TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73], $TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73]], [$TCA->[73], $TCA->[73]], [$TCA->[74]]],
[undef, [$TCA->[75]], [$TCA->[77]], [$TCA->[78]], [$TCA->[80]], [$TCA->[83]], [$TCA->[76]], [$TCA->[79], $TCA->[79]], [$TCA->[81]], [$TCA->[82]], [$TCA->[84]], [$TCA->[85], $TCA->[85]], [$TCA->[86]]],
[undef, [$TCA->[87]], [$TCA->[89]], [$TCA->[90]], [$TCA->[92]], [$TCA->[95]], [$TCA->[88]], [$TCA->[91], $TCA->[91]], [$TCA->[93]], [$TCA->[94]], [$TCA->[96]], [$TCA->[97], $TCA->[97]], [$TCA->[98]]],
[undef, [$TCA->[135]], [$TCA->[137]], [$TCA->[138]], [$TCA->[140]], [$TCA->[143]], [$TCA->[136]], [$TCA->[139], $TCA->[139]], [$TCA->[141]], [$TCA->[142]], [$TCA->[144]], [$TCA->[145], $TCA->[145]], [$TCA->[146]]],
[undef, [$TCA->[99]], [$TCA->[101]], [$TCA->[102]], [$TCA->[104]], [$TCA->[107]], [$TCA->[100]], [$TCA->[103], $TCA->[103]], [$TCA->[105]], [$TCA->[106]], [$TCA->[108]], [$TCA->[109], $TCA->[109]], [$TCA->[110]]],
[undef, [$TCA->[111]], [$TCA->[113]], [$TCA->[114]], [$TCA->[116]], [$TCA->[119]], [$TCA->[112]], [$TCA->[115], $TCA->[115]], [$TCA->[117]], [$TCA->[118]], [$TCA->[120]], [$TCA->[121], $TCA->[121]], [$TCA->[122]]],
[undef, [$TCA->[123]], [$TCA->[125]], [$TCA->[126]], [$TCA->[128]], [$TCA->[131]], [$TCA->[124]], [$TCA->[127], $TCA->[127]], [$TCA->[129]], [$TCA->[130]], [$TCA->[132]], [$TCA->[133], $TCA->[133]], [$TCA->[134]]],
[undef, [$TCA->[147]], [$TCA->[149]], [$TCA->[150]], [$TCA->[152]], [$TCA->[155]], [$TCA->[148]], [$TCA->[151], $TCA->[151]], [$TCA->[153]], [$TCA->[154]], [$TCA->[156]], [$TCA->[157], $TCA->[157]], [$TCA->[158]]]];
my $ResetIMByET = {};
my $ResetIMByETUnlessLast = {};my $StateByElementName = {};

    ## ------ Input byte stream ------
    

## ------ Character encoding processing ------

sub locale_tag ($;$) {
  if (@_ > 1) {
    $_[0]->{locale_tag} = $_[1];
    $_[0]->{locale_tag} =~ tr/A-Z/a-z/ if defined $_[0]->{locale_tag};
  }
  return $_[0]->{locale_tag};
} # locale_tag

sub known_definite_encoding ($;$) {
  if (@_ > 1) {
    $_[0]->{known_definite_encoding} = $_[1];
  }
  return $_[0]->{known_definite_encoding};
} # known_definite_encoding

## Encoding sniffing algorithm
## <http://www.whatwg.org/specs/web-apps/current-work/#determining-the-character-encoding>.
sub _encoding_sniffing ($;%) {
  my ($self, %args) = @_;

  ## One of followings:
  ##   - Step 1. User-specified encoding
  ##   - The new character encoding by change the encoding
  ##     <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>
  ##     step 5. Encoding from <meta charset>
  ##   - A known definite encoding
  my $kde = $self->known_definite_encoding;
  if (defined $kde) {
    ## If specified, it must be an encoding label from the Encoding
    ## Standard.
    my $name = Web::Encoding::encoding_label_to_name $kde;
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 1; # certain
      return;
    }
  }

  return if $args{no_body_data_yet};
  ## $args{no_body_data_yet} flag must be set to true if the body of
  ## the resource is not available to the parser such that
  ## $args{read_head} callback ought not be invoked yet.

  ## Step 2. Wait 500ms or 1024 bytes, whichever came first (See
  ## Web::HTML::Parser for how and when to use this callback).
  my $head = $args{read_head} ? $args{read_head}->() : undef;
  ## $args{read_head} must be a callback which, when invoked, returns
  ## a byte string used to sniff the character encoding of the input
  ## stream.  As described in the HTML Standard, it should be at most
  ## 1024 bytes.  The callback should not invoke sync I/O.  This
  ## method should be invoked with $args{no_body_data_yet} flag unset
  ## only after 500ms has past or 1024 bytes has been received.  The
  ## callback should not invoke any exception.

  ## Step 3. BOM
  ## XXX Now this step is part of "decode" in the specs
  if (defined $head) {
    if ($$head =~ /^\xFE\xFF/) {
      $self->{input_encoding} = 'utf-16be';
      $Confident = 1; # certain
      return;
    } elsif ($$head =~ /^\xFF\xFE/) {
      $self->{input_encoding} = 'utf-16le';
      $Confident = 1; # certain
      return;
    } elsif ($$head =~ /^\xEF\xBB\xBF/) {
      $self->{input_encoding} = 'utf-8';
      $Confident = 1; # certain
      return;
    }
  }

  ## Step 4. Transport-layer encoding
  if ($args{transport_encoding_name}) {
    ## $args{transport_encoding_name} must be specified iff the
    ## underlying protocol provides the character encoding for the
    ## input stream.  For HTTP, the |charset=""| parameter in the
    ## |Content-Type:| header specifies the character encoding.  The
    ## value is interpreted as an encoding name or alias defined in
    ## the Encoding Standard.  (Invalid encoding name will be
    ## ignored.)
    my $name = Web::Encoding::encoding_label_to_name $args{transport_encoding_name};
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 1; # certain
      return;
    }
  }

  ## Step 5. <meta charset>
  if (defined $head) {
    my $name = $self->_prescan_byte_stream ($$head);
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 6. Parent browsing context
  if ($args{parent_document}) {
    ## $args{parent_document}, if specified, must be the |Document|
    ## through which the new (to be parsed) document is nested, or the
    ## active document of the parent browsing context of the new
    ## document.

    # XXX
    # if $args{parent_document}->origin equals $self->document->origin and
    #    $args{parent_document}->charset is ASCII compatible {
    #   $self->{input_encoding} = $args{parent_document}->charset;
    #   $Confident = 0; # tentative
    #   return;
    # }
  }

  ## Step 7. History
  if ($args{get_history_encoding_name}) {
    ## EXPERIMENTAL: $args{get_history_encoding_name}, if specified,
    ## must be a callback which returns the canonical character
    ## encoding name for the input stream, guessed by e.g. last visit
    ## to this page.
    # XXX how to handle async access to history DB?
    my $name = Web::Encoding::encoding_label_to_name $args{get_history_encoding_name}->();
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. UniversalCharDet
  if (defined $head) {
    require Web::Encoding::UnivCharDet;
    my $det = Web::Encoding::UnivCharDet->new;
    # XXX locale-dependent configuration
    my $name = Web::Encoding::encoding_label_to_name $det->detect_byte_string ($$head);
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. Locale-dependent default
  my $locale = $self->locale_tag;
  if ($locale) {
    my $name = Web::Encoding::encoding_label_to_name (
        Web::Encoding::locale_default_encoding_name $locale ||
        Web::Encoding::locale_default_encoding_name [split /-/, $locale, 2]->[0]
    );
    if ($name) {
      $self->{input_encoding} = $name;
      $Confident = 0; # tentative
      return;
    }
  }

  ## Step 8. Default of default
  $self->{input_encoding} = Web::Encoding::encoding_label_to_name 'windows-1252';
  $Confident = 0; # tentative
  return;

  # XXX expose sniffing info for validator
} # _encoding_sniffing

# prescan a byte stream to determine its encoding
# <http://www.whatwg.org/specs/web-apps/current-work/#prescan-a-byte-stream-to-determine-its-encoding>
sub _prescan_byte_stream ($$) {
  # 1.
  (pos $_[1]) = 0;

  # 2.
  LOOP: {
    $_[1] =~ /\G<!--+>/gc;
    $_[1] =~ /\G<!--.*?-->/gcs;
    if ($_[1] =~ /\G<[Mm][Ee][Tt][Aa](?=[\x09\x0A\x0C\x0D\x20\x2F])/gc) {
      # 1.
      #

      # 2.-5.
      my $attr_list = {};
      my $got_pragma = 0;
      my $need_pragma = undef;
      my $charset;

      # 6.
      ATTRS: {
        my $attr = $_[0]->_get_attr ($_[1]) or last ATTRS;

        # 7.
        redo ATTRS if $attr_list->{$attr->{name}};
        
        # 8.
        $attr_list->{$attr->{name}} = $attr;

        # 9.
        if ($attr->{name} eq 'http-equiv') {
          $got_pragma = 1 if $attr->{value} eq 'content-type';
        } elsif ($attr->{name} eq 'content') {
          # algorithm for extracting a character encoding from a
          # |meta| element
          # <http://www.whatwg.org/specs/web-apps/current-work/#algorithm-for-extracting-a-character-encoding-from-a-meta-element>
          if (not defined $charset and
              $attr->{value} =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                                 [\x09\x0A\x0C\x0D\x20]*=
                                 [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                                 ([^"'\x09\x0A\x0C\x0D\x20]
                                  [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
            $charset = Web::Encoding::encoding_label_to_name
                (defined $1 ? $1 : defined $2 ? $2 : $3);
            $need_pragma = 1;
          }
        } elsif ($attr->{name} eq 'charset') {
          $charset = Web::Encoding::encoding_label_to_name $attr->{value};
          $need_pragma = 0;
        }

        # 10.
        return undef if pos $_[1] >= length $_[1];
        redo ATTRS;
      } # ATTRS

      # 11. Processing, 12.
      if (not defined $need_pragma or
          ($need_pragma and not $got_pragma)) {
        #
      } elsif (defined $charset) {
        # 13.-14.
        $charset = Web::Encoding::fixup_html_meta_encoding_name $charset;

        # 15.-16.
        return $charset if defined $charset;
      }
    } elsif ($_[1] =~ m{\G</?[A-Za-z][^\x09\x0A\x0C\x0D\x20>]*}gc) {
      {
        $_[0]->_get_attr ($_[1]) and redo;
      }
    } elsif ($_[1] =~ m{\G<[!/?][^>]*}gc) {
      #
    }

    # 3. Next byte
    $_[1] =~ /\G[^<]+/gc || $_[1] =~ /\G</gc;
    return undef if pos $_[1] >= length $_[1];
    redo LOOP;
  } # LOOP
} # _prescan_byte_stream

# get an attribute
# <http://www.whatwg.org/specs/web-apps/current-work/#concept-get-attributes-when-sniffing>
sub _get_attr ($$) {
  # 1.
  $_[1] =~ /\G[\x09\x0A\x0C\x0D\x20\x2F]+/gc;

  # 2.
  if ($_[1] =~ /\G>/gc) {
    pos ($_[1])--;
    return undef;
  }
  
  # 3.
  my $attr = {name => '', value => ''};

  # 4.-5.
  if ($_[1] =~ m{\G([^\x09\x0A\x0C\x0D\x20/>][^\x09\x0A\x0C\x0D\x20/>=]*)}gc) {
    $attr->{name} .= $1;
    $attr->{name} =~ tr/A-Z/a-z/;
  }
  return undef if $_[1] =~ m{\G\z}gc;
  return $attr if $_[1] =~ m{\G(?=[/>])}gc;

  # 6.
  $_[1] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;

  # 7.-8.
  return $attr unless $_[1] =~ m{\G=}gc;

  # 9.
  $_[1] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;

  # 10.-12.
  if ($_[1] =~ m{\G\x22([^\x22]*)\x22}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  } elsif ($_[1] =~ m{\G\x27([^\x27]*)\x27}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  } elsif ($_[1] =~ m{\G([^\x09\x0A\x0C\x0D\x20>]+)}gc) {
    $attr->{value} .= $1;
    $attr->{value} =~ tr/A-Z/a-z/;
  }
  return undef if $_[1] =~ m{\G\z}gc;
  return $attr;
} # _get_attr

sub _change_the_encoding ($$$) {
  my ($self, $name, $attr) = @_;

  ## "meta" start tag
  ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inhead>.

  ## "meta". Confidence is /tentative/
  #return undef if $Confident; # certain or irrelevant

  $name = Web::Encoding::encoding_label_to_name $name;
  unless (defined $name) {
    ## "meta". Supported encoding
    return undef;
  }

  ## "meta". ASCII-compatible or UTF-16
  ## All encodings in Encoding Standard are ASCII-compatible or UTF-16.

  ## Change the encoding
  ## <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>.

  ## Step 1. UTF-16
  if (Web::Encoding::is_utf16_encoding_key $self->{input_encoding}) {
    $Confident = 1; # certain
    return undef;
  }

  ## Step 2.-3.
  $name = Web::Encoding::fixup_html_meta_encoding_name $name;
  
  ## Step 4. Same
  if ($name eq $self->{input_encoding}) {
    $Confident = 1; # certain
    return undef;
  }

  push @$Errors, {type => 'charset label detected',
                  text => $self->{input_encoding},
                  value => $name,
                  level => 'i',
                  di => $attr->{di}, index => $attr->{index}};

  ## Step 5. Change the encoding on the fly
  ## Not implemented.

  ## Step 6. Navigate with replace.
  return $name; # change!

#XXX move this to somewhere else (when callback can't handle restart)
  ## Step 6. If can't restart
  $Confident = 1; # certain
  return undef;
} # _change_the_encoding

    sub di_data_set ($;$) {
      if (@_ > 1) {
        $_[0]->{di_data_set} = $_[1];
      }
      return $_[0]->{di_data_set} ||= [];
    } # di_data_set

    sub di ($;$) {
      if (@_ > 1) {
        $_[0]->{di} = $_[1];
      }
      return $_[0]->{di}; # or undef
    } # di

  
    ## ------ Tokenizer ------
    
    my $StateActions = [];
    $StateActions->[ATTLIST_ATTR_DEFAULT_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\>\"\']+)/gcs) {
$Attr->{q<default_type>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_DEFAULT_STATE, A_ATTLIST_ATTR_DEFAULT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTLIST_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\ \(\>]+)/gcs) {
$Attr->{q<name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_NAME_STATE, A_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr type', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTLIST_ATTR_TYPE_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\"\#\'\(\>]+)/gcs) {
$Attr->{q<declared_type>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ATTLIST_ATTR_TYPE_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_TYPE_STATE, A_ATTLIST_ATTR_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTLIST_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\>\ ]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_ATTR_NAME_STATE, B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTLIST_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        $Token = {type => ATTLIST_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = B_ATTLIST_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        $Token = {type => ATTLIST_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_NAME_STATE, B_ATTLIST_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ATTLIST_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ATTLIST_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ATTLIST_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = ATTLIST_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_BRACKET_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_END_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
        
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - 1};
        
$State = CDATA_SECTION_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_END_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        
} elsif ($Input =~ /\G(.)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
        
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@]]@,
                          di => $DI, index => $Offset + (pos $Input) - 2};
        
$State = CDATA_SECTION_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_STATE] = sub {
if ($Input =~ /\G([^\\]]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_BRACKET_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CDATA_SECTION_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = CDATA_SECTION_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = CDATA_SECTION_STATE_CR;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = CDATA_SECTION_BRACKET_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = CDATA_SECTION_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = CDATA_SECTION_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PI_DATA_STATE] = sub {
if ($Input =~ /\G([^\\?\ ]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PI_DATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_PI_DATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PI_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => PROCESSING_INSTRUCTION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<target>} = q@@;
$Token->{q<data>} = [['', $DI, $Offset + (pos $Input) - 1]];
$State = DOCTYPE_PI_TARGET_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => PROCESSING_INSTRUCTION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<target>} = $1;
$Token->{q<data>} = [['', $DI, $Offset + (pos $Input) - 1]];
$State = DOCTYPE_PI_TARGET_STATE;
} else {
if ($EOF) {

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input)]];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PI_TARGET_QUESTION_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = DOCTYPE_PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = DOCTYPE_IN_PIC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = DOCTYPE_PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input)]];
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PI_TARGET_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\?\ ]+)/gcs) {
$Token->{q<target>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
$State = DOCTYPE_AFTER_PI_TARGET_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
} elsif ($Input =~ /\G([\])/gcs) {
$Temp = q@
@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DOCTYPE_AFTER_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_PI_TARGET_QUESTION_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<target>} .= q@@;
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_AFTER_PI_TARGET_STATE] = sub {
if ($Input =~ /\G([\	\\ \
]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = DOCTYPE_AFTER_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_AFTER_PI_TARGET_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = DOCTYPE_AFTER_PI_TARGET_STATE;
$Temp .= $1;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_AFTER_PI_TARGET_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = DOCTYPE_AFTER_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_BOGUS_COMMENT_STATE] = sub {
if ($Input =~ /\G([^\ \\>]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
push @$Tokens, $Token;
$State = DTD_STATE;
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_BOGUS_COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_END_BANG_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = DOCTYPE_COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_COMMENT_STATE;
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_END_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = DOCTYPE_COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_COMMENT_STATE;
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_END_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DOCTYPE_COMMENT_END_BANG_STATE;
} elsif ($Input =~ /\G([\-])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_COMMENT_STATE;
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_START_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = DOCTYPE_COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_COMMENT_STATE;
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_START_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = DOCTYPE_COMMENT_START_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = DOCTYPE_COMMENT_STATE;
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_STATE] = sub {
if ($Input =~ /\G([^\\-\ ]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = DOCTYPE_COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = DOCTYPE_COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_COMMENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = DTD_STATE;
push @$Tokens, $Token;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_IN_PIC_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DTD_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\?])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = DOCTYPE_PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = DOCTYPE_PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - 2];
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE] = sub {
if ($Input =~ /\G([\-])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE__;
} elsif ($Input =~ /\G([A])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_A;
} elsif ($Input =~ /\G([E])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_E;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_N;
} elsif ($Input =~ /\G([a])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_A;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_E;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = DOCTYPE_MDO_STATE_N;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = DOCTYPE_BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[q@@, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

          unless ($DTDMode eq 'internal subset' or
                  $DTDMode eq 'parameter entity in internal subset') {
            $State = A_MSS_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'condsect in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = DOCTYPE_BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE__] = sub {
if ($Input =~ /\G([\-])/gcs) {

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = DOCTYPE_COMMENT_START_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_A] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_AT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_AT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_AT] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ATT] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTL;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ATTL] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTLI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTLI;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ATTLI] = sub {
if ($Input =~ /\G([S])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTLIS;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ATTLIS;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ATTLIS] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G([T])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ATTLIST}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = ATTLIST_STATE;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ATTLIST}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = ATTLIST_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_E] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_EL;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_EN;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_EL;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_EN;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_EL] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ELE] = sub {
if ($Input =~ /\G([M])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEM;
} elsif ($Input =~ /\G([m])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEM;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ELEM] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEME;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEME;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ELEME] = sub {
if ($Input =~ /\G([N])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEMEN;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ELEMEN;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ELEMEN] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G([T])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ELEMENT}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = ELEMENT_STATE;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ELEMENT}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = ELEMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_EN] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ENT] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENTI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENTI;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ENTI] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENTIT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_ENTIT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_ENTIT] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ENTITY}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = ENT_STATE;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{ENTITY}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = ENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_N] = sub {
if ($Input =~ /\G([O])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NO;
} elsif ($Input =~ /\G([o])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NO;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NO] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NOT] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTA;
} elsif ($Input =~ /\G([a])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTA;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NOTA] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTAT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTAT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NOTAT] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTATI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTATI;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NOTATI] = sub {
if ($Input =~ /\G([O])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTATIO;
} elsif ($Input =~ /\G([o])/gcs) {
$Temp .= $1;
$State = DOCTYPE_MDO_STATE_NOTATIO;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_MDO_STATE_NOTATIO] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{NOTATION}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 7};
            }
          
$State = NOTATION_STATE;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{NOTATION}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 7};
            }
          
$State = NOTATION_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = DOCTYPE_BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\>ABCDEFGHJKQVWZILMNOPRSTUXY\[\ ]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Token->{q<name>} .= $1;
} elsif ($Input =~ /\G([\[])/gcs) {
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\ \>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\\'\ \>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = q@@;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\>\ ]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\>]+)/gcs) {
$Token->{q<system_identifier>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\\'\>\ ]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\>]+)/gcs) {
$Token->{q<system_identifier>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G(.)/gcs) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DOCTYPE_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\!])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = DOCTYPE_MDO_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = DOCTYPE_PI_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = DOCTYPE_BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[q@@, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = DOCTYPE_BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = DOCTYPE_BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} else {
if ($EOF) {
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DTD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_DTD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = DOCTYPE_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = A_DOCTYPE_INTERNAL_SUBSET_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} else {
if ($EOF) {

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ELEMENT_CONTENT_KWD_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\>]+)/gcs) {
$Token->{q<content_keyword>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ELEMENT_CONTENT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ELEMENT_CONTENT_STATE, A_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ELEMENT_NAME_STATE] = sub {
if ($Input =~ /\G([^\ \	\\ \
\\%\(\>]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ELEMENT_CONTENT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_CONTENT_STATE, B_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
my $cmgroup = {items => [], separators => [], di => $DI, index => $Offset + (pos $Input) - 1};
$Token->{cmgroup} = $cmgroup;
@$OpenCMGroups = ($cmgroup);
$State = B_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ELEMENT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        $Token = {type => ELEMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = B_ELEMENT_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        $Token = {type => ELEMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_NAME_STATE, B_ELEMENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ELEMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ELEMENT_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ELEMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = ELEMENT_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_NAME_STATE] = sub {
if ($Input =~ /\G([^\ \	\\ \
\\%\"\'\>]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ENT_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_NAME_STATE, A_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_VALUE__DQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_VALUE__SQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_PUBLIC_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\ \\"\>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = ENT_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_PUBLIC_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = ENT_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ENT_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = ENT_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = ENT_PUBLIC_ID__DQ__STATE;
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = ENT_PUBLIC_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_PUBLIC_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\ \\'\>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = ENT_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_PUBLIC_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = ENT_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ENT_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = ENT_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = ENT_PUBLIC_ID__SQ__STATE;
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = ENT_PUBLIC_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        $Token = {type => ENTITY_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = B_ENT_TYPE_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        $Token = {type => ENTITY_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = PE_DECL_OR_REF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ENTITY_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = q@@;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => ENTITY_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_SYSTEM_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\ \\"]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = ENT_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_SYSTEM_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_SYSTEM_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = ENT_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = ENT_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = ENT_SYSTEM_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_SYSTEM_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\ \\']+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = ENT_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_SYSTEM_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_SYSTEM_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = ENT_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = ENT_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = ENT_SYSTEM_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE] = sub {
if ($Input =~ /\G([^\\"\%\&\ ]+)/gcs) {
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^0123456789\;ABCDEFGHJKQVWZILMNOPRSTUXYabcdefghjkqvwzilmnoprstuxy\	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        $DTDDefs->{entity_names_in_entity_values}->{$Temp}
            ||= {di => $DI, index => $TempIndex};
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([abcdefghjkqvwzilmnoprstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ENT_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ENT_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = ENT_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE] = sub {
if ($Input =~ /\G([^\\%\&\'\ ]+)/gcs) {
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^0123456789\;ABCDEFGHJKQVWZILMNOPRSTUXYabcdefghjkqvwzilmnoprstuxy\	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        $DTDDefs->{entity_names_in_entity_values}->{$Temp}
            ||= {di => $DI, index => $TempIndex};
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([abcdefghjkqvwzilmnoprstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ENT_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ENT_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = ENT_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([^\\%\&\ ]+)/gcs) {
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^0123456789\;ABCDEFGHJKQVWZILMNOPRSTUXYabcdefghjkqvwzilmnoprstuxy\	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        $DTDDefs->{entity_names_in_entity_values}->{$Temp}
            ||= {di => $DI, index => $TempIndex};
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([abcdefghjkqvwzilmnoprstuxy]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ENT_VALUE_IN_ENT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NDATA_ID_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\%\>\ ]+)/gcs) {
$Token->{q<notation_name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_PARAMETER_STATE, A_ENT_PARAMETER_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<notation_name>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_NAME_STATE] = sub {
if ($Input =~ /\G([^\ \	\\ \
\\%\>]+)/gcs) {
$Token->{q<name>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_NOTATION_NAME_STATE, A_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_PUBLIC_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\ \\"\>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = NOTATION_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_PUBLIC_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = NOTATION_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = NOTATION_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = NOTATION_PUBLIC_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = NOTATION_PUBLIC_ID__DQ__STATE;
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$State = NOTATION_PUBLIC_ID__DQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = NOTATION_PUBLIC_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_PUBLIC_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\ \\'\>]+)/gcs) {
$Token->{q<public_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = NOTATION_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_PUBLIC_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = NOTATION_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = NOTATION_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<public_identifier>} .= q@
@;
$State = NOTATION_PUBLIC_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = NOTATION_PUBLIC_ID__SQ__STATE;
undef $InLiteral;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'parser:literal not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$State = NOTATION_PUBLIC_ID__SQ__STATE;
$Token->{q<public_identifier>} .= $1;
} else {
if ($EOF) {
$State = NOTATION_PUBLIC_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        $Token = {type => NOTATION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = B_NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        $Token = {type => NOTATION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_NAME_STATE, B_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => NOTATION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => NOTATION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = NOTATION_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_SYSTEM_ID__DQ__STATE] = sub {
if ($Input =~ /\G([^\ \\"]+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = NOTATION_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_NOTATION_SYSTEM_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_SYSTEM_ID__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = NOTATION_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = NOTATION_SYSTEM_ID__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_NOTATION_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = NOTATION_SYSTEM_ID__DQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = NOTATION_SYSTEM_ID__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_SYSTEM_ID__SQ__STATE] = sub {
if ($Input =~ /\G([^\ \\']+)/gcs) {
$Token->{q<system_identifier>} .= $1;

} elsif ($Input =~ /\G([\ ])/gcs) {
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = NOTATION_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_NOTATION_SYSTEM_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[NOTATION_SYSTEM_ID__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = NOTATION_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= q@@;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Token->{q<system_identifier>} .= q@
@;
$State = NOTATION_SYSTEM_ID__SQ__STATE_CR;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_NOTATION_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = NOTATION_SYSTEM_ID__SQ__STATE;
$Token->{q<system_identifier>} .= $1;
} else {
if ($EOF) {
$State = NOTATION_SYSTEM_ID__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PI_DATA_STATE] = sub {
if ($Input =~ /\G([^\\?\ ]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PI_DATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = PI_DATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PI_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => PROCESSING_INSTRUCTION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<target>} = q@@;
$Token->{q<data>} = [['', $DI, $Offset + (pos $Input) - 1]];
$State = PI_TARGET_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'bare pio', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => PROCESSING_INSTRUCTION_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<target>} = $1;
$Token->{q<data>} = [['', $DI, $Offset + (pos $Input) - 1]];
$State = PI_TARGET_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input)]];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PI_TARGET_QUESTION_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = IN_PIC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input) - length $1]];
$State = PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'no s after target', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<data>} = [[q@?@, $DI, $Offset + (pos $Input)]];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PI_TARGET_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\?\ ]+)/gcs) {
$Token->{q<target>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
$State = A_PI_TARGET_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
} elsif ($Input =~ /\G([\])/gcs) {
$Temp = q@
@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = A_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = PI_TARGET_QUESTION_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<target>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_DEFAULT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_DEFAULT_STATE, A_ATTLIST_ATTR_DEFAULT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {

        push @{$Token->{attr_list} ||= []}, $Attr;
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

        push @{$Token->{attr_list} ||= []}, $Attr;
      

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_DEFAULT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_DEFAULT_STATE, A_ATTLIST_ATTR_DEFAULT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_DEFAULT_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

        push @{$Token->{attr_list} ||= []}, $Attr;
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

        push @{$Token->{attr_list} ||= []}, $Attr;
      

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_DEFAULT_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_DEFAULT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_DEFAULT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ATTLIST_ATTR_DEFAULT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_NAME_STATE, A_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr type', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Attr->{q<declared_type>} = $1;
$State = ATTLIST_ATTR_TYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_NAME_STATE, A_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr type', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Attr->{q<declared_type>} = $1;
$State = ATTLIST_ATTR_TYPE_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_TYPE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_TYPE_STATE, A_ATTLIST_ATTR_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\(])/gcs) {
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_TYPE_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ATTLIST_ATTR_TYPE_STATE, A_ATTLIST_ATTR_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\(])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_TYPE_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ATTLIST_ATTR_TYPE_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_TYPE_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ATTLIST_ATTR_TYPE_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ATTLIST_ATTR_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTLIST_DEFAULT_VALUE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$State = B_ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_ATTR_NAME_STATE, B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

        push @{$Token->{attr_list} ||= []}, $Attr;
      
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        push @{$Token->{attr_list} ||= []}, $Attr;
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        push @{$Token->{attr_list} ||= []}, $Attr;
      

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_INTERNAL_SUBSET_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {

          if (defined $CONTEXT) {
            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
            $State = DTD_STATE;
            return 1;
          }
        
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      
return 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = A_DTD_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          if (defined $CONTEXT) {
            $State = DTD_STATE;
            return 1;
          }
        
$DTDMode = q{N/A};
$State = BOGUS_AFTER_DOCTYPE_INTERNAL_SUBSET_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_S;
} elsif ($Input =~ /\G([\[])/gcs) {
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_DOCTYPE_NAME_STATE_S;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_P] = sub {
if ($Input =~ /\G([U])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PU;
} elsif ($Input =~ /\G([u])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PU;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PU] = sub {
if ($Input =~ /\G([B])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUB;
} elsif ($Input =~ /\G([b])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUB;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUB] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBL;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUBL] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_PUBLI] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_DOCTYPE_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_DOCTYPE_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_S] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SY;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SY] = sub {
if ($Input =~ /\G([S])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYS;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYS;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYS] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYST;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYST;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYST] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = A_DOCTYPE_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_NAME_STATE_SYSTE] = sub {
if ($Input =~ /\G([M])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_DOCTYPE_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G([m])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_DOCTYPE_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_PUBLIC_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DOCTYPE_SYSTEM_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_DOCTYPE_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_DTD_MSC_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {

        if (@$OpenMarkedSections) {
          pop @$OpenMarkedSections;
          if (@$OpenMarkedSections) {
            if ($OpenMarkedSections->[-1] eq 'INCLUDE') {
              $State = DTD_STATE;
            } else {
              $State = IGNORED_SECTION_STATE;
            }
          } else {
            $State = DTD_STATE;
          }
        } else {
          push @$Errors, {level => 'm',
                          type => 'string in internal subset', # ]]>
                          di => $DI, index => $Offset + (pos $Input) - 3};
          $State = DTD_STATE;
        }
      
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          
$State = DTD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ELEMENT_CONTENT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ELEMENT_CONTENT_STATE, A_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ELEMENT_CONTENT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ELEMENT_CONTENT_STATE, A_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ELEMENT_CONTENT_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ELEMENT_CONTENT_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ELEMENT_CONTENT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ELEMENT_CONTENT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = ENT_VALUE__DQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_NAME_STATE, A_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = ENT_VALUE__SQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_S;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_S;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_VALUE__DQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_NAME_STATE, A_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_VALUE__SQ__STATE;
$Token->{q<value>} = [['', $DI, $Offset + pos $Input]];
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_S;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_NAME_STATE_S;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_P] = sub {
if ($Input =~ /\G([U])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PU;
} elsif ($Input =~ /\G([u])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PU;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_PU] = sub {
if ($Input =~ /\G([B])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUB;
} elsif ($Input =~ /\G([b])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUB;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_PUB] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUBL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUBL;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_PUBL] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_PUBLI] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_ENT_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_ENT_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_S] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SY;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_SY] = sub {
if ($Input =~ /\G([S])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYS;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYS;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_SYS] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYST;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYST;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_SYST] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = A_ENT_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_NAME_STATE_SYSTE] = sub {
if ($Input =~ /\G([M])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_ENT_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G([m])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_ENT_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PARAMETER_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_PARAMETER_STATE, A_ENT_PARAMETER_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PARAMETER_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ENT_PARAMETER_STATE, A_ENT_PARAMETER_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_PARAMETER_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ENT_PARAMETER_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ENT_PARAMETER_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ENT_PARAMETER_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ENT_PARAMETER_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_PUBLIC_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_PUBLIC_ID_STATE, B_ENT_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_NDATA_KWD_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_KWD_STATE, B_NDATA_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G([N])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G([n])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ENT_SYSTEM_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ENT_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_SYSTEM_ID_STATE, B_ENT_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_IGNORE_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_IGNORE_KWD_STATE, A_IGNORE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_IGNORE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_IGNORE_KWD_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_IGNORE_KWD_STATE, A_IGNORE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_IGNORE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_IGNORE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_IGNORE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_IGNORE_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_IGNORE_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_IGNORE_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_IGNORE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_INCLUDE_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_INCLUDE_KWD_STATE, A_INCLUDE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'INCLUDE';
$State = DTD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_INCLUDE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_INCLUDE_KWD_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_INCLUDE_KWD_STATE, A_INCLUDE_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_INCLUDE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'INCLUDE';
$State = DTD_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_INCLUDE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_INCLUDE_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_INCLUDE_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_INCLUDE_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_INCLUDE_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_INCLUDE_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NDATA_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_NDATA_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_ID_STATE, B_NDATA_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<notation_name>} = q@@;
$State = NDATA_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no notation name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<notation_name>} = $1;
$State = NDATA_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_NOTATION_NAME_STATE, A_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_S;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_S;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_NOTATION_NAME_STATE, A_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([P])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_P;
} elsif ($Input =~ /\G([S])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_S;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_P;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_NAME_STATE_S;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_P] = sub {
if ($Input =~ /\G([U])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PU;
} elsif ($Input =~ /\G([u])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PU;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_PU] = sub {
if ($Input =~ /\G([B])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUB;
} elsif ($Input =~ /\G([b])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUB;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_PUB] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUBL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUBL;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_PUBL] = sub {
if ($Input =~ /\G([I])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_PUBLI;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_PUBLI] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_NOTATION_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{PUBLIC}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_NOTATION_PUBLIC_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_S] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SY;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_SY] = sub {
if ($Input =~ /\G([S])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYS;
} elsif ($Input =~ /\G([s])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYS;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_SYS] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYST;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYST;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_SYST] = sub {
if ($Input =~ /\G([E])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;
$State = A_NOTATION_NAME_STATE_SYSTE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_NAME_STATE_SYSTE] = sub {
if ($Input =~ /\G([M])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_NOTATION_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G([m])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{SYSTEM}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_NOTATION_SYSTEM_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'xml:dtd:string after name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after PUBLIC literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_PUBLIC_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_PUBLIC_ID_STATE, B_NOTATION_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_NOTATION_SYSTEM_ID_STATE, A_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_NOTATION_SYSTEM_ID_STATE, A_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_SYSTEM_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_NOTATION_SYSTEM_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_NOTATION_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_NOTATION_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_NOTATION_SYSTEM_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_NOTATION_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_SYSTEM_ID_STATE, B_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_PI_TARGET_STATE] = sub {
if ($Input =~ /\G([\	\\ \
]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_PI_TARGET_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = A_PI_TARGET_STATE;
$Temp .= $1;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = A_PI_TARGET_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_PI_TARGET_STATE_CR;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = IN_PIC_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_AFTER_ALLOWED_TOKEN_LIST_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_AFTER_ALLOWED_TOKEN_LIST_STATE, A_AFTER_ALLOWED_TOKEN_LIST_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_AFTER_ALLOWED_TOKEN_LIST_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_AFTER_ALLOWED_TOKEN_LIST_STATE, A_AFTER_ALLOWED_TOKEN_LIST_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ALLOWED_TOKEN_LIST_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_AFTER_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_AFTER_ALLOWED_TOKEN_LIST_STATE, A_AFTER_ALLOWED_TOKEN_LIST_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ATTLIST_ATTR_DEFAULT_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$InLiteral = 1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ALLOWED_TOKEN_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ALLOWED_TOKEN_STATE, A_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$State = A_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ALLOWED_TOKEN_STATE, A_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ALLOWED_TOKEN_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_ALLOWED_TOKEN_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ALLOWED_TOKEN_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_ALLOWED_TOKEN_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\=])/gcs) {
$State = B_ATTR_VALUE_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\/])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_ATTR_VALUE__QUOTED__STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no space before attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_CM_GROUP_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_CM_ITEM_STATE, A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          $State = A_CM_GROUP_STATE;

        }
      
} elsif ($Input =~ /\G([\*])/gcs) {
$OpenCMGroups->[-1]->{q<repetition>} = $1;

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {
$OpenCMGroups->[-1]->{q<repetition>} = $1;

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;

        } else {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

        }
      
} elsif ($Input =~ /\G([\?])/gcs) {
$OpenCMGroups->[-1]->{q<repetition>} = $1;

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {

        if ($InitialCMGroupDepth < @$OpenCMGroups) {
          pop @$OpenCMGroups;
        } else {
          push @$Errors, {level => 'm',
                          type => 'unmatched mgc',
                          di => $DI, index => $Offset + (pos $Input)};
          $State = BOGUS_MARKUP_DECL_STATE;
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_CM_ITEM_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_CM_ITEM_STATE, A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          $State = A_CM_GROUP_STATE;

        }
      
} elsif ($Input =~ /\G([\,])/gcs) {

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\>])/gcs) {

        if (not @$OpenCMGroups) {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;

        } else {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

        }
      
} elsif ($Input =~ /\G([\|])/gcs) {

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_CM_ITEM_STATE, A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          $State = A_CM_GROUP_STATE;

        }
      
} elsif ($Input =~ /\G([\,])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;

        } else {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

        }
      
} elsif ($Input =~ /\G([\|])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\(])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_CM_ITEM_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_CM_ITEM_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_CM_ITEM_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_IGNORED_SECTION_MSC_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {

        if (@$OpenMarkedSections) {
          pop @$OpenMarkedSections;
          if (@$OpenMarkedSections) {
            if ($OpenMarkedSections->[-1] eq 'INCLUDE') {
              $State = DTD_STATE;
            } else {
              $State = IGNORED_SECTION_STATE;
            }
          } else {
            $State = DTD_STATE;
          }
        } else {
          push @$Errors, {level => 'm',
                          type => 'string in internal subset', # ]]>
                          di => $DI, index => $Offset + (pos $Input) - 3};
          $State = DTD_STATE;
        }
      
} elsif ($Input =~ /\G([\]]+)/gcs) {
} elsif ($Input =~ /\G(.)/gcs) {
$State = IGNORED_SECTION_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSC_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'unmatched mse', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_MSS_STATE, A_MSS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([I])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_MSS_STATE_I;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_MSS_STATE_I;
} elsif ($Input =~ /\G([\<])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_MSS_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_MSS_STATE, A_MSS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([I])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_MSS_STATE_I;
} elsif ($Input =~ /\G([i])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = A_MSS_STATE_I;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_MSS_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_MSS_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_MSS_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'ms:no status keyword', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = A_MSS_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = A_MSS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_I] = sub {
if ($Input =~ /\G([G])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IG;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IN;
} elsif ($Input =~ /\G([g])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IG;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IN;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_IG] = sub {
if ($Input =~ /\G([N])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGN;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGN;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_IGN] = sub {
if ($Input =~ /\G([O])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGNO;
} elsif ($Input =~ /\G([o])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGNO;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_IGNO] = sub {
if ($Input =~ /\G([R])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGNOR;
} elsif ($Input =~ /\G([r])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_IGNOR;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_IGNOR] = sub {
if ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([E])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{IGNORE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_IGNORE_KWD_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{IGNORE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 5};
            }
          
$State = A_IGNORE_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_IN] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INC;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INC;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_INC] = sub {
if ($Input =~ /\G([L])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCL;
} elsif ($Input =~ /\G([l])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCL;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_INCL] = sub {
if ($Input =~ /\G([U])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCLU;
} elsif ($Input =~ /\G([u])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCLU;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_INCLU] = sub {
if ($Input =~ /\G([D])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCLUD;
} elsif ($Input =~ /\G([d])/gcs) {
$Temp .= $1;
$State = A_MSS_STATE_INCLUD;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[A_MSS_STATE_INCLUD] = sub {
if ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([E])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{INCLUDE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = A_INCLUDE_KWD_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{INCLUDE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = A_INCLUDE_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'ms:no dso', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ALLOWED_TOKEN_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_ALLOWED_TOKEN_STATE, A_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$State = A_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{allowed_tokens}->[-1] .= q@@;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Attr->{allowed_tokens}->[-1] .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\=ABCDEFGHJKQVWZILMNOPRSTUXY\ \"\'\/\<\>]+)/gcs) {
$Attr->{q<name>} .= $1;

} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G[\	\
\\\ ][\	\
\\\ ]*\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'\/\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\"([^\ \	\
\\\ \"\&\<]*)\"\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\=[\	\
\\\ ]*\'([^\ \	\
\\\ \&\'\<]*)\'\>/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = A_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = B_ATTR_VALUE_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\/])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr->{q<name>} .= $1;
} elsif ($Input =~ /\G([\>])/gcs) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      

            push @$Errors, {type => 'no attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} else {
if ($EOF) {

        if (defined $Token->{attrs}->{$Attr->{name}}) {
          push @$Errors, {type => 'duplicate attribute',
                          text => $Attr->{name},
                          level => 'm',
                          di => $Attr->{di},
                          index => $Attr->{index}};
        } else {
          $Token->{attrs}->{$Attr->{name}} = $Attr;
          push @{$Token->{attr_list} ||= []}, $Attr;
          $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
        }
      
$State = A_ATTR_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\"\&\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\'\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = A_ATTR_VALUE__QUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\>\ \"\'\<\=\`]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE__UNQUOTED__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\"])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\'])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 0}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[ATTR_VALUE_IN_ENT_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_ATTR_DEFAULT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Attr->{q<default_type>} .= $1;
$State = ATTLIST_ATTR_DEFAULT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'no attr default', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_ATTR_NAME_STATE, B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_ATTR_NAME_STATE, B_ATTLIST_ATTR_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_ATTR_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

        $Attr = {di => $DI, index => $Offset + pos $Input};
      
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$State = ATTLIST_ATTR_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_ATTR_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ATTLIST_ATTR_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ATTLIST_ATTR_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ATTLIST_ATTR_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_NAME_STATE, B_ATTLIST_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ATTLIST_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<name>} = $1;
$State = ATTLIST_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ATTLIST_NAME_STATE, B_ATTLIST_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ATTLIST_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = $1;
$State = ATTLIST_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ATTLIST_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ATTLIST_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ATTLIST_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ATTLIST_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = q@@;
$State = DOCTYPE_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<name>} = $1;
$State = DOCTYPE_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => DOCTYPE_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<public_identifier>} = '';
$State = DOCTYPE_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_DOCTYPE_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_CONTENT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_CONTENT_STATE, B_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
my $cmgroup = {items => [], separators => [], di => $DI, index => $Offset + (pos $Input) - 1};
$Token->{cmgroup} = $cmgroup;
@$OpenCMGroups = ($cmgroup);
$State = B_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<content_keyword>} = $1;
$State = ELEMENT_CONTENT_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_CONTENT_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_CONTENT_STATE, B_ELEMENT_CONTENT_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
my $cmgroup = {items => [], separators => [], di => $DI, index => $Offset + (pos $Input) - 1};
$Token->{cmgroup} = $cmgroup;
@$OpenCMGroups = ($cmgroup);
$State = B_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_CONTENT_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\?])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<content_keyword>} = $1;
$State = ELEMENT_CONTENT_KWD_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_CONTENT_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ELEMENT_CONTENT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ELEMENT_CONTENT_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ELEMENT_CONTENT_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_NAME_STATE, B_ELEMENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ELEMENT_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<name>} = $1;
$State = ELEMENT_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ELEMENT_NAME_STATE, B_ELEMENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = ELEMENT_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = $1;
$State = ELEMENT_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ELEMENT_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ELEMENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ELEMENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ELEMENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_NAME_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$Token->{q<name>} = q@@;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_NAME_STATE, B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = q@@;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_NAME_STATE, B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ENT_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = ENT_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_PUBLIC_ID_STATE, B_ENT_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = ENT_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_PUBLIC_ID_STATE, B_ENT_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_PUBLIC_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_PUBLIC_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_PUBLIC_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_PUBLIC_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ENT_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_SYSTEM_ID_STATE, B_ENT_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_SYSTEM_ID_STATE, B_ENT_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_SYSTEM_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_SYSTEM_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ENT_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_TYPE_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$Token->{q<name>} = q@@;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$State = PE_DECL_OR_REF_AFTER_SPACE_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = B_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = q@@;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_TYPE_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = PE_DECL_OR_REF_AFTER_SPACE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ENT_TYPE_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_TYPE_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ENT_TYPE_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ENT_TYPE_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ENT_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\%])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_ID_STATE, B_NDATA_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<notation_name>} = q@@;
$State = NDATA_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no notation name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<notation_name>} = $1;
$State = NDATA_ID_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_ID_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_ID_STATE, B_NDATA_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<notation_name>} = q@@;
$State = NDATA_ID_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no notation name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<notation_name>} = $1;
$State = NDATA_ID_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NDATA_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NDATA_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_NDATA_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_KWD_STATE, B_NDATA_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_KWD_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NDATA_KWD_STATE, B_NDATA_KWD_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G([N])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G([n])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NDATA_KWD_STATE_N;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NDATA_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_NDATA_KWD_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE_N] = sub {
if ($Input =~ /\G([D])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_ND;
} elsif ($Input =~ /\G([d])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_ND;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE_ND] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_NDA;
} elsif ($Input =~ /\G([a])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_NDA;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE_NDA] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_NDAT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = B_NDATA_KWD_STATE_NDAT;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NDATA_KWD_STATE_NDAT] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{NDATA}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 4};
            }
          
$State = A_NDATA_KWD_STATE;
} elsif ($Input =~ /\G([a])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{NDATA}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 4};
            }
          
$State = A_NDATA_KWD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'string after SYSTEM literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_NAME_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_NAME_STATE, B_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Token->{q<name>} = $1;
$State = NOTATION_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_NAME_STATE, B_NOTATION_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<name>} = q@@;
$State = NOTATION_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Token->{q<name>} = $1;
$State = NOTATION_NAME_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_NAME_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_NOTATION_NAME_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_PUBLIC_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_PUBLIC_ID_STATE, B_NOTATION_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_PUBLIC_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_PUBLIC_ID_STATE, B_NOTATION_PUBLIC_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_PUBLIC_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_PUBLIC_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_PUBLIC_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_PUBLIC_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_PUBLIC_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_NOTATION_PUBLIC_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_SYSTEM_ID_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_SYSTEM_ID_STATE, B_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_SYSTEM_ID_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_NOTATION_SYSTEM_ID_STATE, B_NOTATION_SYSTEM_ID_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_SYSTEM_ID_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_NOTATION_SYSTEM_ID_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_NOTATION_SYSTEM_ID_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_NOTATION_SYSTEM_ID_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ALLOWED_TOKEN_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ALLOWED_TOKEN_STATE, B_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{allowed_tokens} ||= []}, '';
$Attr->{allowed_tokens}->[-1] = q@@;
$State = ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = A_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\|])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Attr->{allowed_tokens} ||= []}, '';
$Attr->{allowed_tokens}->[-1] = $1;
$State = ALLOWED_TOKEN_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ALLOWED_TOKEN_STATE, B_ALLOWED_TOKEN_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{allowed_tokens} ||= []}, '';
$Attr->{allowed_tokens}->[-1] = q@@;
$State = ALLOWED_TOKEN_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = A_ALLOWED_TOKEN_LIST_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G([\|])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Attr->{allowed_tokens} ||= []}, '';
$Attr->{allowed_tokens}->[-1] = $1;
$State = ALLOWED_TOKEN_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_ALLOWED_TOKEN_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ALLOWED_TOKEN_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_ALLOWED_TOKEN_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_ALLOWED_TOKEN_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTR_NAME_STATE] = sub {
if ($Input =~ /\G([^\ \	\
\\\ \"\'\/\<\=\>A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)([A-Z]*)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
$Attr->{q<name>} .= $3;
} elsif ($Input =~ /\G([A-Z])([^\ \	\
\\\ \"\'\/\<\=\>A-Z]*)([A-Z]*)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + $-[1];
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
$Attr->{q<name>} .= $2;
$Attr->{q<name>} .= $3;
} elsif ($Input =~ /\G\/\>/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\>/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\"])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {
$State = A_ATTR_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_ATTR_VALUE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$State = ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$State = ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'bad attribute value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = ATTR_VALUE__UNQUOTED__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'unquoted attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = ATTR_VALUE__UNQUOTED__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_CM_ITEM_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_CM_ITEM_STATE, B_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
my $cmgroup = {items => [], separators => [], di => $DI, index => $Offset + (pos $Input) - 1};
push @{$OpenCMGroups->[-1]->{items}}, $cmgroup;
push @$OpenCMGroups, $cmgroup;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        push @{$OpenCMGroups->[-1]->{items}},
            {di => $DI, index => $Offset + pos $Input};
      
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} = q@@;
$LastCMItem = 'element';
$State = CM_ELEMENT_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

        push @{$OpenCMGroups->[-1]->{items}},
            {di => $DI, index => $Offset + pos $Input};
      
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} = $1;
$LastCMItem = 'element';
$State = CM_ELEMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_CM_ITEM_STATE, B_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\(])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_CM_ITEM_STATE;
my $cmgroup = {items => [], separators => [], di => $DI, index => $Offset + (pos $Input) - 1};
push @{$OpenCMGroups->[-1]->{items}}, $cmgroup;
push @$OpenCMGroups, $cmgroup;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        push @{$OpenCMGroups->[-1]->{items}},
            {di => $DI, index => $Offset + pos $Input};
      
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} = q@@;
$LastCMItem = 'element';
$State = CM_ELEMENT_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\*])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_CM_ITEM_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'xml:dtd:no group item', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

        push @{$OpenCMGroups->[-1]->{items}},
            {di => $DI, index => $Offset + pos $Input};
      
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} = $1;
$LastCMItem = 'element';
$State = CM_ELEMENT_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = B_CM_ITEM_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_CM_ITEM_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = B_CM_ITEM_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = B_CM_ITEM_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<system_identifier>} = '';
$State = DOCTYPE_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<force_quirks_flag>} = 1;
$State = BOGUS_DOCTYPE_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<force_quirks_flag>} = 1;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = ENT_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = BETWEEN_ENT_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\]+)/gcs) {
} elsif ($Input =~ /\G([\"])/gcs) {
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'string after PUBLIC literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__DQ__STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE, BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$InLiteral = 1;
$State = NOTATION_SYSTEM_ID__SQ__STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      

            push @$Errors, {type => 'string after PUBLIC literal', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\\>\ \!\%\&\<]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = BETWEEN_NOTATION_PUBLIC_AND_SYSTEM_IDS_STATE___TEXT_DECL_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
          push @$Errors, {type => 'tag in pe in markup declaration', level => 'm',
                          di => $DI, index => $Offset + (pos $Input) - 1};
          $State = BOGUS_MARKUP_DECL_STATE;
        

        }
      
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_DOCTYPE_STATE] = sub {
if ($Input =~ /\G([^\>\[]+)/gcs) {

} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} elsif ($Input =~ /\G([\[])/gcs) {
$State = DTD_STATE;
$Token->{q<has_internal_subset_flag>} = 1;
$DTDMode = q{internal subset};
push @$Tokens, $Token;
return 1 if $Token->{type} == DOCTYPE_TOKEN;
} else {
if ($EOF) {
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_AFTER_DOCTYPE_INTERNAL_SUBSET_STATE] = sub {
if ($Input =~ /\G([^\>]+)/gcs) {

} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      
return 1;
} else {
if ($EOF) {
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_COMMENT_STATE] = sub {
if ($Input =~ /\G([^\ \\>]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
push @$Tokens, $Token;
$State = DATA_STATE;
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\ ])/gcs) {
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = BOGUS_COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\>]+)/gcs) {

} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[BOGUS_STATUS_KWD_STATE] = sub {
if ($Input =~ /\G([^\%\<\>\[\]]+)/gcs) {

} elsif ($Input =~ /\G([\%])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IN_IGNORED_SECTION_MSC_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CHARREF_IN_DATA_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\=])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\`])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - 1;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_BANG_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_END_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = COMMENT_END_BANG_STATE;
} elsif ($Input =~ /\G([\-])/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'parser:comment not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_START_DASH_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_START_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_START_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'parser:comment closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
$State = COMMENT_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_STATE] = sub {
if ($Input =~ /\G([^\\-\ ]+)/gcs) {
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];

} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[COMMENT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = COMMENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\-])/gcs) {
$State = COMMENT_END_DASH_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = COMMENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;
push @$Tokens, $Token;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[CM_ELEMENT_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [A_CM_ITEM_STATE, A_CM_ITEM_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\)])/gcs) {
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          $State = A_CM_GROUP_STATE;

        }
      
} elsif ($Input =~ /\G([\*])/gcs) {
$OpenCMGroups->[-1]->{items}->[-1]->{q<repetition>} = $1;
$LastCMItem = 'element';
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\+])/gcs) {
$OpenCMGroups->[-1]->{items}->[-1]->{q<repetition>} = $1;
$LastCMItem = 'element';
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\,])/gcs) {
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\>])/gcs) {

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;

        } else {
          
          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'unclosed cmgroup', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

        }
      
} elsif ($Input =~ /\G([\?])/gcs) {
$OpenCMGroups->[-1]->{items}->[-1]->{q<repetition>} = $1;
$LastCMItem = 'element';
$State = A_CM_ITEM_STATE;
} elsif ($Input =~ /\G([\|])/gcs) {
$State = A_CM_ITEM_STATE;

        if (not @$OpenCMGroups) {
          
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

        } else {
          
        push @{$OpenCMGroups->[-1]->{separators}},
            {di => $DI, index => $Offset + (pos $Input) - 1, type => $1};
        if (not defined $LastCMItem) {
          push @$Errors, {level => 's',
                          type => 'xml:dtd:cm:entity begins with connector',
                          di => $DI, index => $Offset + (pos $Input) - 1};
        }
        $LastCMItem = 'separator';
      
$State = B_CM_ITEM_STATE;

        }
      
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} .= q@@;
} elsif ($Input =~ /\G([\(])/gcs) {

            push @$Errors, {type => 'xml:dtd:no group delimiter', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$OpenCMGroups->[-1]->{items}->[-1]->{q<name>} .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE] = sub {
if ($Input =~ /\G([^\\&\<\]\ ]+)/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        

} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        if (not @$OE and $DTDMode eq 'N/A') {
          push @$Errors, {level => 'm',
                          type => 'ref outside of root element',
                          value => $Temp.';',
                          di => $DI, index => $TempIndex};
        }
        $TempRef = {value => $Temp.';', di => $DI, index => $TempIndex};
      

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>

            if (not @$OE) {
              push @$Errors, {level => 'm',
                              type => 'ref outside of root element',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              $TempIndex += length $Temp;
              $Temp = '';
              last REF;
            }

            if (defined $DTDDefs->{ge}->{$Temp}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if ($ent->{only_text}) {
                ## Internal entity with no "&" or "<"

                ## A variant of |emit-temp|
                push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                value => $_->[0],
                                di => $_->[1], index => $_->[2]}
                    for @{$ent->{value}}; # IndexedString
                $TempIndex += length $Temp;
                $Temp = '';
                last REF;
              } elsif (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } else {
                ## Internal entity with "&" and/or "<"
                ## External parsed entity
                push @$Callbacks, [$OnContentEntityReference,
                                   {entity => $ent,
                                    ref => {di => $DI, index => $TempIndex},
                                    ops => $OP}];
                $TempIndex += length $Temp;
                $Temp = '';
                $return = 1;
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  ## 

                  ## A variant of |emit-temp|
                  push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                  value => $value,
                                  di => $DI, index => $TempIndex};
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {level => 'm',
                              type => 'entity not declared',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE___CHARREF_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DATA_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DATA_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = DATA_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          TempRef => $TempRef,
                          value => $Temp,
                          di => $DI,
                          index => $TempIndex} if length $Temp;
          undef $TempRef;
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DATA_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = DATA_STATE;
} elsif ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = IN_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\"\&\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 if $return }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__DQ__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DEFAULT_ATTR_VALUE__DQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\'\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 if $return }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE__SQ__STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
undef $InLiteral;
$State = A_ATTLIST_DEFAULT_VALUE_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'lt in attr value', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DEFAULT_ATTR_VALUE__SQ__STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\&\ \<]+)/gcs) {
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];

} elsif ($Input =~ /\G([\	\\ \
])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_HEX_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789ABCDEFabcdef]+)/gcs) {
$Temp .= $1;
} elsif ($Input =~ /\G([\;])/gcs) {

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
        if (my $replace = $InvalidCharRefs->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = $replace;
        } elsif ($code > 0x10FFFF) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => 'm',
                          di => $DI, index => $TempIndex};
          $code = 0xFFFD;
        ## <XML>
        } elsif ($Web::HTML::_SyntaxDefs->{xml_char_discouraged}->{$code}) {
          push @$Errors, {type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => 'w',
                          di => $DI, index => $TempIndex};
        ## </XML>
        }
        $Temp = chr $code;
      
$Attr->{has_ref} = 1;
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
return 1 if $return;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (1) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
return 1 if $return;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          my $return;
          REF: {
            ## <XML>
            if (defined $DTDDefs->{ge}->{$Temp} and
                not $DTDDefs->{ge}->{$Temp}->{predefined}) {
              my $ent = $DTDDefs->{ge}->{$Temp};

              if (my $ext = $ent->{external}) {
                if (not $ext->{vc_error_reported} and $DTDDefs->{XMLStandalone}) {
                  push @$Errors, {level => 'm',
                                  type => 'VC:Standalone Document Declaration:entity',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  $ext->{vc_error_reported} = 1;
                }
              }

              if (defined $ent->{notation_name}) {
                ## Unparsed entity
                push @$Errors, {level => 'm',
                                type => 'unparsed entity',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif ($ent->{open}) {
                push @$Errors, {level => 'm',
                                type => 'WFC:No Recursion',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              } elsif (defined $ent->{value}) {
                ## Internal entity with or without "&" and/or "<"
                my $value = join '', map { $_->[0] } @{$ent->{value}}; # IndexedString
                if ($value =~ /</) {
                  push @$Errors, {level => 'm',
                                  type => 'entref in attr has element',
                                  value => $Temp,
                                  di => $DI, index => $TempIndex};
                  last REF;
                } else {
                  push @$Callbacks, [$OnAttrEntityReference,
                                     {entity => $ent,
                                      ref => {di => $DI, index => $TempIndex},
                                      in_default_attr => 1}];
                  $TempIndex += length $Temp;
                  $Temp = '';
                  $return = 1;
                  last REF;
                }
              } else {
                ## External parsed entity
                push @$Errors, {level => 'm',
                                type => 'WFC:No External Entity References',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                last REF;
              }
            }
            ## </XML>

            for (reverse (2 .. length $Temp)) {
              my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
              if (defined $value) {
                my $temp_index = $TempIndex;

                unless (';' eq substr $Temp, $_-1, 1) {
                  if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                    last REF;
                  } elsif (0) { # before_equals
                    last REF;
                  } else {
                    ## 
                  }

                  ## A variant of |append-to-attr|
                  push @{$Attr->{value}},
                      [$value, $DI, $TempIndex]; # IndexedString
                  $TempIndex += $_;
                  $value = '';
                }

                ## <XML>
                if ($DTDDefs->{has_charref_decls}) {
                  if ($DTDDefs->{charref_vc_error}) {
                    push @$Errors, {level => 'm',
                                    type => 'VC:Standalone Document Declaration:entity',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                } elsif ({
                  '&amp;' => 1, '&quot;' => 1, '&lt;' => 1, '&gt;' => 1,
                  '&apos;' => 1,
                }->{$Temp}) {
                  if ($DTDDefs->{ge}->{$Temp}) {
                    #
                  } elsif ($DTDDefs->{need_predefined_decls} or
                      not $DTDMode eq 'N/A') {
                    push @$Errors, {level => 's',
                                    type => 'entity not declared',
                                    value => $Temp,
                                    di => $DI, index => $temp_index};
                  }
                  ## If the document has no DOCTYPE, skip warning.
                } else {
                  ## Not a declared XML entity.
                  push @$Errors, {level => 'm',
                                  type => 'entity not declared',
                                  value => $Temp,
                                  di => $DI, index => $temp_index};
                }
                ## </XML>

                $Attr->{has_ref} = 1;
                substr ($Temp, 0, $_) = $value;
                last REF;
              }
            }
            if ($Temp =~ /;\z/) {
              push @$Errors, {type => 'entity not declared',
                              value => $Temp,
                              level => 'm',
                              di => $DI, index => $TempIndex};
              ## <XML>
              $DTDDefs->{entity_names}->{$Temp}
                  ||= {di => $DI, index => $TempIndex};
              ## </XML>
            }
          } # REF
        
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE] = sub {
if ($Input =~ /\G([0123456789])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_DECIMAL_NUM_STATE;
} elsif ($Input =~ /\G([x])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([X])/gcs) {

            push @$Errors, {type => 'uppercase hcro', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {

            push @$Errors, {type => 'bare nero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE] = sub {
if ($Input =~ /\G([\#])/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NUM_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'bare ero', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$Temp .= $1;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR] = sub {
if ($Input =~ /\G([\	\\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\
])/gcs) {
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
push @{$Attr->{q<value>}}, [q@ @, $DI, $Offset + (pos $Input) - length $1];
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G([\<])/gcs) {
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'entref in attr has element', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} elsif ($Input =~ /\G(.)/gcs) {
$State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;
push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[END_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = q@@;
$State = TAG_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare etago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare etago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'empty end tag', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 2};
          
$State = DATA_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = '';

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$State = TAG_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 2};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IGNORED_SECTION_MDO_STATE] = sub {
if ($Input =~ /\G([\<])/gcs) {
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\[])/gcs) {
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = IGNORED_SECTION_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IGNORED_SECTION_STATE] = sub {
if ($Input =~ /\G([^\<\]]+)/gcs) {

} elsif ($Input =~ /\G([\<])/gcs) {
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = IN_IGNORED_SECTION_MSC_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IGNORED_SECTION_TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([\!])/gcs) {
$State = IGNORED_SECTION_MDO_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = IN_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = IGNORED_SECTION_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IN_IGNORED_SECTION_MSC_STATE] = sub {
if ($Input =~ /\G([\]])/gcs) {
$State = A_IGNORED_SECTION_MSC_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$State = IGNORED_SECTION_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IN_MSC_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\&])/gcs) {
$State = CHARREF_IN_DATA_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {
$State = TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\]])/gcs) {
$State = A_MSC_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\ ])/gcs) {
$State = DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} else {
if ($EOF) {
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[IN_PIC_STATE] = sub {
if ($Input =~ /\G([\])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = PI_DATA_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\?])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
} elsif ($Input =~ /\G([\ ])/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = PI_DATA_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - (length $1) - 2];
$State = PI_DATA_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {
push @{$Token->{q<data>}}, [q@?@, $DI, $Offset + (pos $Input) - 2];

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE] = sub {
if ($Input =~ /\G([\-])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;
} elsif ($Input =~ /\G([D])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE_D;
} elsif ($Input =~ /\G([\[])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__5B;
} elsif ($Input =~ /\G([d])/gcs) {
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE_D;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[q@@, $DI, $Offset + (pos $Input) - length $1]];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[q@
@, $DI, $Offset + (pos $Input) - length $1]];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$State = BOGUS_COMMENT_STATE;
$Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__] = sub {
if ($Input =~ /\G([\-])/gcs) {

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_D] = sub {
if ($Input =~ /\G([O])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DO;
} elsif ($Input =~ /\G([o])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DO;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DO] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOC;
} elsif ($Input =~ /\G([c])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOC;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOC] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCT;
} elsif ($Input =~ /\G([t])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCT;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCT] = sub {
if ($Input =~ /\G([Y])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTY;
} elsif ($Input =~ /\G([y])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTY;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCTY] = sub {
if ($Input =~ /\G([P])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTYP;
} elsif ($Input =~ /\G([p])/gcs) {
$Temp .= $1;
$State = MDO_STATE_DOCTYP;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE_DOCTYP] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G([E])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{DOCTYPE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = DOCTYPE_STATE;
} elsif ($Input =~ /\G([e])/gcs) {
$Temp .= $1;

            unless ($Temp eq q{DOCTYPE}) {
              push @$Errors, {type => 'keyword-wrong-case', level => 'm',
                              value => $Temp,
                              di => $DI, index => $Offset + (pos $Input) - 1 - 6};
            }
          
$State = DOCTYPE_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5B] = sub {
if ($Input =~ /\G([C])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BC;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BC] = sub {
if ($Input =~ /\G([D])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCD;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCD] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDA;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDA] = sub {
if ($Input =~ /\G([T])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDAT;

          return 1;
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDAT] = sub {
if ($Input =~ /\G([A])/gcs) {
$Temp .= $1;
$State = MDO_STATE__5BCDATA;

          if (@$OE and defined $OE->[-1]->{cm_type} and
              ($OE->[-1]->{cm_type} eq 'element' or
               $OE->[-1]->{cm_type} eq 'EMPTY')) {
            push @$Errors, {level => 'm',
                            type => 'xml:CDATA section not allowed by cm',
                            di => $DI, index => $Offset + (pos $Input) - 8};
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[MDO_STATE__5BCDATA] = sub {
if ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<data>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = BOGUS_COMMENT_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;
} elsif ($Input =~ /\G([\[])/gcs) {

            unless (@$OE) {
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            }
          
$State = CDATA_SECTION_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
$State = BOGUS_COMMENT_STATE;
push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'bogus comment', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
push @$Tokens, $Token;
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_DECL_OR_REF_AFTER_SPACE_STATE] = sub {
if ($Input =~ /\G([\	\\ \
\])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_NAME_STATE, B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\;])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
$Temp .= $1;

        $LastCMItem = 'peref';
        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnMDEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $State = BOGUS_MARKUP_DECL_STATE;
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
return 1 if $return;
} elsif ($Input =~ /\G([\<])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\`])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_DECL_OR_REF_STATE] = sub {
if ($Input =~ /\G([\;])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
$Temp .= $1;

        $LastCMItem = 'peref';
        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnMDEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $State = BOGUS_MARKUP_DECL_STATE;
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$OriginalState = [B_ENT_NAME_STATE, B_ENT_NAME_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        

            push @$Errors, {type => 'no md name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no space between params', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$Token->{q<name>} = $1;
$State = ENT_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 1;
$OriginalState = [B_ENT_TYPE_STATE, B_ENT_TYPE_STATE___BEFORE_TEXT_DECL_IN_MARKUP_DECL_STATE];
$State = PE_NAME_IN_MARKUP_DECL_STATE;
$Temp .= $1;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$Token->{q<is_parameter_entity_flag>} = 1;
$State = B_ENT_NAME_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_DTD_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif (defined $ent->{public_identifier} and
                     $Web::HTML::_SyntaxDefs->{charrefs_pubids}->{$ent->{public_identifier}}) {
              ## Public identifier normalization is intentionally not
              ## done (Chrome behavior).

              $DTDDefs->{has_charref_decls} = 1;
              $DTDDefs->{charref_vc_error} = 1 if $DTDDefs->{XMLStandalone};
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            } else {
              push @$Callbacks, [$OnDTDEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
$State = DTD_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_DTD_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DOCTYPE_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = DTD_STATE;

            push @$Errors, {type => 'string in internal subset', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_ENT_VALUE__DQ__STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnEntityValueEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
$State = ENT_VALUE__DQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__DQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__DQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__DQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__DQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_ENT_VALUE__SQ__STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnEntityValueEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
$State = ENT_VALUE__SQ__STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE__SQ__STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE__SQ__STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE__SQ__STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
undef $InLiteral;
$State = A_ENT_PARAMETER_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE__SQ__STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_ENT_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnEntityValueEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
$State = ENT_VALUE_IN_ENT_STATE;
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
push @{$Token->{q<value>}}, [q@
@, $DI, $Offset + (pos $Input) - (length $1) - 0];
$State = ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_MARKUP_DECL_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        $LastCMItem = 'peref';
        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnMDEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $State = BOGUS_MARKUP_DECL_STATE;
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_MARKUP_DECL_STATE;
            return 1;
          }
        
$State = DTD_STATE;
push @$Tokens, $Token;
$Token->{StopProcessing} = 1 if $DTDDefs->{StopProcessing};
return 1 if $Token->{type} == ENTITY_TOKEN;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_MARKUP_DECL_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_MARKUP_DECL_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[PE_NAME_IN_STATUS_KWD_STATE] = sub {
if ($Input =~ /\G([^\;\ \	\\ \
\\"\#\%\&\'\<\=\>\`]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\;])/gcs) {
$Temp .= $1;

        $LastCMItem = 'peref';
        my $return;
        REF: {
          if ($DTDDefs->{StopProcessing}) {
            $TempIndex += length $Temp;
            $Temp = '';
            last REF;
          } elsif (defined $DTDDefs->{pe}->{$Temp}) {
            my $ent = $DTDDefs->{pe}->{$Temp};
            if ($ent->{open}) {
              push @$Errors, {level => 'm',
                              type => 'WFC:No Recursion',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } elsif ($DTDMode eq 'internal subset' or
                     $DTDMode eq 'parameter entity in internal subset') {
              ## In a markup declaration in internal subset
              push @$Errors, {level => 'm',
                              type => 'WFC:PEs in Internal Subset',
                              value => $Temp,
                              di => $DI, index => $TempIndex};
            } else {
              push @$Callbacks, [$OnMDEntityReference,
                                 {entity => $ent,
                                  ref => {di => $DI, index => $TempIndex}}];
              $TempIndex += length $Temp;
              $Temp = '';
              $return = 1;
              last REF;
            }
          } else {
            push @$Errors, {level => 'm',
                            type => 'entity not declared',
                            value => $Temp,
                            di => $DI, index => $TempIndex};
            $DTDDefs->{entity_names}->{$Temp}
              ||= {di => $DI, index => $TempIndex};
          }

          if (not $DTDDefs->{StopProcessing} and
              not $DTDDefs->{XMLStandalone}) {
            push @$Errors, {level => 'i',
                            type => 'stop processing',
                            di => $DI, index => $TempIndex};
            $State = BOGUS_MARKUP_DECL_STATE;
            $DTDDefs->{StopProcessing} = 1;
          }
        } # REF
      
return 1 if $return;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Temp .= q@@;
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\#])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\%])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'string after md def', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_TAG_OPEN_STATE;
$AnchoredIndex = $Offset + (pos $Input) - 1;
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;

          if ($InMDEntity) {
            push @$Errors, {type => 'mdc in pe in md', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
            $State = BOGUS_STATUS_KWD_STATE;
            return 1;
          }
        
push @$OpenMarkedSections, 'IGNORE';
$State = IGNORED_SECTION_STATE;
} elsif ($Input =~ /\G([\`])/gcs) {

            push @$Errors, {type => 'no refc', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = BOGUS_STATUS_KWD_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$State = BOGUS_STATUS_KWD_STATE;

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[SELF_CLOSING_START_TAG_STATE] = sub {
if ($Input =~ /\G([\>])/gcs) {
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = q@@;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\"])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\'])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'bad attribute name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\/])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\<])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;

            push @$Errors, {type => 'tag not closed', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
} elsif ($Input =~ /\G([\=])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

            push @$Errors, {type => 'parser:no attr name', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY])/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} elsif ($Input =~ /\G(.)/gcs) {

            push @$Errors, {type => 'nestc has no net', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Attr = {di => $DI};
$Attr->{q<name>} = $1;
$Attr->{index} = $Offset + (pos $Input) - length $1;
$Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
$State = ATTR_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TAG_NAME_STATE] = sub {
if ($Input =~ /\G([^\	\\ \
\\/\>ABCDEFGHJKQVWZILMNOPRSTUXY\ ]+)/gcs) {
$Token->{q<tag_name>} .= $1;

} elsif ($Input =~ /\G([\	\\ \
\])/gcs) {
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = SELF_CLOSING_START_TAG_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([ABCDEFGHJKQVWZILMNOPRSTUXY]+)/gcs) {
$Token->{q<tag_name>} .= $1;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
$Token->{q<tag_name>} .= q@@;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TAG_OPEN_STATE] = sub {
if ($Input =~ /\G([^\ \	\
\\\ \!\/\>\?])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G\/([^\ \	\
\\\ \>])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)[\	\
\\\ ][\	\
\\\ ]*/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = B_ATTR_NAME_STATE;
} elsif ($Input =~ /\G([^\ \	\
\\\ \!\/\>\?])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)\/\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G([^\ \	\
\\\ \!\/\>\?])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)\>/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\>])([^\ \\-]*)\-([^\ \\-])([^\ \\-]*)/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = COMMENT_END_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
} elsif ($Input =~ /\G\!(\-)\-([^\ \\-\>])([^\ \\-]*)\-([^\ \\-])([^\ \\-]*)/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = COMMENT_END_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
$State = COMMENT_STATE;
push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
} elsif ($Input =~ /\G\/([^\ \	\
\\\ \>])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)\/\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = SELF_CLOSING_START_TAG_STATE;
$Token->{q<self_closing_flag>} = 1;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\/([^\ \	\
\\\ \>])([^\ \	\
\\\ \/\>A-Z]*)([A-Z]*)\>/gcs) {
$State = END_TAG_OPEN_STATE;

        $Token = {type => END_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$Token->{q<tag_name>} .= $2;
$Token->{q<tag_name>} .= $3;
$State = DATA_STATE;

          if ($Token->{type} == END_TAG_TOKEN) {
            if (keys %{$Token->{attrs} or {}}) {
              push @$Errors, {type => 'end tag attribute',
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
            if ($Token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                              text => $Token->{tag_name},
                              level => 'm',
                              di => $Token->{di},
                              index => $Token->{index}};
            }
          }
        
push @$Tokens, $Token;

          if ($Token->{type} == START_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            if (not defined $LastStartTagName) { # "first start tag"
              $LastStartTagName = $Token->{tag_name};
              return 1;
            } else {
              $LastStartTagName = $Token->{tag_name};
            }
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
            return 1 if $Token->{tag_name} =~ /-/;
            return 1 if $Token->{attrs}->{is};
          }
        

          if ($Token->{type} == END_TAG_TOKEN) {
            ## <!Temma></!Temma>
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
            ## <XML>
            return 1 if @$OE <= 1;
            ## </XML>
          }
        
} elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\>])([^\ \\-]*)\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = COMMENT_START_DASH_STATE;
push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G\!(\-)\-([^\ \\-\>])([^\ \\-]*)\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G\!(\-)\-\-\-\>/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
$Temp = $1;
$TempIndex = $Offset + (pos $Input) - (length $1);
$State = MDO_STATE__;

        $Token = {type => COMMENT_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
$State = DATA_STATE;
push @$Tokens, $Token;
} elsif ($Input =~ /\G([\!])/gcs) {

        $Temp = '';
        $TempIndex = $Offset + (pos $Input);
      
$State = MDO_STATE;
} elsif ($Input =~ /\G([\/])/gcs) {
$State = END_TAG_OPEN_STATE;
} elsif ($Input =~ /\G([\?])/gcs) {
$State = PI_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

        $Token = {type => START_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = q@@;
$State = TAG_NAME_STATE;
} elsif ($Input =~ /\G([\	\\ \
])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G([\])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@
@,
                          di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
        
$State = DATA_STATE_CR;
} elsif ($Input =~ /\G([\>])/gcs) {

            push @$Errors, {type => 'bare stago', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1 - 1};
          
$State = DATA_STATE;

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => $1,
                          di => $DI, index => $Offset + (pos $Input) - (length $1)};
        
} elsif ($Input =~ /\G(.)/gcs) {

        $Token = {type => START_TAG_TOKEN, tn => 0, DTDMode => $DTDMode,
                  di => $DI, index => $AnchoredIndex};
      
$Token->{q<tag_name>} = $1;
$State = TAG_NAME_STATE;
} else {
if ($EOF) {

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          

          push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                          value => q@<@,
                          di => $DI, index => $AnchoredIndex};
        
$State = DATA_STATE;

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE] = sub {
if ($Input =~ /\G([^\\!\%\&\>\ ]+)/gcs) {
$Temp .= $1;

} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} else {
if ($EOF) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};
$StateActions->[TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE_CR] = sub {
if ($Input =~ /\G([\
])/gcs) {
$State = TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\])/gcs) {
$Temp .= q@
@;
$State = TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE_CR;
} elsif ($Input =~ /\G([\!])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
push @{$Token->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
} elsif ($Input =~ /\G([\%])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@%@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = PE_NAME_IN_ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\&])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$Temp = q@&@;
$TempIndex = $Offset + (pos $Input) - (length $1) - 0;
$State = ENT_VALUE_IN_ENT_STATE___CHARREF_STATE;
} elsif ($Input =~ /\G([\>])/gcs) {
$Temp .= $1;

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
} elsif ($Input =~ /\G([\ ])/gcs) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;

            push @$Errors, {type => 'NULL', level => 'm',
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
push @{$Token->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
} elsif ($Input =~ /\G(.)/gcs) {
$State = TEXT_DECL_IN_ENT_VALUE_IN_ENT_STATE;
$Temp .= $1;
} else {
if ($EOF) {

        if ($Temp =~ s{^<\?xml(?=[\x09\x0A\x0C\x20?])(.*?)\?>}{}s) {
          my $text_decl = {data => [[$1, $DI, $TempIndex + 5]], # IndexedString
                           di => $DI, index => $TempIndex};
          $TempIndex += length $1;
          $text_decl->{data}->[0]->[0] =~ s/^([\x09\x0A\x0C\x20]*)//;
          $text_decl->{data}->[0]->[2] += length $1;
          _process_xml_decl $text_decl;
        } else {
          push @$Errors, {level => 's',
                          type => 'no XML decl',
                          di => $DI, index => $TempIndex};
          
        }
      
push @{$Token->{q<value>}}, [$Temp, $DI, $TempIndex];
$State = ENT_VALUE_IN_ENT_STATE;
if ($InMDEntity) { return 1 }
$State = DTD_STATE;

            if (@$OpenMarkedSections) {
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            }
          

            if (defined $CONTEXT) {
              push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                              di => $DI,
                              index => $Offset + pos $Input};
              return 1;
            }
          

            push @$Errors, {type => 'parser:EOF', level => 'm',
                            di => $DI, index => $Offset + (pos $Input)};
          
$DTDMode = q{N/A};
$State = DATA_STATE;

        push @$Tokens, {type => END_OF_DOCTYPE_TOKEN, tn => 0,
                        di => $DI,
                        index => $Offset + pos $Input};
      

          push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                          di => $DI,
                          index => $Offset + pos $Input};
        
return 1;
} else {
return 1;
}
}
return 0;
};

    sub _tokenize ($) {
      TOKENIZER: while (1) {
        my $code = $StateActions->[$State]
            or die "Unknown state |$State|";
        &$code and last TOKENIZER;
      } # TOKENIZER
    } # _tokenize
  
    ## ------ Tree constructor ------
    
    sub _construct_tree ($$) {
      my $self = shift;

      for my $token (@$Tokens) {
        local $_ = $token;
        &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
      }

      $self->dom_tree ($OP);
      @$OP = ();
      @$Tokens = ();
    } # _construct_tree
  
    ## ------ DOM integration ------
    
sub dom_tree ($$) {
  my ($self, $ops) = @_;

  my $doc = $self->{document};
  my $strict = $doc->strict_error_checking;
  $doc->strict_error_checking (0);

  my $nodes = $self->{nodes};
  for my $op (@$ops) {
    if ($op->[0] eq 'insert' or
        $op->[0] eq 'insert-foster' or
        $op->[0] eq 'create') {
      my $data = $op->[1];
      my $el = $doc->create_element_ns
          ($data->{ns}, [$data->{prefix}, $data->{local_name}]);
      $el->manakai_set_source_location (['', $data->{di}, $data->{index}]);
      ## Note that $data->{ns} can be 0.
      for my $attr (@{$data->{attr_list} or []}) {
        $el->manakai_set_attribute_indexed_string_ns
            (@{$attr->{name_args}} => $attr->{value}); # IndexedString
      }
      if ($data->{et} == TEMPLATE_EL) {
        $nodes->[$data->{id}] = $el->content;
        $el->content->manakai_set_source_location
            (['', $data->{di}, $data->{index}]);
      } else {
        $nodes->[$data->{id}] = $el;
      }
      # XXX $data->{script_flags}

      if (defined $data->{form}) {
        my $form = $nodes->[$data->{form}];
        #warn "XXX set form owner of $el to $form if $nodes->[$op->[2]] and $form are in the same home subtree";
      }

      if ($op->[0] eq 'insert') {
        $nodes->[$op->[2]]->append_child ($el);
      } elsif ($op->[0] eq 'insert-foster') {
        my $next_sibling = $nodes->[$op->[2]];
        my $parent = $next_sibling->parent_node;
        if (defined $parent) {
          if ($parent->node_type == $parent->DOCUMENT_NODE) {
            #
          } else {
            $parent->insert_before ($el, $next_sibling);
          }
        } else {
          $nodes->[$op->[3]]->append_child ($el);
        }
      }
    } elsif ($op->[0] eq 'text') {
      $nodes->[$op->[2]]->manakai_append_indexed_string ($op->[1]); # IndexedString
    } elsif ($op->[0] eq 'text-foster') {
      my $next_sibling = $nodes->[$op->[2]];
      my $parent = $next_sibling->parent_node;
      if (defined $parent) {
        if ($parent->node_type == $parent->DOCUMENT_NODE) {
          #
        } else {
          my $prev_sibling = $next_sibling->previous_sibling;
          if (defined $prev_sibling and
              $prev_sibling->node_type == $prev_sibling->TEXT_NODE) {
            $prev_sibling->manakai_append_indexed_string ($op->[1]);
          } else {
            $prev_sibling = $doc->create_text_node ('');
            $prev_sibling->manakai_append_indexed_string ($op->[1]);
            $parent->insert_before ($prev_sibling, $next_sibling);
          }
        }
      } else {
        $nodes->[$op->[3]]->manakai_append_text ($op->[1]);
      }

    } elsif ($op->[0] eq 'append') {
      $nodes->[$op->[2]]->append_child ($nodes->[$op->[1]]);
    } elsif ($op->[0] eq 'append-by-list') {
      my @node = $op->[1]->to_list;
      if (@node and $node[0]->node_type == $node[0]->TEXT_NODE) {
        my $node = shift @node;
        $nodes->[$op->[2]]->manakai_append_indexed_string
            ($node->manakai_get_indexed_string);
      }
      $nodes->[$op->[2]]->append_child ($_) for @node;
    } elsif ($op->[0] eq 'append-foster') {
      my $next_sibling = $nodes->[$op->[2]];
      my $parent = $next_sibling->parent_node;
      if (defined $parent) {
        if ($parent->node_type == $parent->DOCUMENT_NODE) {
          #
        } else {
          $parent->insert_before ($nodes->[$op->[1]], $next_sibling);
        }
      } else {
        $nodes->[$op->[3]]->append_child ($nodes->[$op->[1]]);
      }
    } elsif ($op->[0] eq 'move-children') {
      my $new_parent = $nodes->[$op->[2]];
      # XXX mutation observer?
      for ($nodes->[$op->[1]]->child_nodes->to_list) {
        $new_parent->append_child ($_);
      }

    } elsif ($op->[0] eq 'comment') {
      my $comment = $doc->create_comment (join '', map { $_->[0] } @{$op->[1]->{data}}); # IndexedString
      $comment->manakai_set_source_location
          (['', $op->[1]->{di}, $op->[1]->{index}]);
      $nodes->[$op->[2]]->append_child ($comment);
    } elsif ($op->[0] eq 'pi') {
      my $pi = $doc->create_processing_instruction ($op->[1]->{target}, '');
      $pi->manakai_append_indexed_string ($op->[1]->{data});
      $pi->manakai_set_source_location
          (['', $op->[1]->{di}, $op->[1]->{index}]);
      if ($op->[2] == 1) { # DOCTYPE
        unless ($self->ignore_doctype_pis) {
          local $nodes->[$op->[2]]->owner_document->dom_config->{manakai_allow_doctype_children} = 1;
          $nodes->[$op->[2]]->append_child ($pi);
        }
      } else {
        $nodes->[$op->[2]]->append_child ($pi);
      }
    } elsif ($op->[0] eq 'doctype') {
      my $data = $op->[1];
      my $dt = $doc->implementation->create_document_type
          (defined $data->{name} ? $data->{name} : '',
           defined $data->{public_identifier} ? $data->{public_identifier} : '',
           defined $data->{system_identifier} ? $data->{system_identifier} : '');
      $dt->manakai_set_source_location (['', $data->{di}, $data->{index}]);
      $nodes->[1] = $dt;
      $nodes->[$op->[2]]->append_child ($dt);

    } elsif ($op->[0] eq 'set-if-missing') {
      my $el = $nodes->[$op->[2]];
      for my $attr (@{$op->[1]}) {
        $el->manakai_set_attribute_indexed_string_ns
            (@{$attr->{name_args}} => $attr->{value}) # IndexedString
            unless $el->has_attribute_ns ($attr->{name_args}->[0], $attr->{name_args}->[1]->[1]);
      }

    } elsif ($op->[0] eq 'change-the-encoding') {
      unless ($Confident) {
        my $changed = $self->_change_the_encoding ($op->[1], $op->[2]);
        push @$Callbacks, [$self->onrestartwithencoding, $changed]
            if defined $changed;
      }
      if ($op->[2]->{has_ref}) {
        push @$Errors, {type => 'charref in charset', level => 'm',
                        di => $op->[2]->{di}, index => $op->[2]->{index}};
      }

    } elsif ($op->[0] eq 'script') {
      # XXX insertion point setup
      push @$Callbacks, [$self->onscript, $nodes->[$op->[1]]];
    } elsif ($op->[0] eq 'ignore-script') {
      #warn "XXX set already started flag of $nodes->[$op->[1]]";
    } elsif ($op->[0] eq 'appcache') {
      if (defined $op->[1]) {
        my $value = join '', map { $_->[0] } @{$op->[1]->{value}}; # IndexedString
        push @$Callbacks, [$self->onappcacheselection, length $value ? $value : undef];
      } else {
        push @$Callbacks, [$self->onappcacheselection, undef];
      }

    } elsif ($op->[0] eq 'popped') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_AUD_STY_VID_ELS | OBJ_TEX_ELS) } @{$op->[1]}]];
    } elsif ($op->[0] eq 'stop-parsing') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_AUD_STY_VID_ELS | OBJ_TEX_ELS) } @$OE]];
      #@$OE = ();

      # XXX stop parsing
    } elsif ($op->[0] eq 'abort') {
      push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (APP_AUD_STY_VID_ELS | OBJ_TEX_ELS) } @$OE]];
      #@$OE = ();

      # XXX abort

    } elsif ($op->[0] eq 'remove') {
      my $parent = $nodes->[$op->[1]]->parent_node;
      $parent->remove_child ($nodes->[$op->[1]]) if defined $parent;

    } elsif ($op->[0] eq 'set-compat-mode') {
      $doc->manakai_compat_mode ($op->[1]);
## <XML>
    } elsif ($op->[0] eq 'xml-version') {
      $doc->xml_version ($op->[1]);
    } elsif ($op->[0] eq 'xml-encoding') {
      $doc->xml_encoding ($op->[1]);
    } elsif ($op->[0] eq 'xml-standalone') {
      $doc->xml_standalone ($op->[1]);

    } elsif ($op->[0] eq 'construct-doctype') {
      my $doctype = $nodes->[1];
      my $serialize_cmgroup; $serialize_cmgroup = sub {
        return '(' . (join {'|' => ' | ', ',' => ', '}->{$_[0]->{separators}->[0]->{type} || ''} || '', map {
          if ($_->{items}) {
            $serialize_cmgroup->($_);
          } else {
            $_->{name} . ($_->{repetition} || '');
          }
        } @{$_[0]->{items}}) . ')' . ($_[0]->{repetition} || '');
      };
      for my $data (values %{$DTDDefs->{elements} or {}}) {
        my $node = $doc->create_element_type_definition ($data->{name});
        if (defined $data->{content_keyword}) {
          $node->content_model_text ($data->{content_keyword});
        } elsif (defined $data->{cmgroup}) {
          $node->content_model_text ($serialize_cmgroup->($data->{cmgroup}));
        }
        $node->manakai_set_source_location (['', $data->{di}, $data->{index}])
            if defined $data->{index};
        $doctype->set_element_type_definition_node ($node);
      }
      for my $elname (keys %{$DTDDefs->{attrdefs} or {}}) {
        my $et = $doctype->get_element_type_definition_node ($elname);
        for my $data (@{$DTDDefs->{attrdefs}->{$elname}}) {
          my $node = $doc->create_attribute_definition ($data->{name});
          $node->declared_type ($data->{declared_type} || 0);
          push @{$node->allowed_tokens}, @{$data->{allowed_tokens} or []};
          $node->default_type ($data->{default_type} || 0);
          $node->manakai_append_indexed_string ($data->{value})
              if defined $data->{value};
          $et->set_attribute_definition_node ($node);
          $node->manakai_set_source_location
              (['', $data->{di}, $data->{index}]);
        }
      }
      my $dids = $self->di_data_set;
      for my $data (values %{$DTDDefs->{notations} or {}}) {
        my $node = $doc->create_notation ($data->{name});
        $node->public_id ($data->{public_identifier}); # or undef
        $node->system_id ($data->{system_identifier}); # or undef
        my $base = $dids->[$data->{base_url_di}]->{url};
        $node->declaration_base_uri ($base); # or undef
        $node->manakai_set_source_location (['', $data->{di}, $data->{index}]);
        $doctype->set_notation_node ($node);
      }
      for my $data (values %{$DTDDefs->{ge} or {}}) {
        next unless defined $data->{notation_name};
        my $node = $doc->create_general_entity ($data->{name});
        $node->public_id ($data->{public_identifier}); # or undef
        $node->system_id ($data->{system_identifier}); # or undef
        $node->notation_name ($data->{notation_name}); # or undef
        my $base = $dids->[$data->{base_url_di}]->{url};
        $node->declaration_base_uri ($base); # or undef
        $node->manakai_set_source_location (['', $data->{di}, $data->{index}]);
        $doctype->set_general_entity_node ($node);
      }
## </XML>

    } else {
      die "Unknown operation |$op->[0]|";
    }
  }

  $doc->strict_error_checking ($strict);
} # dom_tree

    sub ignore_doctype_pis ($;$) {
      if (@_ > 1) {
        $_[0]->{ignore_doctype_pis} = $_[1];
      }
      return $_[0]->{ignore_doctype_pis};
    } # ignore_doctype_pis

  
    ## ------ API ------
    
    sub _run ($) {
      my ($self) = @_;
      return 1 if $self->{pause};
      my $is = $self->{input_stream};
      # XXX rewrite loop conditions
      my $length = @$is == 0 ? 0 : defined $is->[0]->[0] ? length $is->[0]->[0] : 0;
      my $in_offset = 0;
      {
        my $len = 10000;
        $len = $length - $in_offset if $in_offset + $len > $length;
        if ($len > 0) {
          $Input = substr $is->[0]->[0], $in_offset, $len;
        } elsif (@$is and not defined $is->[0]->[0]) {
          $Input = '';
          pos ($Input) = 0;
          $EOF = 1;
        } else {
          shift @$is;
          if (@$is) {
            if (defined $is->[0]->[0]) {
              $length = length $is->[0]->[0];
              $in_offset = 0;
              redo;
            } else {
              $Input = '';
              pos ($Input) = 0;
              $EOF = 1;
            }
          } else {
            last;
          }
        }
        {
          $self->_tokenize;
          $self->_construct_tree;

          if (@$Callbacks or @$Errors or $self->{is_sub_parser}) {
            $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
            {
              my $Errors = $Errors;
              my $Callbacks = $Callbacks;

              $self->onerrors->($self, $Errors) if @$Errors;
              @$Errors = ();
              while (@$Callbacks) {
                my $cb = shift @$Callbacks;
                $cb->[0]->($self, $cb->[1]);
              }

              if ($self->{restart}) {
                delete $self->{restart};
                return 0;
              }

              if ($self->{pause}) {
                my $pos = pos $Input;
                $is->[0] = [substr $is->[0]->[0], $in_offset + $pos]
                    if defined $is->[0]->[0];
                $Offset += $pos;
                $self->{saved_states}->{Offset} = $Offset;
                return 1;
              }
            }
            ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};
          }

          redo unless pos $Input == length $Input; # XXX parser pause flag
        }
        $Offset += $len;
        $in_offset += $len;
        redo unless $EOF;
      }
      if ($EOF) {
## <XML>
        unless ($self->{is_sub_parser}) {
          for my $en (keys %{$DTDDefs->{entity_names_in_entity_values} || {}}) {
            my $vt = $DTDDefs->{entity_names_in_entity_values}->{$en};
            $SC->check_hidden_name (name => (substr $en, 1, -2+length $en), onerror => sub {
              $self->onerrors->($self, [{%{$DTDDefs->{entity_names_in_entity_values}->{$en}}, @_}]);
            });
            my $def = $DTDDefs->{ge}->{$en};
            if (defined $def->{notation_name}) {
              push @$Errors, {%{$DTDDefs->{entity_names_in_entity_values}->{$en}},
                              level => 'w',
                              type => 'xml:dtd:entity value:unparsed entref',
                              value => $en};
            }
          } # $en
          $SC->check_ncnames (names => $DTDDefs->{el_ncnames} || {},
                              onerror => sub { $self->onerrors->($self, [{@_}]) });
          for my $en (keys %{$DTDDefs->{entity_names} || {}}) {
            $SC->check_hidden_name (name => (substr $en, 1, -2+length $en), onerror => sub {
              $self->onerrors->($self, [{%{$DTDDefs->{entity_names}->{$en}}, @_}]);
            });
          }
        }
        $self->onerrors->($self, $Errors) if @$Errors;
        @$Errors = ();
## </XML>
        $self->onparsed->($self);
        $self->_cleanup_states;
      }
      return 1;
    } # _run
  

    sub _feed_chars ($$) {
      my ($self, $input) = @_;
      pos ($input->[0]) = 0;
      while ($input->[0] =~ /[\x{0001}-\x{0008}\x{000B}\x{000C}\x{000E}-\x{001F}\x{D800}-\x{DFFF}\x{FFFE}\x{FFFF}\x{007F}-\x{009F}\x{FDD0}-\x{FDEF}\x{1FFFE}-\x{1FFFF}\x{2FFFE}-\x{2FFFF}\x{3FFFE}-\x{3FFFF}\x{4FFFE}-\x{4FFFF}\x{5FFFE}-\x{5FFFF}\x{6FFFE}-\x{6FFFF}\x{7FFFE}-\x{7FFFF}\x{8FFFE}-\x{8FFFF}\x{9FFFE}-\x{9FFFF}\x{AFFFE}-\x{AFFFF}\x{BFFFE}-\x{BFFFF}\x{CFFFE}-\x{CFFFF}\x{DFFFE}-\x{DFFFF}\x{EFFFE}-\x{EFFFF}\x{FFFFE}-\x{FFFFF}\x{10FFFE}-\x{10FFFF}]/gcx) {
        my $index = $-[0];
        my $char = ord substr $input->[0], $index, 1;
        my $level = (substr $input->[0], $index, 1) =~ /[\x{0001}-\x{0008}\x{000B}\x{000C}\x{000E}-\x{001F}\x{D800}-\x{DFFF}\x{FFFE}\x{FFFF}]/ ? 'm' : 'w';
        if ($char < 0x100) {
          push @$Errors, {type => 'control char', level => $level,
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        } elsif ($char < 0xE000) {
          push @$Errors, {type => 'char:surrogate', level => $level,
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        } else {
          push @$Errors, {type => 'nonchar', level => $level,
                          text => (sprintf 'U+%04X', $char),
                          di => $DI, index => $index};
        }
      }
      push @{$self->{input_stream}}, $input;

      return $self->_run;
    } # _feed_chars
  

    sub _feed_eof ($) {
      my $self = $_[0];
      push @{$self->{input_stream}}, [undef];
      return $self->_run;
    } # _feed_eof
  

    sub parse_char_string ($$$) {
      my $self = $_[0];
      my $input = [$_[1]]; # string copy

      $self->{document} = my $doc = $_[2];
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      ## 
      ## <XML>
      $doc->manakai_is_html (0);
      ## </XML>
      $doc->manakai_compat_mode ('no quirks');
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];
      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      $Confident = 1; # irrelevant
      $State = DATA_STATE;;
      ## <!Temma>
      $IM = BEFORE_XML_DECLARATION_IM;
      ## </!Temma>

      $self->{input_stream} = [];
      my $dids = $self->di_data_set;
      $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
      $dids->[$DI] ||= {} if $DI >= 0;
      ## <XML>
      $self->{BaseURLDI} = $BaseURLDI = $DI;
      ## </XML>
      $doc->manakai_set_source_location (['', $DI, 0]);

      local $self->{onextentref};
      $self->_feed_chars ($input) or die "Can't restart";
      $self->_feed_eof or die "Can't restart";

      return;
    } # parse_char_string
  

    sub parse_char_string_with_context ($$$$) {
      my $self = $_[0];
      my $context = $_[2]; # an Element or undef

      ## HTML fragment parsing algorithm
      ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-html-fragments>.

      ## XML fragment parsing algorithm
      ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-xhtml-fragments>

      ## 1.
      $self->{document} = my $doc = $_[3]; # an empty Document
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      my $nodes = $self->{nodes} = [$doc];
      ## 

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      $State = DATA_STATE;;

      ## 3.
      my $input = [$_[1]]; # string copy
      $self->{input_stream} = [];
      my $dids = $self->di_data_set;
      $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
      $dids->[$DI] ||= {} if $DI >= 0;
      ## <XML>
      $self->{BaseURLDI} = $BaseURLDI = $DI;
      ## </XML>

      ## HTML 4. / XML 3. (cnt.)
      my $root;
      if (defined $context) {
        $IM = IN_ELEMENT_IM;

        ## HTML 4.1. / XML 2., 4., 6.
        my $node_ns = $context->namespace_uri || '';
        my $node_ln = $context->local_name;
        if ($node_ns eq 'http://www.w3.org/1999/xhtml') {
          ## 
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => $Element2Type->{(HTMLNS)}->{$node_ln} || $Element2Type->{(HTMLNS)}->{'*'},
                      aet => $Element2Type->{(HTMLNS)}->{$node_ln} || $Element2Type->{(HTMLNS)}->{'*'}};
        ## 
        } else {
          $CONTEXT = {id => $NEXT_ID++,
                      #token => undef,
                      #di => $token->{di}, index => $token->{index},
                      ns => 0,
                      local_name => $node_ln,
                      attr_list => [], # not relevant
                      et => 0,
                      aet => 0};
        }
        ## <XML>
        my $nsmap = {};
        {
          my $prefixes = {};
          my $p = $context;
          while ($p and $p->node_type == 1) { # ELEMENT_NODE
            $prefixes->{$_->local_name} = 1 for grep {
              ($_->namespace_uri || '') eq q<http://www.w3.org/2000/xmlns/>;
            } @{$p->attributes or []};
            my $prefix = $p->prefix;
            $prefixes->{$prefix} = 1 if defined $prefix;
            $p = $p->parent_node;
          }
          for ('', keys %$prefixes) {
            $nsmap->{$_} = $context->lookup_namespace_uri ($_);
          }
          $nsmap->{xml} = q<http://www.w3.org/XML/1998/namespace>;
          $nsmap->{xmlns} = q<http://www.w3.org/2000/xmlns/>;
        }
        $CONTEXT->{nsmap} = $nsmap;
        ## </XML>
        $nodes->[$CONTEXT->{id}] = $context;

        ## 
        ## <XML>
        $root = $doc->create_element_ns
            ($context->namespace_uri, [$context->prefix, $context->local_name]);
        ## </XML>

        ## HTML 4.3.
        $doc->append_child ($root);

        ## 
        ## <XML>
        @$OE = ({id => $NEXT_ID++,
                 #token => undef,
                 #di => $token->{di}, index => $token->{index},
                 ns => $CONTEXT->{ns},
                 local_name => $CONTEXT->{local_name},
                 nsmap => $CONTEXT->{nsmap},
                 attr_list => [],
                 et => $CONTEXT->{et},
                 aet => $CONTEXT->{aet}});
        ## </XML>

        ## HTML 4.5.
        if ($node_ns eq 'http://www.w3.org/1999/xhtml' and
            $node_ln eq 'template') {
          ## 
          ## <XML>
          $root = $root->content;
          ## </XML>
        }
        $nodes->[$OE->[-1]->{id}] = $root;

        ## 
      } else { # $context
        $IM = BEFORE_XML_DECLARATION_IM;
      } # $context

      ## HTML 5.
      $Confident = 1; # irrelevant

      ## HTML 6. / XML 3. (cnt.)
      local $self->{onextentref};
      $self->_feed_chars ($input) or die "Can't restart";
      $self->_feed_eof or die "Can't restart";

      ## XML 5. If not well-formed, throw SyntaxError - should be
      ## handled by callee using $self->onerror.

      ## 7.
      return defined $context ? $root->child_nodes : $doc->child_nodes;
    } # parse_char_string_with_context
  

    sub parse_chars_start ($$) {
      my ($self, $doc) = @_;

      $self->{input_stream} = [];
      $self->{document} = $doc;
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->manakai_is_html (0);
      $doc->manakai_compat_mode ('no quirks');
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      $Confident = 1; # irrelevant
      $State = DATA_STATE;;
      $IM = BEFORE_XML_DECLARATION_IM;

      my $dids = $self->di_data_set;
      $DI = @$dids || 1;
      $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
      $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
      $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
      $doc->manakai_set_source_location (['', $DI, 0]);
      ## Note that $DI != $source_di to support document.write()'s
      ## insertion.
      ## <XML>
      $self->{BaseURLDI} = $BaseURLDI = $source_di;
      ## </XML>

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_chars_start
  

    sub parse_chars_feed ($$) {
      my $self = $_[0];
      my $input = [$_[1]]; # string copy

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};

      $self->_feed_chars ($input) or die "Can't restart";

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_chars_feed

    sub parse_chars_end ($) {
      my $self = $_[0];
      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};

      $self->_feed_eof or die "Can't restart";
      
      return;
    } # parse_chars_end

## NOTE: HTML5 spec says that the encoding layer MUST NOT strip BOM
## and the HTML layer MUST ignore it.  However, we does strip BOM in
## the encoding layer and the HTML layer does not ignore any U+FEFF,
## because the core part of our HTML parser expects a string of
## character, not a string of bytes or code units or anything which
## might contain a BOM.  Therefore, any parser interface that accepts
## a string of bytes, such as |parse_byte_string| in this module, must
## ensure that it does strip the BOM and never strip any ZWNBSP.

## XXX The policy mentioned above might change when we implement
## Encoding Standard spec.

  

    sub parse_byte_string ($$$$) {
      my $self = $_[0];

      $self->{document} = my $doc = $_[3];
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->manakai_is_html (0);
      $doc->manakai_compat_mode ('no quirks');
      $self->{can_restart} = 1;

      PARSER: {
        $self->{input_stream} = [];
        $self->{nodes} = [$doc];
        $doc->remove_child ($_) for $doc->child_nodes->to_list;

        local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
        $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
        $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};

        my $inputref = \($_[2]);
        $self->_encoding_sniffing
            (transport_encoding_name => $_[1],
             read_head => sub {
          return \substr $$inputref, 0, 1024;
        }); # $Confident is set within this method.
        $doc->input_encoding ($self->{input_encoding});

        my $input = [decode $self->{input_encoding}, $$inputref]; # XXXencoding
        my $dids = $self->di_data_set;
        $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
        $dids->[$DI] ||= {} if $DI >= 0;
        $doc->manakai_set_source_location (['', $DI, 0]);
        ## <XML>
        $self->{BaseURLDI} = $BaseURLDI = $DI;
        ## </XML>

        $State = DATA_STATE;;
        $IM = BEFORE_XML_DECLARATION_IM;

        local $self->{onextentref};
        $self->_feed_chars ($input) or redo PARSER;
        $self->_feed_eof or redo PARSER;
      } # PARSER

      return;
    } # parse_byte_string
  

    sub _parse_bytes_init ($) {
      my $self = $_[0];

      my $doc = $self->{document};
      $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
      $doc->remove_child ($_) for $doc->child_nodes->to_list;
      $self->{nodes} = [$doc];

      delete $self->{parse_bytes_started};
      $self->{input_stream} = [];
      $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      $State = DATA_STATE;;
      $IM = BEFORE_XML_DECLARATION_IM;

      my $dids = $self->di_data_set;
      $DI = @$dids || 1;
      $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
      $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
      $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
      $doc->manakai_set_source_location (['', $DI, 0]);
      ## Note that $DI != $source_di to support document.write()'s
      ## insertion.
      ## <XML>
      $self->{BaseURLDI} = $BaseURLDI = $source_di;
      ## </XML>
    } # _parse_bytes_init
  

    sub _parse_bytes_start_parsing ($;%) {
      my ($self, %args) = @_;
      
      $self->_encoding_sniffing
          (transport_encoding_name => $self->{transport_encoding_label},
           no_body_data_yet => $args{no_body_data_yet},
           read_head => sub {
             return \(substr $self->{byte_buffer}, 0, 1024);
           }); # $Confident is set within this method.
      if (not defined $self->{input_encoding} and $args{no_body_data_yet}) {
        return 1;
      }
      $self->{document}->input_encoding ($self->{input_encoding});

      $self->{parse_bytes_started} = 1;

      my $input = [decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET]; # XXXencoding

      $self->_feed_chars ($input) or return 0;

      return 1;
    } # _parse_bytes_start_parsing
  

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{document} = my $doc = $_[2];
      $doc->manakai_is_html (0);
      $self->{can_restart} = 1;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_start
  

    ## The $args{start_parsing} flag should be set true if it has
    ## taken more than 500ms from the start of overall parsing
    ## process. XXX should this be a separate method?
    sub parse_bytes_feed ($$;%) {
      my ($self, undef, %args) = @_;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};

      $self->{byte_buffer} .= $_[1];
      $self->{byte_buffer_orig} .= $_[1];
      PARSER: {
        if ($self->{parse_bytes_started}) {
          my $input = [decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET]; # XXXencoding
          if (length $self->{byte_buffer} and 0 == length $input->[0]) {
            substr ($self->{byte_buffer}, 0, 1) = '';
            $input->[0] .= "\x{FFFD}" . decode $self->{input_encoding}, $self->{byte_buffer}, Encode::FB_QUIET; # XXX Encoding Standard
          }

          $self->_feed_chars ($input) or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        } else {
          if ($args{start_parsing} or 1024 <= length $self->{byte_buffer}) {
            $self->_parse_bytes_start_parsing or do {
              $self->{byte_buffer} = $self->{byte_buffer_orig};
              $self->_parse_bytes_init;
              redo PARSER;
            };
          }
        }
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_feed

    sub parse_bytes_end ($) {
      my $self = $_[0];
      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};

      PARSER: {
        unless ($self->{parse_bytes_started}) {
          $self->_parse_bytes_start_parsing or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        }

        if (length $self->{byte_buffer}) {
          my $input = [decode $self->{input_encoding}, $self->{byte_buffer}]; # XXX encoding
          $self->_feed_chars ($input) or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        }

        $self->_feed_eof or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          $self->_parse_bytes_init;
          redo PARSER;
        };
      } # PARSER
      
      return;
    } # parse_bytes_end
  


{
  package Web::XML::Parser::AttrEntityParser;
  push our @ISA, qw(Web::XML::Parser);

  sub parse ($$$) {
    my ($self, $main, $in) = @_;

    local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    $Confident = 1; # irrelevant
    {
      package Web::XML::Parser;
      if ($in->{in_default_attr}) {
        $State = DEFAULT_ATTR_VALUE_IN_ENT_STATE;;
      } else {
        $State = ATTR_VALUE_IN_ENT_STATE;;
      }
      $IM = BEFORE_XML_DECLARATION_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [@{$in->{entity}->{value}}];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $BaseURLDI = $self->{BaseURLDI} = defined $main->{BaseURLDI} ? $main->{BaseURLDI} : $main->di;
    require Web::HTML::SourceMap;
    $dids->[$DI] ||= {
      name => '&'.$in->{entity}->{name}.';',
      map => Web::HTML::SourceMap::indexed_string_to_mapping ($self->{input_stream}),
    } if $DI >= 0;

    $Attr = $main->{saved_states}->{Attr};
    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;

    $self->_run or die "Can't restart";
    $self->_feed_eof or die "Can't restart";
  } # parse

  sub _construct_tree ($) {
    #
  } # _construct_tree
}

{
  package Web::XML::Parser::ContentEntityParser;
  push our @ISA, qw(Web::XML::Parser);

  sub parse ($$$) {
    my ($self, $main, $in) = @_;

    local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    $Confident = 1; # irrelevant
    {
      package Web::XML::Parser;
      $State = DATA_STATE;;
      $IM = IN_ELEMENT_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [@{$in->{entity}->{value}}];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $BaseURLDI = $self->{BaseURLDI} = defined $main->{BaseURLDI} ? $main->{BaseURLDI} : $main->di;
    require Web::HTML::SourceMap;
    $dids->[$DI] ||= {
      name => '&'.$in->{entity}->{name}.';',
      map => Web::HTML::SourceMap::indexed_string_to_mapping ($self->{input_stream}),
    } if $DI >= 0;

    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;

    my $root = $doc->create_element_ns (undef, 'dummy');
    @$OE = ({id => $NEXT_ID++,
             #token => undef,
             #di => $token->{di}, index => $token->{index},
             ns => undef,
             local_name => 'dummy',
             attr_list => [],
             nsmap => $main->{saved_lists}->{OE}->[-1]->{nsmap},
             cm_type => $main->{saved_lists}->{OE}->[-1]->{cm_type},
             et => 0,
             aet => 0});
    $self->{nodes}->[$CONTEXT = $OE->[-1]->{id}] = $root;

    $self->_run or die "Can't restart";
    $self->_feed_eof or die "Can't restart";
  } # parse

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{main_parser} = $_[2];
      $self->{can_restart} = 1;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_start

  sub _parse_bytes_init ($$) {
    my $self = $_[0];
    my $main = $self->{main_parser};

    delete $self->{parse_bytes_started};

    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    {
      package Web::XML::Parser;
      $State = DATA_STATE;;
      $IM = BEFORE_CONTENT_TEXT_DECLARATION_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $self->{BaseURLDI} = $BaseURLDI = $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $dids->[$DI] ||= {} if $DI >= 0;

    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;

    my $root = $doc->create_element_ns (undef, 'dummy');
    @$OE = ({id => $NEXT_ID++,
             #token => undef,
             #di => $token->{di}, index => $token->{index},
             ns => undef,
             local_name => 'dummy',
             attr_list => [],
             nsmap => $main->{saved_lists}->{OE}->[-1]->{nsmap},
             et => 0,
             aet => 0});
    $self->{nodes}->[$CONTEXT = $OE->[-1]->{id}] = $root;
  } # _parse_bytes_init
}

{
  package Web::XML::Parser::DTDEntityParser;
  push our @ISA, qw(Web::XML::Parser);

  sub parse ($$$) {
    my ($self, $main, $in) = @_;

    local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    $Confident = 1; # irrelevant
    {
      package Web::XML::Parser;
      $State = DTD_STATE;;
      $IM = IN_SUBSET_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [@{$in->{entity}->{value}}];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $BaseURLDI = $self->{BaseURLDI} = defined $main->{BaseURLDI} ? $main->{BaseURLDI} : $main->di;
    require Web::HTML::SourceMap;
    $dids->[$DI] ||= {
      name => '%'.$in->{entity}->{name}.';',
      map => Web::HTML::SourceMap::indexed_string_to_mapping ($self->{input_stream}),
    } if $DI >= 0;

    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    if ($main->{saved_states}->{DTDMode} eq 'internal subset' or
        $main->{saved_states}->{DTDMode} eq 'parameter entity in internal subset') {
      $DTDMode = 'parameter entity in internal subset';
    } else {
      $DTDMode = 'parameter entity';
    }

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE

    $self->_run or die "Can't restart";
    $self->_feed_eof or die "Can't restart";
  } # parse

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{main_parser} = $_[2];
      $self->{can_restart} = 1;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_start

  sub _parse_bytes_init ($$) {
    my $self = $_[0];
    my $main = $self->{main_parser};

    delete $self->{parse_bytes_started};

    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    {
      package Web::XML::Parser;
      $State = DTD_STATE;;
      $IM = BEFORE_DTD_TEXT_DECLARATION_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $self->{BaseURLDI} = $BaseURLDI = $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $dids->[$DI] ||= {} if $DI >= 0;

    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    $DTDMode = 'parameter entity';

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE
  } # _parse_bytes_init
}

{
  package Web::XML::Parser::EntityValueEntityParser;
  push our @ISA, qw(Web::XML::Parser);

  sub parse ($$$) {
    my ($self, $main, $in) = @_;

    local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    $Confident = 1; # irrelevant
    {
      package Web::XML::Parser;
      $State = ENT_VALUE_IN_ENT_STATE;;
      $IM = IN_SUBSET_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [@{$in->{entity}->{value}}];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $BaseURLDI = $self->{BaseURLDI} = defined $main->{BaseURLDI} ? $main->{BaseURLDI} : $main->di;
    require Web::HTML::SourceMap;
    $dids->[$DI] ||= {
      name => '%'.$in->{entity}->{name}.';',
      map => Web::HTML::SourceMap::indexed_string_to_mapping ($self->{input_stream}),
    } if $DI >= 0;

    $Token = $main->{saved_states}->{Token};
    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    if ($main->{saved_states}->{DTDMode} eq 'internal subset' or
        $main->{saved_states}->{DTDMode} eq 'parameter entity in internal subset') {
      $DTDMode = 'parameter entity in internal subset';
    } else {
      $DTDMode = 'parameter entity';
    }

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE

    $self->_run or die "Can't restart";
    $self->_feed_eof or die "Can't restart";
  } # parse

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{main_parser} = $_[2];
      $self->{can_restart} = 1;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_start

  sub _parse_bytes_init ($$) {
    my $self = $_[0];
    my $main = $self->{main_parser};

    delete $self->{parse_bytes_started};

    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    {
      package Web::XML::Parser;
      $State = B_ENT_VALUE_IN_ENT_STATE;;
      $IM = IN_SUBSET_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    $self->{onerrors} = $main->onerrors;
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $self->{BaseURLDI} = $BaseURLDI = $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $dids->[$DI] ||= {} if $DI >= 0;

    $Token = $main->{saved_states}->{Token};
    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    $DTDMode = 'parameter entity';

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE
  } # _parse_bytes_init
}

{
  package Web::XML::Parser::MDEntityParser;
  push our @ISA, qw(Web::XML::Parser);

  sub parse ($$$) {
    my ($self, $main, $in) = @_;

    $self->{InMDEntity} = 1;
    local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    $Confident = 1; # irrelevant
    {
      package Web::XML::Parser;
      $State = $main->{saved_states}->{OriginalState}->[0];
      $IM = IN_SUBSET_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    my $onerrors = $main->onerrors;
    $self->{onerrors} = sub {
      my ($self, $errors) = @_;
      $onerrors->($self, [grep { $_->{type} ne 'parser:EOF' } @$errors]);
    };
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [@{$in->{entity}->{value}}];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $BaseURLDI = $self->{BaseURLDI} = defined $main->{BaseURLDI} ? $main->{BaseURLDI} : $main->di;
    require Web::HTML::SourceMap;
    $dids->[$DI] ||= {
      name => '%'.$in->{entity}->{name}.';',
      map => Web::HTML::SourceMap::indexed_string_to_mapping ($self->{input_stream}),
    } if $DI >= 0;

    $Token = $main->{saved_states}->{Token};
    $Attr = $main->{saved_states}->{Attr};
    $self->{saved_lists}->{OpenCMGroups} = $OpenCMGroups
        = $main->{saved_lists}->{OpenCMGroups};
    $InitialCMGroupDepth = defined $self->{InitialCMGroupDepth}
        ? $self->{InitialCMGroupDepth} : @{$main->{saved_lists}->{OpenCMGroups}};
    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    if ($main->{saved_states}->{DTDMode} eq 'internal subset' or
        $main->{saved_states}->{DTDMode} eq 'parameter entity in internal subset') {
      $DTDMode = 'parameter entity in internal subset';
    } else {
      $DTDMode = 'parameter entity';
    }

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE

    $self->_run or die "Can't restart";
    $self->_feed_eof or die "Can't restart";
  } # parse

    sub parse_bytes_start ($$$) {
      my $self = $_[0];

      $self->{byte_buffer} = '';
      $self->{byte_buffer_orig} = '';
      $self->{transport_encoding_label} = $_[1];

      $self->{main_parser} = $_[2];
      $self->{can_restart} = 1;

      $self->{InMDEntity} = 1;

      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      PARSER: {
        $self->_parse_bytes_init;
        $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
          $self->{byte_buffer} = $self->{byte_buffer_orig};
          redo PARSER;
        };
      } # PARSER

      $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, DTDMode => $DTDMode, EOF => $EOF, IM => $IM, InLiteral => $InLiteral, InitialCMGroupDepth => $InitialCMGroupDepth, LastCMItem => $LastCMItem, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, OriginalState => $OriginalState, State => $State, Temp => $Temp, TempIndex => $TempIndex, TempRef => $TempRef, Token => $Token};
      return;
    } # parse_bytes_start

  sub _parse_bytes_init ($$) {
    my $self = $_[0];
    my $main = $self->{main_parser};

    delete $self->{parse_bytes_started};

    $AnchoredIndex = 0;
$InitialCMGroupDepth = 0;
$NEXT_ID = 1;
$Offset = 0;
$DTDMode = q{N/A};
$self->{saved_lists} = {Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), OpenCMGroups => ($OpenCMGroups = []), OpenMarkedSections => ($OpenMarkedSections = []), Tokens => ($Tokens = [])};
$self->{saved_maps} = {DTDDefs => ($DTDDefs = {})};
    $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
    {
      package Web::XML::Parser;
      $State = $main->{saved_states}->{OriginalState}->[1];
      $IM = IN_SUBSET_IM;
    }

    my $doc = $self->{document} = $main->{document}->implementation->create_document;
    $doc->manakai_is_html ($main->{document}->manakai_is_html);
    $doc->manakai_compat_mode ($main->{document}->manakai_compat_mode);
    for (qw(onextentref entity_expansion_count
            max_entity_depth max_entity_expansions)) {
      $self->{$_} = $main->{$_};
    }
    $self->{onerror} = $main->onerror;
    my $onerrors = $main->onerrors;
    $self->{onerrors} = sub {
      my ($self, $errors) = @_;
      $onerrors->($self, [grep { $_->{type} ne 'parser:EOF' } @$errors]);
    };
    $self->{nodes} = [$doc];

    $self->{entity_depth} = ($main->{entity_depth} || 0) + 1;
    ${$self->{entity_expansion_count} = $main->{entity_expansion_count} ||= \(my $v = 0)}++;

    $self->{input_stream} = [];
    $self->{di_data_set} = my $dids = $main->di_data_set;
    $self->{BaseURLDI} = $BaseURLDI = $DI = $self->{di} = defined $self->{di} ? $self->{di} : @$dids;
    $dids->[$DI] ||= {} if $DI >= 0;

    $Token = $main->{saved_states}->{Token};
    $Attr = $main->{saved_states}->{Attr};
    $self->{saved_lists}->{OpenCMGroups} = $OpenCMGroups
        = $main->{saved_lists}->{OpenCMGroups};
    $InitialCMGroupDepth = $self->{InitialCMGroupDepth} || @{$main->{saved_lists}->{OpenCMGroups}};
    $self->{saved_maps}->{DTDDefs} = $DTDDefs = $main->{saved_maps}->{DTDDefs};
    $self->{is_sub_parser} = 1;
    $DTDMode = 'parameter entity';

    $NEXT_ID++;
    $self->{nodes}->[$CONTEXT = 1] = $main->{nodes}->[1]; # DOCTYPE
  } # _parse_bytes_init

}

    sub _parse_sub_done ($) {
      my $self = $_[0];
      local ($AnchoredIndex, $Attr, $BaseURLDI, $CONTEXT, $Callbacks, $Confident, $DI, $DTDDefs, $DTDMode, $EOF, $Errors, $IM, $IframeSrcdoc, $InLiteral, $InMDEntity, $InitialCMGroupDepth, $Input, $LastCMItem, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $OpenCMGroups, $OpenMarkedSections, $OriginalState, $SC, $Scripting, $State, $Temp, $TempIndex, $TempRef, $Token, $Tokens);
      $BaseURLDI = $self->{BaseURLDI};
$IframeSrcdoc = $self->{IframeSrcdoc};
$InMDEntity = $self->{InMDEntity};
$SC = $self->_sc;
$Scripting = $self->{Scripting};
      ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $DTDMode, $EOF, $IM, $InLiteral, $InitialCMGroupDepth, $LastCMItem, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $OriginalState, $State, $Temp, $TempIndex, $TempRef, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI DTDMode EOF IM InLiteral InitialCMGroupDepth LastCMItem LastStartTagName NEXT_ID ORIGINAL_IM Offset OriginalState State Temp TempIndex TempRef Token)};
($Callbacks, $Errors, $OE, $OP, $OpenCMGroups, $OpenMarkedSections, $Tokens) = @{$self->{saved_lists}}{qw(Callbacks Errors OE OP OpenCMGroups OpenMarkedSections Tokens)};
($DTDDefs) = @{$self->{saved_maps}}{qw(DTDDefs)};

      $self->_run or die "Can't restart";
    } # _parse_sub_done
  

    1;

=head1 LICENSE

Copyright 2007-2015 Wakaba <wakaba@suikawiki.org>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

This library derived from a JSON file, which contains data extracted
from HTML Standard.  "Written by Ian Hickson (Google, ian@hixie.ch) -
Parts  Copyright 2004-2014 Apple Inc., Mozilla Foundation, and Opera
Software ASA; You are granted a license to use, reproduce and create
derivative works of this document."

=cut

  